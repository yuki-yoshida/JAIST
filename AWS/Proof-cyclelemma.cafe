require Proof Proof.cafe
--> **************************************************************************************
--> Initial Cont Lemma: If there is an initail resource, then there is an applicable rule.
--> **************************************************************************************
--> ******************************************
--> Step 2-0: Define a predicate to be proved.
--> ******************************************
module! ProofInitialCont {
  protecting(ProofBase)

  vars B1 B2 : Bool

  pred (_when _) : Bool Bool { prec: 64 r-assoc }
  eq (B1 when B2)
     = B2 implies B1 .

  var S : State

  pred invcont : State
  eq invcont(S) 
    = cont(S) = true
    when inv(S) .
}

select ProofInitialCont .

--> Proof of the initialcont lemma
--> When there is an initial resource in state S
--> Cyclic Dependency Theorem ensures there is an initial resource RS
--> where DDSC(RS,S) does not include any initial resources.
--> So, we can assume that S = < (res(trs, idRS, initial) sRS), sPR >
--> and someRSInStates(DDSC(res(trs, idRS, initial),S),initial) = false .
--> **************************************************************************
--> Step 2-1: Begin with the cases each of which matches to LHS of each rule.
--> **************************************************************************
:goal {eq invcont(< (res(trs, idRS, initial) sRS), sPR >) = true .}
--> ************************************************************
--> Step 2-4: Think which rule can be applied to the next state.
--> ************************************************************
-- The next rule should be R01 for the resource of idRS.
--> ************************************************************************
--> Step 2-5: Split the general case into cases which collectively cover
--> the general case and one of which matches to LHS of the applicable rule.
--> ************************************************************************
--> The case already matches to LHS of R01.
--> ***********************************************************
--> Step 2-6: Split the general case into cases where 
--> the condition of the applicable rule does or does not hold.
--> ***********************************************************
-- The condition of R01 does or does not hold for the resource o idRS.
:csp { 
  eq allPROfRSInStates(sPR,idRS,ready) = true .
  eq sPR = (prop(tpr,idPR,notready,idRS,idRRS) sPR') .
}
-- Case 1: When all of or properties of the resource idRS are ready:
:apply (rd) -- 1
-- Case 2: When at least one of properties of the resource idRS is notready.
--> ***********************************************************
--> Step 2-7: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The resource referred by the property does or does not exist.
:csp {
  eq existRS(sRS,idRRS) = false .
  eq sRS = (res(trs',idRRS,srs) sRS') .
}
-- Case 2-1: When the resource referred by the property does not exist:
:apply (rd) -- 2-1
-- Case 2-2: When the resource referred by the property exists:
-- The state of the resource is initial or started.
:csp { 
  eq srs = initial .
  eq srs = started .
}
-- Case 2-2-1: When the resource idRRS is initial:
--> ******************************************************************************
--> Step 2-8: When falling in a cyclic situation, use the Cyclic Dependency Lemma.
--> ******************************************************************************
-- The Cyclic Dependency Lemma rejects this case.
:init [Cycle] by {
  RS:Resource <- res(trs,idRS,initial);
  S:State <- < (res(trs,idRS,initial) sRS), sPR >;
}
:apply (rd) -- 2-2-1
-- Case 2-2-2: When the resource idRRS is started:
:apply (rd) -- 2-2-2
show proof
