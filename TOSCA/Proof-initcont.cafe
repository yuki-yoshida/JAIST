require Proof Proof.cafe

--> ****************************
--> (1) init(S) implies cont(S).
--> ****************************

--> ******************************************
--> Step 1-0: Define a predicate to be proved.
--> ******************************************
module! ProofInitCont {
  protecting(ProofBase)

  var S : State
  var T : NDType
  var I : NDID
  var SetND : SetOfNode
  var SetCP : SetOfCapability
  var SetRQ : SetOfRequirement
  var SetRL : SetOfRelationship
  var M : PoolOfMsg

  -- Predicate to be proved.
  pred initcont : State .
  eq initcont(S) = init(S) implies cont(S) .

  -- initial-cont lemma: 
  eq cont(< (node(T, I, initial) SetND), 
            SetCP, SetRQ, SetRL, M >) = true .
}

--> Proof of (1) init(S) implies cont(S).
select ProofInitCont .

--> *******************************************
--> Step 1-1: Begin with the most general case. 
--> *******************************************
:goal {eq initcont(< sND, sCP, sRQ, sRL, mp >) = true .}

--> *******************************************************************************
--> Step 1-2: Think which rule is applied to the initial state in an unproved case. 
--> *******************************************************************************
-- The first rule is R01.

--> ********************************************************************
--> Step 1-3: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- LHS of R01 requires at least one initial node.
:csp { 
  eq sND = empND .
  eq sND = (node(tnd,idND,snd) sND') .
}
-- Case 1: When there is no node:
:apply (rd) -- 1
-- Case 2: When there is a node:
-- The state of the node is initial, created, or started.
:csp { 
  eq snd = initial .
  eq snd = created .
  eq snd = started .
}
:apply (rd)
:apply (rd)
:apply (rd)
show proof
select
--> Totally 1 goal should be proved.
