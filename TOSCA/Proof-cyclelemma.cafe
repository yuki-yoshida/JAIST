require Proof Proof.cafe
--> **********************************************************************************
--> Initial Cont Lemma: If there is an initail node, then there is an applicable rule.
--> **********************************************************************************
--> ******************************************
--> Step 2-0: Define a predicate to be proved.
--> ******************************************
module! ProofInitialCont {
  pr(PROOFfuns)

  pred invcont : State
  eq invcont(S:State) = wfs(S) and inv(S) implies cont(S) .
}

select ProofInitialCont .

--> Proof of the initialcont lemma
--> When there is an initial node in state S
--> Cyclic Dependency Theorem ensures there is an initial node N
--> where DDSR01(N,S) does not include any initial nodes.
--> So, we can assume that S = < (node(tnd, idND, initial) sND), sCP, sRQ, sRL, mp >
--> and someNDInStates(DDSR01(node(tnd, idND, initial),S),initial) = false .
--> **************************************************************************
--> Step 2-1: Begin with the cases each of which matches to LHS of each rules.
--> **************************************************************************
:goal {eq invcont(< (node(tnd, idND, initial) sND), sCP, sRQ, sRL, mp >) = true .}
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R01 for the node of idND.
--> ****************************************************
--> Step 1-4: Split the first rule case into cases where
-->  the condition of the rule does or does not hold.
--> ****************************************************
-- The condition of R01 does or does not hold for the node of idND.
-- The states of all of the hostedOn requirements of the node are or are not ready.
:csp { 
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
  eq sRQ = (req(hostedOn,idRQ,unbound,idND) sRQ') .
  eq sRQ = (req(hostedOn,idRQ,waiting,idND) sRQ') .
}
-- Case 1: When all of the hostedOn requirements are ready:
:apply (rd) -- 1
-- Case 2: When there is an unbound hostedOn requirement of the node:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R04 for the requirement of idRQ.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The relationship of the requirement of idRQ does or does not exist.
:csp {
  eq onlyOneRLOfRQ(sRL,idRQ) = false .
  eq sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL') .
}
-- Case 2-1: When the relationship of the requirement of idRQ does not exist:
:apply (rd) -- 2-1
-- Case 2-2: When the relationship of the requirement of idRQ exists:
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The capability of the relationship does or does not exist.
:csp {
  eq existCP(sCP,idCP) = false .
  eq sCP = (cap(hostedOn,idCP,scp,idND') sCP') .
}
-- Case 2-2-1: When the capability of the relationship does not exist:
:apply (rd) -- 2-2-1
-- Case 2-2-2: When the capability of the relationship exists:
-- The node of the capability of idCP is or is not the same of the node of the requiement of idRQ.
:ctf {
  eq idND' = idND .
}
-- Case 2-2-2-1: When the node of the capability of idCP is the same of the node of the requiement of idRQ:
:apply (rd) -- 2-2-2-1
-- Case 2-2-2-2: When the node of the capability of idCP is not the same of the node of the requiement of idRQ:
--> ********************************************************************
--> Step 1-3: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- LHS of R04 requires a relationship and an available capability of the requirement of idRQ.
-- The state of the capability of idCP is closed, open, or available.
:csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
-- Case 2-2-2-2-1: When the capability of idCP is closed:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R03 for the capability of idCP
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The node of the capability of idCP does or does not exist.
:csp {
  eq existND(sND,idND') = false .
  eq sND = (node(tnd',idND',snd') sND') .
}
-- Case 2-2-2-2-1-1: When the node of the capability of idCP does not exist:
:apply (rd) -- 2-2-2-2-1-1
-- Case 2-2-2-2-1-2: When the node of the capability of idCP exists:
--> ****************************************************
--> Step 1-4: Split the first rule case into cases where
-->  the condition of the rule does or does not hold.
--> ****************************************************
-- The condition of R03 requires the node is created or started.
-- The state of the node of idND' is initial, created, or started.
:csp {
  eq snd' = initial .
  eq snd' = created .
  eq snd' = started .
}
-- Case 2-2-2-2-1-2-1: When the node of idND' is initial:
-- The Cyclic Dependency Lemma rejects this case.
:init [CycleR01] by {
  T:NDType <- tnd;
  I:NDID   <- idND;
  S:State  <- < (node(tnd,idND,initial) sND) , sCP , sRQ , sRL , mp >;
}
:apply (rd) -- 2-2-2-2-1-2-1
-- Case 2-2-2-2-2-2: When the node of idND' is created:
:apply (rd) -- 2-2-2-2-1-2-2
-- Case 2-2-2-2-2-3: When the node of idND' is started:
:apply (rd) -- 2-2-2-2-1-2-3
-- Case 2-2-2-2-2: When the capability of idCP is open:
:apply (rd) -- 2-2-2-2-2
-- Case 2-2-2-2-2: When the capability of idCP is avialable:
:apply (rd) -- 2-2-2-2-3
-- Case 3: When there is a waiting hostedOn requirement of the node:
:apply (rd) -- 3
show proof
select

--> *****************************************************************************************************
--> Created Cont Lemma: Assuming invariants if there is a created node, then there is an applicable rule.
--> *****************************************************************************************************
--> ******************************************
--> Step 2-0: Define a predicate to be proved.
--> ******************************************
module! ProofCreatedCont {
  pr(PROOFfuns)

  pred invcont : State
  eq invcont(S:State) = wfs(S) and inv(S) implies cont(S) .

  -- This proof uses the Initial Cont Lemma: If there is an initail node, then there is an applicable rule.
  eq cont(< (node(T:NDType, I:NDID, initial) SetND:SetOfNode), 
	      SetCP:SetOfCapability, SetRQ:SetOfRequirement, SetRL:SetOfRelationship, M:PoolOfMsg >)
     = true .
}

select ProofCreatedCont .

--> Proof of the createdcont lemma
--> When there is a created node in state S
--> Cyclic Dependency Theorem ensures there is a created node N
--> where DDSR02(N,S) does not include any created nodes.
--> So, we can assume that S = < (node(tnd, idND, created) sND), sCP, sRQ, sRL, mp >
--> and someNDInStates(DDSR02(node(tnd, idND, created),S),created) = false .
--> **************************************************************************
--> Step 2-1: Begin with the cases each of which matches to LHS of each rules.
--> **************************************************************************
:goal {eq invcont(< (node(tnd, idND, created) sND), sCP, sRQ, sRL, mp >)  = true .}
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R02 for the node of idND.
--> ********************************************************************
--> Step 1-3: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- The states of all of the requirements of the node of idND are or are not ready.
:csp { 
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sRQ = (req(trl,idRQ,unbound,idND) sRQ') .
  eq sRQ = (req(trl,idRQ,waiting,idND) sRQ') .
}
-- Case 1: When all of the requirements are ready:
:apply (rd) -- 1
-- Case 2: When there is an unbound requirement of the node of idND:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next applicable rule depends on the type of the requirement.
-- The type of the requirement of idRQ is hostedOn, dependsOn, or connectsTo.
:csp {
  eq trl = hostedOn .
  eq trl = dependsOn .
  eq trl = connectsTo .
}
-- Case 2-1: When the type of the requirement of idRQ is hostedOn:
:apply (rd) -- 2-1
-- Case 2-2: When the type of the requirement of idRQ is dependsOn:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R07 for the dependsOn requirement of idRQ.
--> ********************************************************************
--> Step 1-3: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- LHS of R07 requires a relationship and a capability of the dependsOn requirement of idRQ.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The relationship of the dependsOn requirement of idRQ does or does not exist.
:csp {
  eq onlyOneRLOfRQ(sRL,idRQ) = false .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
}
-- Case 2-2-1: When the relationship of the dependsOn requirement of idRQ does not exist:
:apply (rd) -- 2-2-1
-- Case 2-2-2: When the relationship of the dependsOn requirement of idRQ exists:
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The capability of the relationship does or does not exist.
:csp {
  eq existCP(sCP,idCP) = false .
  eq sCP = (cap(dependsOn,idCP,scp,idND') sCP') .
}
-- Case 2-2-2-1: When the capability of the relationship does not exist:
:apply (rd) -- 2-2-2-1
-- Case 2-2-2-2: When the capability of the relationship exists:
-- The node of the capability of idCP is or is not the same of the node of the requiement of idRQ.
:ctf {
  eq idND' = idND .
}
-- Case 2-2-2-2-1: When the node of the capability of idCP is the same of the node of the requiement of idRQ:
:apply (rd) -- 2-2-2-2-1
-- Case 2-2-2-2-2: When the node of the capability of idCP is not the same of the node of the requiement of idRQ:
--> ********************************************************************
--> Step 1-3: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- LHS of R07 requires an activated capability of the dependsOn requirement of idRQ.
-- The state of the capability of idCP is closed, open, or available.
:csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
-- Case 2-2-2-2-2-1: When the capability of idCP is closed:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R05 for the dependsOn capability of idCP.
--> ****************************************************
--> Step 1-4: Split the first rule case into cases where
-->  the condition of the rule does or does not hold.
--> ****************************************************
-- The condition of R05 requires the parent node of the capability of idCP is created or started.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The node of the capability of idCP does or does not exist.
:csp {
  eq existND(sND,idND') = false .
  eq sND = (node(tnd',idND',snd') sND') .
}
-- Case 2-2-2-2-2-1-1: When the node of the capability of idCP does not exist:
:apply (rd) -- 2-2-2-2-2-1-1
-- Case 2-2-2-2-2-1-2: When the node of the capability of idCP exists:
-- The state of the node of idND' is initial, created, or started.
:csp {
  eq snd' = initial .
  eq snd' = created .
  eq snd' = started .
}
-- Case 2-2-2-2-2-1-2-1: When the node of idND' is initial:
:apply (rd) -- 2-2-2-2-2-1-2-1
-- Case 2-2-2-2-2-1-2-2: When the node of idND' is created:
:apply (rd) -- 2-2-2-2-2-1-2-2
-- Case 2-2-2-2-2-1-2-3: When the node of idND' is started:
:apply (rd) -- 2-2-2-2-2-1-2-3
-- Case 2-2-2-2-2-2: When the capability of idCP is open:
:apply (rd) -- 2-2-2-2-2-2
-- Case 2-2-2-2-2-3: When the capability of idCP is available:
:apply (rd) -- 2-2-2-2-2-3
-- Case 2-3: When the type of the requirement of idRQ is connectsTo:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R11 for the connectsTo requirement of idRQ.
--> ********************************************************************
--> Step 1-3: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- LHS of R11 requires a relationship of the connectsTo requirement of idRQ.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The relationship of the connectsTo requirement of idRQ does or does not exist.
:csp {
  eq onlyOneRLOfRQ(sRL,idRQ) = false .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
}
-- Case 2-3-1: When the relationship of the connectsTo requirement of idRQ does not exist:
:apply (rd) -- 2-3-1
-- Case 2-3-2: When the relationship of the connectsTo requirement of idRQ exists:
--> ********************************************************************
--> Step 1-3: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- LHS of R11 requires an open message of idCP.
:csp {
  eq (opMsg(idCP) \in mp) = false .
  eq mp = (opMsg(idCP) mp') .
}
-- Case 2-3-2-1: When there is no open message of idCP.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The capability of the relationship does or does not exist.
:csp {
  eq existCP(sCP,idCP) = false .
  eq sCP = (cap(connectsTo,idCP,scp,idND') sCP') .
}
-- Case 2-3-2-1-1: When the capability of the relationship does not exist:
:apply (rd) -- 2-3-2-1-1
-- Case 2-3-2-1-2: When the capability of the relationship exists:
-- The node of the capability of idCP is or is not the same of the node of the requiement of idRQ.
:ctf {
  eq idND' = idND .
}
-- Case 2-3-2-1-2-1: When the node of the capability of idCP is the same of the node of the requiement of idRQ:
:apply (rd) -- 2-3-2-1-2-1
-- Case 2-3-2-1-2-2: When the node of the capability of idCP is not the same of the node of the requiement of idRQ:
-- The state of the capability of idCP is closed, open, or available.
:csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
-- Case 2-3-2-1-2-2-1: When the capability of idCP is closed:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R09 for the connectsTo capability of idCP.
--> ****************************************************
--> Step 1-4: Split the first rule case into cases where
-->  the condition of the rule does or does not hold.
--> ****************************************************
-- The condition of R09 requires the parent node of the capability of idCP is created or started.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The node of the capability of idCP does or does not exist.
:csp {
  eq existND(sND,idND') = false .
  eq sND = (node(tnd',idND',snd') sND') .
}
-- Case 2-3-2-1-2-2-1-1: When the node of the capability of idCP does not exist:
:apply (rd) -- 2-3-2-1-2-2-1-1
-- Case 2-3-2-1-2-2-1-2: When the node of the capability of idCP exists:
-- The state of the node of idND' is initial, created, or started.
:csp {
  eq snd' = initial .
  eq snd' = created .
  eq snd' = started .
}
-- Case 2-3-2-1-2-2-1-2-1: When the node of idND' is initial:
:apply (rd) -- 2-3-2-1-2-2-1-2-1
-- Case 2-3-2-1-2-2-1-2-2: When the node of idND' is created:
:apply (rd) -- 2-3-2-1-2-2-1-2-2
-- Case 2-3-2-1-2-2-1-2-3: When the node of idND' is started:
:apply (rd) -- 2-3-2-1-2-2-1-2-3
-- Case 2-3-2-1-2-2-2: When the capability of idCP is open:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R10 for the connectsTo capability of idCP.
--> ****************************************************
--> Step 1-4: Split the first rule case into cases where
-->  the condition of the rule does or does not hold.
--> ****************************************************
-- The condition of R10 requires the parent node of the capability of idCP is started.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The node of the capability of idCP does or does not exist.
:csp {
  eq existND(sND,idND') = false .
  eq sND = (node(tnd',idND',snd') sND') .
}
-- Case 2-3-2-1-2-2-2-1: When the node of the capability of idCP does not exist:
:apply (rd) -- 2-3-2-1-2-2-2-1
-- Case 2-3-2-1-2-2-2-2: When the node of the capability of idCP exists:
-- The state of the node of idND' is initial, created, or started.
:csp {
  eq snd' = initial .
  eq snd' = created .
  eq snd' = started .
}
-- Case 2-3-2-1-2-2-2-2-1: When the node of idND' is initial:
:apply (rd) -- 2-3-2-1-2-2-2-2-1
-- Case 2-3-2-1-2-2-2-2-2: When the node of idND' is created:
:apply (rd) -- 2-3-2-1-2-2-2-2-2
-- Case 2-3-2-1-2-2-2-2-3: When the node of idND' is started:
:apply (rd) -- 2-3-2-1-2-2-2-2-3
-- Case 2-3-2-1-2-2-3: When the capability of idCP is available:
:apply (rd) -- 2-3-2-1-2-2-3
-- Case 2-3-2-2: When there is an open message of idCP.
:apply (rd) -- 2-3-2-2
-- Case 3: When there is a waiting requirement of idRQ of the node of idND:
-- The type of the requirement of idRQ is hostedOn, dependsOn, or connectsTo.
:csp {
  eq trl = hostedOn .
  eq trl = dependsOn .
  eq trl = connectsTo .
}
-- Case 3-1: When the type of the requirement of idRQ is hostedOn:
:apply (rd) -- 3-1
-- Case 3-2: When the type of the requirement of idRQ is dependsOn:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R08 for the dependsOn requirement of idRQ.
--> ********************************************************************
--> Step 1-3: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- LHS of R08 requires a relationship and a capability of the dependsOn requirement of idRQ.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The relationship of the dependsOn requirement of idRQ does or does not exist.
:csp {
  eq onlyOneRLOfRQ(sRL,idRQ) = false .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
}
-- Case 3-2-1: When the relationship of the dependsOn requirement of idRQ does not exist:
:apply (rd) -- 3-2-1
-- Case 3-2-2: When the relationship of the dependsOn requirement of idRQ exists:
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The capability of the relationship does or does not exist.
:csp {
  eq existCP(sCP,idCP) = false .
  eq sCP = (cap(dependsOn,idCP,scp,idND') sCP') .
}
-- Case 3-2-2-1: When the capability of the relationship does not exist:
:apply (rd) -- 3-2-2-1
-- Case 3-2-2-2: When the capability of the relationship exists:
-- The node of the capability of idCP is or is not the same of the node of the requiement of idRQ.
:ctf {
  eq idND' = idND .
}
-- Case 3-2-2-2-1: When the node of the capability of idCP is the same of the node of the requiement of idRQ:
:apply (rd) -- 3-2-2-2-1
-- Case 3-2-2-2-2: When the node of the capability of idCP is not the same of the node of the requiement of idRQ:
--> ********************************************************************
--> Step 1-3: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- LHS of R08 requires an available capability of the dependsOn requirement of idRQ.
-- The state of the capability of idCP is closed, open, or available.
:csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
-- Case 3-2-2-2-2-1: When the capability of idCP is closed:
:apply (rd) -- 3-2-2-2-2-1
-- Case 3-2-2-2-2-2: When the capability of idCP is open:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R06 for the dependsOn capability of idCP.
--> ****************************************************
--> Step 1-4: Split the first rule case into cases where
-->  the condition of the rule does or does not hold.
--> ****************************************************
-- The condition of R06 requires the parent node of the capability of idCP is started.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The node of the capability of idCP does or does not exist.
:csp {
  eq existND(sND,idND') = false .
  eq sND = (node(tnd',idND',snd') sND') .
}
-- Case 3-2-2-2-2-2-1: When the node of the capability of idCP does not exist:
:apply (rd) -- 3-2-2-2-2-2-1
-- Case 3-2-2-2-2-2-2: When the node of the capability of idCP exists:
-- The state of the node of idND' is initial, created, or started.
:csp {
  eq snd' = initial .
  eq snd' = created .
  eq snd' = started .
}
-- Case 3-2-2-2-2-2-2-1: When the node of idND' is initial:
:apply (rd) -- 3-2-2-2-2-2-2-1
-- Case 3-2-2-2-2-2-2-2: When the node of idND' is created:
:init [CycleR02] by {
  T:NDType <- tnd;
  I:NDID   <- idND;
  S:State  <- < (node(tnd,idND,created) sND) , sCP , sRQ , sRL , mp >;
}
:apply (rd) -- 3-2-2-2-2-2-2-2
-- Case 3-2-2-2-2-2-2-3: When the node of idND' is started:
:apply (rd) -- 3-2-2-2-2-2-2-3
-- Case 3-2-2-2-2-3: When the capability of idCP is available:
:apply (rd) -- 3-2-2-2-2-3
-- Case 3-3: When the type of the requirement of idRQ is connectsTo:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R12 for the connectsTo requirement of idRQ.
--> ********************************************************************
--> Step 1-3: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- LHS of R12 requires a relationship of the connectsTo requirement of idRQ.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The relationship of the connectsTo requirement of idRQ does or does not exist.
:csp {
  eq onlyOneRLOfRQ(sRL,idRQ) = false .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
}
-- Case 3-3-1: When the relationship of the connectsTo requirement of idRQ does not exist:
:apply (rd) -- 3-3-1
-- Case 3-3-2: When the relationship of the connectsTo requirement of idRQ exists:
--> ********************************************************************
--> Step 1-3: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- LHS of R12 requires an available message of idCP.
:csp {
  eq (avMsg(idCP) \in mp) = false .
  eq mp = (avMsg(idCP) mp') .
}
-- Case 3-3-2-1: When there is no available message of idCP.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The capability of the relationship does or does not exist.
:csp {
  eq existCP(sCP,idCP) = false .
  eq sCP = (cap(connectsTo,idCP,scp,idND') sCP') .
}
-- Case 3-3-2-1-1: When the capability of the relationship does not exist:
:apply (rd) -- 3-3-2-1-1
-- Case 3-3-2-1-2: When the capability of the relationship exists:
-- The node of the capability of idCP is or is not the same of the node of the requiement of idRQ.
:ctf {
  eq idND' = idND .
}
-- Case 3-3-2-1-2-1: When the node of the capability of idCP is the same of the node of the requiement of idRQ:
:apply (rd) -- 3-3-2-1-2-1
-- Case 3-3-2-1-2-2: When the node of the capability of idCP is not the same of the node of the requiement of idRQ:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next applicable rule depends on the local state of the capability
-- The state of the capability of idCP is closed, open, or available.
:csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
-- Case 3-3-2-1-2-2-1: When the capability of idCP is closed:
:apply (rd) -- 3-3-2-1-2-2-1
-- Case 3-3-2-1-2-2-2: When the capability of idCP is open:
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R10 for the connectsTo capability of idCP.
--> ********************************************************************
--> Step 1-4: Split the general case into cases which collectively cover
-->  the general case and one of which matches to LHS of the first rule.
--> ********************************************************************
-- The condition of R10 requires the parent node of the capability of idCP is started.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The node of the capability of idCP does or does not exist.
:csp {
  eq existND(sND,idND') = false .
  eq sND = (node(tnd',idND',snd') sND') .
}
-- Case 3-3-2-1-2-2-2-1: When the node of the capability of idCP does not exist:
:apply (rd) -- 3-3-2-1-2-2-2-1
-- Case 3-3-2-1-2-2-2-2: When the node of the capability of idCP exists:
-- The state of the node of idND' is initial, created, or started.
:csp {
  eq snd' = initial .
  eq snd' = created .
  eq snd' = started .
}
-- Case 3-3-2-1-2-2-2-2-1: When the node of idND' is initial:
:apply (rd) -- 3-3-2-1-2-2-2-2-1
-- Case 3-3-2-1-2-2-2-2-2: When the node of idND' is created:
:init [CycleR02] by {
  T:NDType <- tnd;
  I:NDID   <- idND;
  S:State  <- < (node(tnd,idND,created) sND) , sCP , sRQ , sRL , mp >;
}
:apply (rd) -- 3-3-2-1-2-2-2-2-2
-- Case 3-3-2-1-2-2-2-2-3: When the node of idND' is started:
:apply (rd) -- 3-3-2-1-2-2-2-2-3
-- Case 3-3-2-1-2-2-3: When the capability of idCP is available:
:apply (rd) -- 3-3-2-1-2-2-3
-- Case 3-3-2-2: When there is an available message of idCP.
:apply (rd) -- 3-3-2-2
show proof
select
