\documentclass[12pt]{report}
\usepackage{jaist-e-doctor}
\usepackage[dvipdfmx]{graphicx,hyperref}
\usepackage{pxjahyper}
\usepackage{latexsym}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage[varg]{txfonts}
\usepackage{url}
\makeatletter
  \renewcommand{\theequation}{\arabic{equation}}
  \@addtoreset{equation}{section}
\makeatother

\title{An Interactive Theorem Proving Framework\\for Declarative Cloud Orchestration}
\author{Hiroyuki Yoshida}
\school{Information Science}
\adviser{Professor Kokichi Futatsugi}
\date{March\ \ 2017}
%% <local definitions here>
\newtheorem{lemma}{Lemma}

\newtheorem{corollary}{Corollary}

\newtheorem{notation}{Notation}
\let\oldnotation\notation
\renewcommand{\notation}{\oldnotation\normalfont}

\newtheorem{definition}{Definition}
\let\olddefinition\definition
\renewcommand{\definition}{\olddefinition\normalfont}

\newcommand{\ra}{\rightarrow}
\newcommand{\mbtt}[1]{\mbox{\tt {#1}}}
\newcommand{\mbstt}[1]{\mbox{\small{\tt {#1}}}}
\newcommand{\stt}[1]{{\small{\tt {#1}}}}
\newcommand{\ul}{\underline}
\newcommand{\cafeobj}{{\sf CafeOBJ}~}
%%\def\verbatimsize{\footnotesize}
%%\verbatimbaselineskip=3mm
%% </local definitions here>

\begin{document}
\maketitle
\pagenumbering{roman}  % Show page number in ROMAN 
\setcounter{page}{1}
\strut
\vspace{20pt}
\begin{center}
{\LARGE\bf Abstract}
\end{center}
\vspace{20pt}
\addcontentsline{toc}{chapter}{Abstract}
%\begin{abstract}
An interactive theorem proving framework for verifying declarative
cloud orchestration is proposed.

Recent rapid progress of cloud computing accelerates the whole life
cycle of system usage and requires much flexible automation of system
operations. Automation of cloud system operations is called cloud
orchestration and correctness of cloud orchestration becomes much
crucial for many activities in the human society.  However,
correctness of automated cloud system operations cannot depend on
testing-based quality control because a cloud system is a kind of
distributed systems and it is not possible to exhaustively test all of
its behavior which may occur at various situations in the production
environment. Formal approaches are expected to provide systematic
ways to guarantee correctness of cloud orchestration.

Formal approaches are mainly classified into two categories, model
checking and theorem proving. As opposed to model checking, theorem
proving can verify models of arbitrary many number of states and so
suitable for proving absence of counter examples. However, when
applying to practical problems it requires many human efforts to
develop proofs.

This dissertation proposes a framework of interactive proof development for a
kind of liveness properties, leads-to property, of cloud
orchestration. We say ``framework'' to mean something like an
application framework of software development which brings high
productivity by minimizing development efforts and high
maintainability by consistent structure of application software.

The proposed framework provides (1) a general way to formalize
specifications of different kinds of cloud orchestration tools and (2)
a procedure for how to verifying a kind of liveness properties, as
well as invariant properties, of formalized specifications.  It also
provides (3) general templates and libraries of formal descriptions
for specifying orchestration of cloud systems and (4) proved lemmas
for general predicates of the libraries to be used for verification.

The framework has been applied to the verification of specifications
of AWS CloudFormation and also of OASIS TOSCA, and is demonstrated to
be effective for reducing generic routine work and making a
verification engineer concentrate on the work specific to each
individual system. The case study of OASIS TOSCA shows that the framework
can be used to specify, represent, and verify the behavior models of
TOSCA where the standard has not yet provided any ways to do so. It
also shows a general way to manage dependencies of cloud resources
which is a smarter one than that of the most popular tool,
CloudFormation.

The major contributions of this dissertation are that (1) it introduces the
idea of frameworks from software development to proof development
which results in high productivity and high maintainability of proofs
and (2) it shows that the framework can be effectively applied to a
non-trivial problem, that is, to specify, represent, and verify the
behavior models of the standard specification language of cloud
orchestration.

%\end{abstract}

\vspace{0.3cm} {\bf Key Words:\ } Cloud Orchestration, System
Specification/Verification, Theorem Proving, Framework, Proof Scores,
CafeOBJ

\include{eack}

\tableofcontents
\listoffigures
\listoftables
\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

%% ===============================================================
\chapter{Introduction}
%% ===============================================================
Cloud computing has recently emerged as an important infrastructure
supporting many aspects of human activities. In former days, it took
several months to make system infrastructure resources (computer,
network, storage, etc.) available, while in these days, it takes only
several minutes to do so. This situation accelerates the whole life
cycle of system usage where much flexible automation is required for
system operations such as setting up, scaling, patching, and so on.
The total automation of system operations is sometimes called
``Infrastructure as Code'' (IaC).

%% ===============================================================
\section{Correctness of Automated Operations of Cloud Systems}
%% ===============================================================
A system on cloud consists of many ``parts,'' such as virtual machines
(VMs), storages, and network services as well as software packages,
configuration files, and user accounts in VMs. These parts are called
{\it resources} and the automated management of cloud resources is
called {\it resource orchestration}, or {\it cloud orchestration}.

The most popular cloud orchestration tool is {\it
  CloudFormation}~\cite{CloudFormation} provided as a service by
Amazon Web Services (AWS) and a compatible open source tool is being
developed as {\it OpenStack Heat}~\cite{Heat}. CloudFormation can
manage resources provided by IaaS platform of AWS, such as VMs (EC2),
block storages (EBS), load balancers (ELB), and so on. CloudFormation
automatically sets up these resources according to declaratively
defined dependencies of resources. However, CloudFormation does not
directly manage resources inside VMs and instead it allows to specify
any types of scripts for initially setting up VMs, such as installing
Httpd package, creating configuration files, copying contents, and
activating an Httpd component. Shell command scripts were commonly
used for this layer of management and recently several open source
tools become popular such as {\it Puppet}~\cite{Puppet}, {\it
  Chef}~\cite{Chef}, and {\it Ansible}~\cite{Ansible}. Currently
operation engineers have to learn and use these several kinds of tools
in actual situations, which results in much elaboration to guarantee
correctness of automated operations. In an actual commercial
experience of the author, more than 50\% of troubles are caused by
defects in those dependency definitions and scripts.

Correctness of cloud orchestration is much more crucial than that of
the former systems because cloud systems serve to much more people in
much longer time than the former systems used mainly inside of
companies. Although cloud computing enables to easily, cheaply, and
repeatedly prepare testing environments for cloud systems, test-based
quality control is not sufficient for automated system operations
because a cloud system is a kind of distributed systems and it is not
possible to exhaustively test all of its behavior which may occur at
various situations in the production environment. In practice, typical
and problematic defects of automated system operations often occur at
unusual situations, for example, when activation of some component is
much delayed because of unexpected heavy accesses to file/database
systems or when accidental termination of some component occurs and it
returns no responses. In order to test operations at unusual
situations, Netflix, an American video on demand company, has been
using a resiliency tool, named {\it Chaos Monkey} ~\cite{ChaosMonkey},
which intentionally and randomly terminates some components of their
system in the production environment. Chaos is controlled to occur
during business hours of weekdays so that operation engineers can
solve the problems and learn from them when automated operations fail
to deal with the situations. Reinhold, E.~\cite{Reinhold16}, an
engineer of Uber, the most famous online transportation network
company, reported that they are using a similar resiliency tools,
named {\it uDestroy}, to unleash controlled chaos on their services.

%% ===============================================================
\section{Theorem Proving Framework for Cloud Orchestration}
%% ===============================================================
We believe formal approaches will provide more systematic ways to
guarantee correctness of cloud orchestration because they have
theoretical bases to exhaustively test all possible behavior of cloud
systems.  Formal approaches have a long research history of more than
half a century and many theories and techniques together with the
remarkable evolution of computing power enable to apply them to
various domains, such as automotive software, mobile IC chip firmware,
financial and military applications, and so on.

However, it is difficult, as ever, to apply formal approaches to
practical scale problems because they require distinctive knowledge
and skills and there are not enough number of engineers who have
acquired such knowledge and skills. In the computer company, the
author is working for, there have been many trial projects applying
various formal approaches, several selected engineers were trained for
each project, and most of the trials were reported as succeeded. But
none of them was expanded to apply to practical projects after trained
engineers dispersed.

The shortage of competent engineers is a very common problem when a new
technology is applied to practical scale problems. For example, about
twenty years ago we had to shift our software development methods from
structured models to object oriented models. Many projects suffered
from lack of competent object oriented architects and Java programmers,
which is a major reason why some of the projects lost several million
dollars. However, object orientation becomes a matured technology
nowadays and many large-scale applications are developed using object
oriented architectures. It is not because the shortage of competent
engineers is fully resolved.  Instead, now we successfully make use of
high reusability of object oriented designs and programs especially as
{\it application frameworks}.

For example, Ruby on Rails (RoR)~\cite{RoR} is one of the most popular
application frameworks. RoR defines an MVC architecture of web
applications, provides super classes and utility classes to implement
the architecture, and gives developers a guide for how to design and
code web applications. RoR brings high productivity by minimizing
development efforts and high maintainability by consistent structure
of applications.  In general, an application framework focuses on a
specific application domain and provides (1) a general application
model which defines structure and behavior of applications in the
domain, (2) abstract reusable entities, i.e. super classes and
utility classes, which can be instantiated to implement the
application model, and (3) procedures which define how the developers
design, program, and configure their own applications. Using an
application framework is a very popular approach to raise the skill
level of novice engineers and to enable a large number of engineers to
efficiently develop a practical scale application with the consistent
structure and behavior.

This dissertation proposes a ``framework'' of interactive proof development
for a kind of liveness properties, {\it leads-to} property, of cloud
orchestration. The most important property of an automated system
operation, which we want to guarantee, is that the operation surely
brings a cloud system to a desired state.  We say ``surely'' to mean
that the system always reaches some final state from any initial
states, which is formalized as ($init~\mbstt{leads-to}~final$).  There
are two major difficulties to verify the reachability of cloud
orchestration.  One is to find sufficient conditions for the
reachability. The framework assists proof developers how to construct
the sufficient conditions for their own problem.  Another difficulty
is to manage acyclicness of resource dependency.  In a cloud system,
dependency among resources should not become cyclic in order to reach
a desired state. The framework provides how to formalize and prove the
invariant property of the acyclicness.

Similarly to application frameworks in software development, the
theorem proving framework provides a general formalization of cloud
orchestration specifications of different kinds of tools and provides
a procedure for how to verify leads-to properties, and also invariant
properties, of the specifications. It also provides logic templates
and predicate libraries which are defined in a general level of
abstraction and can be instantiated as problem specific descriptions,
predicates, and lemmas. Using them, the verification procedure assists
developers to systematically think and develop proofs of leads-to
properties.  The theorem proving framework is expected to raise the
skill level of proof developers and to enable a number of engineers to
efficiently develop practical scale proofs of cloud orchestration
with a consistent structure.

%% ===============================================================
\section{Formal Verification of System Behavior}
%% ===============================================================
One major approach of formal verification of system behavior is {\it
  model checking} which is based on exhaustive analysis of states of
transition systems and can automatically find counter examples
included in the specified models. However, the sizes of models are
limited and thus absence of counter examples cannot be proved.

Model checking has been used for verification of software behavior
since 1990's.  For example, Magee, J., et al.~\cite{MageeKG99} used
model checking to verify safety and liveness properties of software
architecture. Cornejo, M. A., et al.~\cite{CornejoGMP01} specified an
existing (and commonly used) dynamic reconfiguration protocol in LOTOS
(Language Of Temporal Ordering Specification) and verified several
temporal properties, such as ``every reconfiguration command is
eventually followed by an acknowledgment'', using model checking
techniques of the CADP tool set. Vassev, E., et al.~\cite{VassevHQ09}
applied model checking to autonomic computing in the NASA Voyager
mission. They show that liveness properties, such as ``a picture taken
by the Voyager will eventually be result in sending a message to
antennas on Earth'', specified by ASSL (Autonomic System Specification
Language), can be verified. Song, J., et al.~\cite{song2010towards}
used the SPIN model checker to verify two invariant properties of a
self-configuration procedure for autonomous networks of cellular base
stations.  Recently, Sala{\"u}n, G., et al.~\cite{EtcheversCBP11,
  SalaunBCPEG13, SalaunEPBC13} designed a system setup protocol in the
cloud and demonstrated to verify a liveness property of the protocol
using their model checking method.

The framework proposed in this dissertation supports another approach, namely
{\it interactive theorem proving}, which can verify models of
arbitrary many number of states and so suitable for proving absence of
counter examples. It requires thinking through meanings of the
specified models, which is very important aspect of developing trusted
systems. However, when applying to practical problems, it requires
many human efforts to develop proofs for splitting the cases,
establishing lemmas, and proving them in the course of verification.

There also exist several researches to apply the theorem proving
approach to practical problems. Klein, G. et
al.~\cite{KleinEHACDEEKNSTW09} used the Isabelle/HOL theorem
prover to verify functional correctness of OS Kernel. They wrote 4900
lines of the abstract specification, 5700 lines of the Haskell
prototype which is automatically converted to the executable
specification, and 8700 lines of the C program which is converted to
the implementation specification. They proved two step refinements
(from abstract to executable and from executable to implementation
level) using the forward simulation method and wrote about 200-kilo
proof steps. Since they focused functional correctness, they did not
ensure correctness of the abstract specification.

The German Verisoft project~\cite{Verisoft} researches verification of
a whole software stack from verified hardware to verified application
programs. In the project, Alkassar, E., et
al.~\cite{Alkassar:JAR-42-2-38} used the Isabelle/HOL theorem prover
to verify functional correctness of their page-fault handler in which
program properties are specified by the Hoare logic, transferred or
mapped to several lower stack layers, and finally implemented by a
hardware instruction set. They proved more than twelve thousands of
lemmas and wrote more than 244-kilo proof steps. They found some
difficulty to keep a consistent style of proof development in such
scale of problem, which they described as follows:
\vspace{-0.3cm}
\begin{quotation}
``The theories were developed by various people from different sites
with different backgrounds and Isabelle offers its users quite some
opportunity to develop an individual proof style. Some prefer rather
small steps others try to push automation as far as possible. Some
prefer the ‘apply’ style, which often leads a large number of
intermediate lemmas, others structure their proofs with Isar.''
\end{quotation}

None of the existing researches described above did not consider reuse
of proofs which our framework provides for its users.  As far as we
know, reuse of proofs is discussed only in Event-B community as the
generic instantiation approach proposed by Abrial, J. and Hallerstede,
S.~\cite{AbrialH07}. The idea of the generic instantiation is that it
is sufficient to prove instantiated axioms in order to reuse proofs of
a generic machine and its refined machines. 

Silva, R. and Butler, M. J.~\cite{SilvaB09} proposed to use theorem
proving to ensure the sufficient condition of the generic
instantiation. Using the renaming and composing plug-ins for the Rodin
platform (a tool set for Event-B), they defined a way of instantiating
generic machines and generating the sufficient condition as a theorem
of the concrete machine whose proof obligation will be ensured by
Rodin's theorem prover.  Tikhonova, U., et al.~\cite{TikhonovaMBAV13}
applied this idea to verify LACE DSL programs of controlling
lithography machines. However, the generated theorems are too large
for the automatic provers of Rodin to discharge. They say that they do
not expect their average user to prove these theorems using
interactive provers, as it requires knowledge of propositional
calculus and understanding of proof strategies. Instead of theorem
proving, they employed evaluation of structural properties predicates
in the animation plug-in of Rodin.

The existing researches of applying theorem proving to practical scale
problems commonly reported that it requires much human efforts and the
shortage of competent proof engineer is a remained problem, which is
the main concern of this dissertation.

One of the major contributions of this dissertation is to introduce the idea
of frameworks from software development to proof development, which has
a unique set of features as follows:
\vspace{-0.3cm}
\begin{itemize}
\setlength{\parskip}{0cm}
\setlength{\itemsep}{0cm}
\item The framework supports verification of leads-to properties as
  well as invariant properties of practical scale problems using
  interactive theorem proving.
\item It provides a general way to formalize specifications in a
  specific domain, i.e. cloud orchestration.
\item It provides abstract entities and proved lemmas to be reused to
  specify and verify concrete problems with high productivity.
\item It also provides a procedure to guide novice proof engineers
  which results in consistent proofs with high maintainability.
\end{itemize}
Although the above features of ​​this dissertation are, in principle, not
dependent on the theorem proving system to be implemented, the
following functionalities of CafeOBJ, described in
Chapter~\ref{chap:pre}, contribute to realizing the effective
framework.
\begin{itemize}
\item {\bf Transition search predicates} enable to prove the
  reachability of state transition systems together with equations in
  a unified manner of predicate logic.
\item {\bf Template modules} enable to define general entities and to
  reuse them by instantiating and renaming which brings high
  productivity.
\item {\bf Constructor-based inductive theorem prover} enables users
  to easily follow the provided procedure and develop consistent
  structure of models and proofs which brings high maintainability.
\end{itemize}

%% ===============================================================
\section{Standard Specification Language of Cloud Orchestration}
%% ===============================================================
The second major contribution of this dissertation is to show that the idea
of theorem proving framework can be effectively applied to a non-trivial
problem, that is, to specify, represent, and verify the behavior
models of the standard specification language of cloud orchestration
where the standard has not yet provided any ways to do so.

While orchestration tools are specialized into two management layers,
on IaaS and inside VMs, there is a unified standard specification
language, {\it OASIS TOSCA}~\cite{TOSCA} that can be used to describe
the structure of both types of resources. The resource structure is
called a {\it topology} and a TOSCA tool is expected to automate
system operations based on resource dependencies declaratively defined
by topologies.

TOSCA assumes two main engineering roles, namely a type architect and
an application architect. In a typical scenario, type architects
define and provide several types of resources and an application
architect uses them to define a topology of a cloud system. The type
architect also defines {\it operations}\footnote{In this dissertation, we say
  {\it a type operation} as an operation of a type whereas TOSCA calls
  it {\it a lifecycle operation}.} of resource types, such as
creating, starting, stopping, or deleting resources. A system
operation of a cloud system is implemented as an invocation sequence
of the type operations, which can be decided in two kinds of
manners. One is an imperative manner in which the application
architect uses a process modeling language to define a plan that
explicitly invokes these type operations. Another is a declarative one
in which the application architect only defines a topology and a TOSCA
tool will automatically invoke appropriate type operations based on
the defined topology. Naturally, the declarative manner is a main
target of OASIS TOSCA because it promotes more abstract and reusable
descriptions of topologies.

Currently there are no practical implementations of the declarative
manner of TOSCA and one of the reasons is that no standard set of type
operations are defined and there is no way for type architects to
define behavior of their own types.  In
Section~\ref{sec:TOSCAbehavior}, we will describe how to use our
framework to define behavior of TOSCA types and to verify that a
specified topology can correctly automate to set up the cloud system.

\vspace{0.3cm}
The rest of this dissertation is organized as
follows. Chapter~\ref{chap:cloudorch} introduces several cloud
orchestration tools. Chapter~\ref{chap:pre} introduces functionalities
of \cafeobj language in which we represent formal specifications of
cloud systems. Chapter~\ref{chap:model} describes a general model of
cloud orchestration. Chapter \ref{chap:reusable} describes general
logic templates and predicate
libraries. Chapter~\ref{chap:verification} presents the procedure for
verification of leads-to properties using a simple example
specification of CloudFormation. Chapter~\ref{chap:appTOSCA} explains
how the framework is applied to verification of OASIS TOSCA
specifications.  Chapter~\ref{chap:conclusion} explains related work
and future issues.

%% ===============================================================
\chapter{Cloud Orchestration}
\label{chap:cloudorch}
%% ===============================================================
Cloud computing is a model for providing computational resources that
allows on-demand accesses via the internet to shared pools of
configurable resources such as networks, computers, storage,
middleware, development tools, applications, etc.

Cloud computing services are classified into three categories by the
type of computing resources to provide. IaaS (Infrastructure as a
Service) is one of the service categories which mainly provides
hardware facilities via the internet. Such as servers, storages, and
networks are typically provided and called as virtual machines(VMs),
virtual storages, and virtual networks. PaaS (Platform as a Service)
is another category which mainly provides middleware (software
components for constructing applications) via the internet, such as
application servers, databases, and messaging queues, and so on. SaaS
(Software as a Service) is the last category in which applications are
provided via the internet.

Recent rapid progress of cloud computing accelerates the whole life
cycle of system usage and requires much flexible automation of system
operations, such as set-up, scale-out, scale-in, or shutdown of cloud
systems. Automation of cloud system operations is called {\it resource
  orchestration}, or {\it cloud orchestration} and there are many
cloud orchestration tools used in practical situations. This chapter
introduces several popular cloud orchestration tools and describes
differences of their ways to specify automated system operations.

%% ===============================================================
\section{AWS CloudFormation}
\label{sec:aws}
%% ===============================================================
The most popular cloud orchestration tool is {\it
  CloudFormation}~\cite{CloudFormation} provided as a service by
Amazon Web Services (AWS). CloudFormation can manage {\it resources}
provided by IaaS platform of AWS, such as VMs (EC2), block storages
(EBS), and load balancers (ELB).  CloudFormation automatically sets up
these resources according to a {\it template} that declaratively
defines dependencies of resources.  A template is a set of resources
and a resource has an identifier and a type and includes several {\it
  properties} which may depend on other resources.

Fig.~\ref{fig:AWSExample} is part of a very simple CloudFormation
template written in JSON format~\cite{JSON}.  This template specifies
the dependency of the resources in a simple cloud system on the AWS
IaaS platform shown in lower part of Fig.~\ref{fig:AWSExample}.  There are two
resources; one has the identifier {\tt MyInstance} and the type {\tt
  AWS::EC2::Instance}, another has the identifier {\tt MyEIP} and the
type {\tt AWS::EC2::EIP}. Note that an Elastic Compute Cloud instance
(EC2 instance) is a virtual machine on AWS IaaS platform and an
Elastic IP (EIP) provides a static IP address for an EC2 instance
which is dynamically created and activated. {\tt MyEIP} has a property
whose type is {\tt InstanceID}. The property refers {\tt MyInstance}
which makes resource {\tt MyEIP} depend on {\tt MyInstance}. Thus,
CloudFormation firstly activates {\tt MyInstance} and then activates
{\tt MyEIP} with a parameter of the instance ID of {\tt MyInstance}.
%% =======================================================================
\begin{figure}
\small
\begin{verbatim}
               { "Resources" : {
                   "MyInstance" : {
                     "Type" : "AWS::EC2::Instance",
                   "MyEIP" : {
                     "Type" : "AWS::EC2::EIP",
                     "Properties" : {
                       "InstanceId" : { "Ref" : "MyInstance" }
               }}}}}
\end{verbatim}
\normalsize
\centering
\includegraphics[height=2cm,natwidth=396,natheight=78]{./exaws.png}
\vspace{-0.3cm}
\caption{A Very Simple CloudFormation Template}
\label{fig:AWSExample}
\end{figure}
%% =======================================================================

%% ===============================================================
\section{Puppet, Chef, and Ansible}
\label{sec:PCA}
%% ===============================================================
Puppet, Chef, and Ansible are not cloud orchestration tools but {\it
  deployment tools} (also called {\it configuration tools}) which are
used by cloud orchestration tools to set up resources inside VMs.

Puppet~\cite{Puppet} provides a domain specific language (DSL) to
describe executable Ruby~\cite{Ruby} scripts for setting up resources inside
VMs. A Ruby script of Puppet is called a {\it manifest} and executed in a VM.
Fig.~\ref{fig:PuppetExample} is a simple manifest written in Puppet
DSL to set up an httpd service.
%% =======================================================================
\begin{figure}
\small
\begin{verbatim}
                 package { "httpd":
                   name => "httpd",
                   ensure => "installed"
                 }
                 service { "httpd":
                   name => "httpd",
                   enable => "true",
                   ensure => running,
                   require => Package["httpd"]
                 }
                 file { "/var/www/html/sample":
                   ensure => directory,
                   owner => "apache",
                   group => "apache",
                   mode => "755",
                   require => Package["httpd"]
                 }
                 file { "/var/www/html/sample/sample.html":
                   source => "puppet:///files/sample.html",
                   owner => "root",
                   group => "root",
                   mode => "644",
                   require => File["/var/www/html/sample"]
                 }
                 file { "/etc/httpd/conf/httpd.conf":
                   source => "puppet:///files/httpd.conf",
                   mode => "644",
                   owner => "root",
                   group => "root"
                   subscribe => Service["httpd"]
                 }
\end{verbatim}
\normalsize
\vspace{-0.6cm}
\caption{A Simple Puppet Manifest for Setting up an HTTPD Server}
\label{fig:PuppetExample}
\end{figure}
%% =======================================================================
A manifest is a list of declarations each of which declares the
desired state of a resource. Each declaration specifies a type, a
title, and attributes of a resource. For example, the first four lines
of the manifest shown in Fig.~\ref{fig:PuppetExample} specifies that a
{\it package} type resource named {\tt httpd} is desired to be installed to
the target VM. A package means an installable package of a middleware
which is the Apache HTTP server in this case.  The second declaration
of the example manifest means that an httpd service is desired to be
running and it requires the httpd package resource above is in the
specified state. The third one means that the specified directory is
desired to exist. The fourth means that a file is desired to be
copied from the Puppet server to the specified file path whose owner
is {\tt root}, group is {\tt root}, and mode is 644, which requires
the directory declared above is in the specified state.  The fifth one
also means that a file is desired to be copied and this resource
should be checked whenever the state of the specified service resource
is changed. A manifest is not necessarily executed from top to bottom;
the order is decided by {\tt require} and {\tt subscribe}
attributes. A manifest is idempotent which means the result of its
execution is always the same because nothing is done when a specified
resource is already in the desired state.

Chef~\cite{Chef} also provides a Ruby-based DSL to describe executable
scripts for setting up resources inside VMs. A script is called a {\it recipe}
and executed in a VM. A collection of related recipes and auxiliary
files is called a {\it cookbook}.  Fig.~\ref{fig:ChefExample} is a
simple recipe written in Chef DSL to set up an httpd service.
%% =======================================================================
\begin{figure}
\small
\begin{verbatim}
       package "httpd" do
         action :install
       end
       cookbook_file "/etc/httpd/conf/httpd.conf" do
         source "httpd.conf"
         owner 'root'
         group 'root'
         mode 00644
       end
       directory "/var/www/html/sample" do
         owner 'apache'
         group 'apache'
         mode 00755
         action :create
       end
       cookbook_file "/var/www/html/sample/sample.html" do
         source "sample.html"
         owner 'root'
         group 'root'
         mode 00644
       end
       service "httpd" do
         supports :status => true, :restart => true, :reload => true
         action [:enable,:start]
       end
\end{verbatim}
\normalsize
\vspace{-0.6cm}
\caption{A Simple Chef Recipe for Setting up an HTTPD Server}
\label{fig:ChefExample}
\end{figure}
%% =======================================================================
A recipe is a list of declarations each of which declares the desired
state of a resource. Each declaration specifies a type, a name,
attributes, and actions of a resource. For example, the first three
lines of the recipe shown in Fig.~\ref{fig:ChefExample} specifies that
a package type resource named {\tt httpd} is desired to be installed to
the target VM and the action to do so is {\tt :install}. The second
declaration of the example recipe means that a file {\tt httpd.conf}
included in the cookbook of this recipe is desired to be copied to the
specified file path whose owner is {\tt root}, group is {\tt root},
and mode is 00644. The third one means that the specified directory is
desired to exist and the fifth one means that an httpd service is
desired to be running. As opposed to a Puppet manifest, a Chef recipe
is executed from top to bottom and so the order of resources is
critical; the fourth and fifth resources should not be inverted
because the directory should exist before the file is copied into
it. A recipe is idempotent similarly as a Puppet manifest. Since
actions to achieve the desired states (e.g. {\tt :install}) are
abstracted and implemented for many kinds of operating systems, a
recipe is independent from the difference of them.

What corresponds to a manifest of Puppet or a recipe of Chef is called
a {\it playbook} in Ansible~\cite{Ansible}. Although Ansible is
implemented by Python~\cite{Python}, a playbook is not an executable
script in Python but a YAML format file~\cite{YAML} which is
interpreted and executed by {\tt ansible-playbook} command. Before
showing an example playbook, we will briefly explain the YAML format.
%% =======================================================================
\begin{figure}
\small
\begin{verbatim}
                           A: one
                           B:
                             - C: two
                               D: three
                             - E: four
                               F: five
                           G: six
\end{verbatim}
\normalsize
\vspace{-0.6cm}
\caption{An Example YMAL Document}
\label{fig:YAMLExample}
\end{figure}
%% =======================================================================
A YAML document represents nesting key-value lists and arrays. A key
and its value are separated by a colon (:). Keys with the same
indentation composes a list. In Fig.~\ref{fig:YAMLExample}, the top
level list has three key-value pairs whose keys are {\tt A}, {\tt B},
and {\tt G}.  An array is represented by minus signs (-) with the same
indentation.  In the figure, the value of key {\tt B} is an array with
two elements each of which is a key-value list with two pairs. Let us
write a key-value list as
\small\verb|{(k1, v1), (k2, v2), ... }|\normalsize and an array as
\small\verb|[e1, e2, ... ]|\normalsize, then the data structure
represented by the YAML document in Fig.~\ref{fig:YAMLExample} is the following list:
\\\small
\verb|  {(A, one), (B, [{(C, two), (D, three)}, {(E, four), (F, five)}]), (G, six)}|
\normalsize
%% =======================================================================
\begin{figure}
\small
\begin{verbatim}
            - hosts: webservers
              tasks:
                - name: be sure httpd is installed
                  yum: name=httpd state=installed
                - name: be sure httpd.conf exists
                  file: src=/file/httpd.conf
                        path=/etc/httpd/conf/httpd.conf
                        state=file
                        owner=root
                        group=root
                        mode=0644
                - name: be sure springboot root directory exists
                  file: path=/var/www/html/sample
                        state=directory
                        owner=apache
                        group=apache
                        mode=0755
                - name: be sure sample.html exists
                  file: src=/file/sample.html
                        path=/var/www/html/sample/sample.html
                        state=file
                        owner=root
                        group=root
                        mode=0644
                - name: be sure httpd is running and enabled
                  service: name=httpd state=running enabled=yes
\end{verbatim}
\normalsize
\vspace{-0.6cm}
\caption{A Simple Ansible Playbook for Setting up an HTTPD Server}
\label{fig:AnsibleExample}
\end{figure}
%% =======================================================================

A playbook represents an array of {\it plays} which are a sports
analogy; many plays are required to set up a cloud
system. Fig.~\ref{fig:AnsibleExample} is a simple example playbook to
set up an httpd service which represents only one play. A play is a
key-value list including keys of {\tt hosts}, {\tt tasks}, and so
on. Key {\tt hosts} specifies machines to which the play is applied.
Key {\tt tasks} specifies an array of {\it tasks} which are executed
in order.  In the example, the task array includes five tasks. A task
is a key-value list and typically begins with the pair of {\tt name}
key and its value which serves as a comment. The second pair of a task
specifies a {\it module} and the parameters to invoke it.  A module is
a command provided by Ansible which can be remotely executed on the
specified VMs. In the example, module {\tt yum} will install the
package resource named {\tt httpd}, module {\tt file} will create the
specified file or directory, and {\tt service} will start the httpd
service to be running. Similarly as a Chef recipe, tasks in an Ansible
playbook are executed from top to bottom and so the order of tasks is
critical.  A playbook is idempotent similarly as a Puppet manifest and
a Chef recipe. Since modules to achieve the desired states are
abstracted and implemented for many kinds of operating systems, a
playbook is independent from the difference of them.

Although there are several differences among Puppet, Chef, and Ansible
which are omitted to explain here, they share several common features in
comparison with shell command scripts provided by operating systems
of VMs. They provide domain specific languages to describe the
desired states of resources. The descriptions in the DSLs are
idempotent and abstracted to be independent from the difference of
operation systems.

However, people have to learn and use at least two different kinds of
tools (orchestration tools and configuration tools) with different
styles of specifications and functionalities, which results in much
elaboration to guarantee the correctness of automated system operations.

%% ===============================================================
\section{OASIS TOSCA}
\label{sec:TOSCA}
%% ===============================================================
OASIS TOSCA\cite{TOSCA} is a standard specification language to
describe automation of a cloud system consisting of service components
and their relationships using a {\it service template}. It provides
interoperable deployments of cloud systems across different cloud
environments and their management throughout the complete lifecycle
(e.g. setting up, scaling, patching, monitoring, etc.).  A service
template consists of a {\it topology template} and optionally a set of
{\it plans}. A topology template defines the resource structure of a
cloud system. Note that a topology template can be parameterized to
give actual environment parameters such as IP addresses, which is the
reason why named as ``template'' and in this dissertation we simply say ``a
topology'' for the sake of brevity. A plan is an imperative definition
of a system operation of the cloud system, such as a setup plan,
written by a standard process modeling language, such as BPMN~\cite{BPMN}.

In TOSCA, a resource is called a {\it node} that has several {\it
  capabilities} and {\it requirements}. A topology consists of a set
of nodes and a set of {\it relationships} of nodes.  A capability is a
function that the node provides to another node, while a requirement
is a function that the node needs to be provided by another node. A
relationship relates a requirement of a source node to a capability of
a target node. Note that nodes and relationships in a topology
template can also be parameterized, thus the exact terms of TOSCA are
node templates and relationship templates.
\begin{figure}
\centering
\includegraphics[height=10cm,natwidth=640,natheight=429]{./extopology.png}
\caption{An Example of TOSCA topology}
\label{fig:exampletopology}
\end{figure}
Fig.~\ref{fig:exampletopology} shows a typical example of topology
that consists of nine nodes and nine relationships. White circles
represent capabilities and black ones are requirements.

The current version of TOSCA is an XML-based language\footnote{OASIS
  TOSCA TC has published the committee draft of a simple profile for a
  YAML-based language.~\cite{TOSCAYAML}}. Fig~\ref{fig:topology} is 
part of the topology template of Fig.~\ref{fig:exampletopology}.
%% =======================================================================
\begin{figure}
\small
\begin{verbatim}
  <TopologyTemplate>
    <NodeTemplate id="VMApache" name="VM for Apache" 
                  type="VirtualMachine">
      <Capabilities>
        <Capability id="VMApacheOS" name="OS" 
                    type="OperatingSystemContainerCapability"/>
      </Capabilities> </NodeTemplate>
    <NodeTemplate id="OSApache" name="OS for Apache" 
                  type="OperatingSystem">
      <Requirements>
        <Requirement id="OSApacheContainer" name="Container" 
                     type="OperatingSystemContainerRequirement"/>
      </Requirements>
      <Capabilities>
        <Capability id="OsApacheSoftware" name="Software" 
                    type="SoftwareContainerCapability"/>
      </Capabilities> </NodeTemplate>
    <RelationshipTemplate id="OSApacheHostedOnVMApache"
                          name="hosted on" type="HostedOn">
      <SourceElement ref="OSApacheContainer"/>
      <TargetElement ref="VMApacheOS"/>
    </RelationshipTemplate>
  ...
  </TopologyTemplate>
\end{verbatim}
\normalsize
\caption{A Topology Template of TOSCA}
\label{fig:topology}
\end{figure}
%% =======================================================================
In this example, there are two nodes ({\tt VMApache} and {\tt
  OSApache}) and one relationship.  
{\tt VMApacheOS} is a capability of {\tt VMApache} and {\tt
  OSApacheContainer} is a requirement of {\tt OSApache}.  
Each node, relationship, capability, and requirement
has a {\it type}, such as {\tt VirtualMachine}, {\tt HostedOn}, and so
on. Types are main functionalities of TOSCA that enable reusability of
topology descriptions.

TOSCA assumes two main technical roles, namely a type architect and
an application architect. In a typical scenario, type architects
define and provide several types of those elements and an application
architect uses them to define a topology of a cloud system. The type
architect also defines {\it operations} of node types, such as
creating, starting, stopping, or deleting nodes, and of relationship
types, such as attaching relationships. A system operation of a cloud
system is implemented as an invocation sequence of the type
operations, which can be decided in two kinds of manners. One is an
imperative manner in which the application architect uses a process
modeling language to define a plan that explicitly invokes these type
operations. Another is a declarative one in which the application
architect only defines a topology and a TOSCA tool will automatically
invoke appropriate type operations based on the defined
topology. Naturally, the declarative manner is a main target of OASIS
TOSCA because it promotes more abstract and reusable descriptions of
topologies.

In this dissertation, {\it behavior of topologies} means when
and which type operations should be invoked in automation. It is
important to notice that behavior of a topology is decided by
types of included nodes and relationships. We also say
{\it behavior of a type} to mean that the conditions and
results of invoking its type operations, which is defined by a type
architect. Usually, different types of nodes are provided by different
vendors and so specified by different type architects. An application
architect is responsible for behavior of a topology
whereas type architects are responsible for behavior of
their defined types.

%% ===============================================================
\chapter{Preliminaries of \cafeobj}
\label{chap:pre}
%% ===============================================================
\cafeobj\cite{cafeobj} is a formal specification language that is one
of the state-of-the-art algebraic specification languages and a member
of the {\sf OBJ}~\cite{OBJ} language family, such as {\sf
  Maude}~\cite{Maude14}.  \cafeobj specifications are executable by
regarding equations and transition rules in them as left-to-right
rewrite rules, and this executability can be used for interactive
theorem proving.

%% ===============================================================
\section{Modules and Equations}
\label{sec:module}
%% ===============================================================
Basic units of specifications in \cafeobj are {\it modules}.  A
module\footnote{\cafeobj modules can be classified into tight modules
  and loose modules. Roughly speaking, a tight module denotes a unique
  model, while a loose module denotes a class of modules. Those are
  declared with {\tt module!} and {\tt module*} respectively.}
consists of declarations of {\it module importations, sorts, sub-sort
  relations, operators, variables, equations} and {\it transition
  rules}, some of which may be omitted. Conventionally, names of
modules, sorts, and variables are capitalized while names of operators
including constants start with lower case letters or use punctuation
symbols.

Modules may have {\it parameters} and are called parameterized modules
if so. An example of parameterized modules is as follows
\footnote{In \cafeobj, a comment starts with {\tt --} or {\tt **} to
  the end of the line.}:
%% =======================================================================
\small
\begin{verbatim}
  module! SET(X :: TRIV) {
    -- Module Importation
    protecting(NAT)
  
    -- Sorts, Sub-sort Relations
    [Elt.X < Set]
  
    -- Operators
    op empty : -> Set {constr}
    op _ _ : Set Set -> Set {constr assoc comm idem id: empty}
  
    op #_ : Set -> Nat
    op _U_ : Set Set -> Set
    pred _\in_ : Elt.X Set
    op _A_ : Set Set -> Set
    op _\\_ : Set Set -> Set
    pred subset : Set Set
  
    -- Variables
    vars S S1 S2 : Set
    vars E E1 : Elt.X
  
    -- Equations
    -- for =
    eq ((E S1) = (E S2)) = (S1 = S2) .
    -- for empty
    eq ((E S) = empty) = false .
    -- for #_
    eq # empty = 0 .   
    eq # (E S) = 1 + (# S) . 
    -- for _U_
    eq S1 U S2 = S1 S2 .
    -- for _\in_
    eq E \in empty = false .
    eq E \in (E S) = true .
    ceq E \in (E1 S) = E \in S if not(E = E1) .
    -- for _A_
    eq empty A S2 = empty .
    eq (E S1) A (E S2) = E (S1 A S2) .
    ceq (E S1) A S2 = S1 A S2 if not(E \in S2) .
    -- for _\\_ 
    eq empty \\ E = empty .
    eq (E S) \\ E = S .
    ceq (E1 S) \\ E = (E1 (S \\ E)) if not (E = E1) .
    -- for subset
    eq subset(empty,S) = true .
    eq subset((E S1),S2) = E \in S2 and subset(S1,S2) .
  }
\end{verbatim}
\normalsize
%% =======================================================================
This module specifies generic sets and has one parameter {\tt X}
constrained by the built-in module {\tt TRIV} in which one sort
{\tt Elt} is only declared as follows:
%% =======================================================================
\small
\begin{verbatim}
  module* TRIV {
    [Elt]
  }
\end{verbatim}
\normalsize
%% =======================================================================
The sort is referred by {\tt Elt.X} and used for elements in {\tt
  SET}. The built-in module {\tt NAT} in which natural numbers are
specified is imported with {\tt protecting}. Modules also can be
imported with {\tt extending} and {\tt using}; {\tt protecting} means
that elements of the imported modules should not be added nor
collapsed; {\tt extending} means that they can only be added but not
be collapsed; and {\tt using} means they can be added and collapsed.

One sort {\tt Set} is declared and it is also declared that {\tt
  Elt.X} is a sub-sort of {\tt Set}. This is why an element is also a
singleton set that only consists of the element. An operator without
arguments is a {\it constant} and an operator which is not defined by
any equations is a {\it constructor}. The operator {\tt empty} is a
constant of {\tt Set} and the juxtaposition operator {\tt \_ \_} is a
constructor of {\tt Set}, where an underscore is the place where an
argument is put. It is also specified that the juxtaposition operator
is associative, commutative, and idempotent and has {\tt empty} as its
identity. Operators are defined with equations. The first equation
specifies that \stt{\# empty} equals {\tt 0}, and the second one
specifies that \stt{\# (E S)} equals \stt{1 + (\# S)}. Those two
equations define operator {\tt \#\_} that counts the number of the
elements in a given set. Operators {\tt \_U\_}, {\tt
  \_$\backslash$in\_}, {\tt \_A\_}, {\tt \_$\backslash\backslash$\_},
and {\tt subset} are defined which mean union($\cup$),
membership($\in$), intersection($\cap$), difference($\backslash$), and
inclusion($\subseteq$) of sets respectively.  Note that
``\stt{pred~Op~:~Sort1~Sort2}'' is an abbreviation for
``\stt{op~Op~:~Sort1~Sort2~->~Bool}.''

Parameterized modules can be instantiated together with modules as actual
parameters through views. Let us consider the following module
as an actual parameter of {\tt Set}:
%% =======================================================================
\small
\begin{verbatim}
  module! SERVICE {
   protecting(NAT)
   [LocalState Service]
   ops closed open ready : -> LocalState {constr}
   op sv : Nat LocalState -> Service {constr}
  }
\end{verbatim}
\normalsize
%% =======================================================================
in which two sorts are declared.  A term of sort {\tt LocalState}
represents a local state of a service and there are three constants of
local states ({\tt closed}, {\tt open}, and {\tt ready}).  A term of
sort {\tt Service} represents a service which has a form
\stt{sv(n,lst)} where {\tt n} is some natural number as an identifier
and {\tt lst} is one of local states.  {\tt SET} can be instantiated
as {\tt SV-SET} as follows:
%% =======================================================================
\small
\begin{verbatim}
  module! SV-SET {
   protecting(
    SET(SERVICE{sort Elt -> Service})
     * {sort Set -> SvSet,
        op empty -> empSvSet})
  }
\end{verbatim}
\normalsize
%% =======================================================================
What follows {\tt SERVICE}, namely \stt{\{sort Elt -> Service\}}, is
a {\it view} used here saying that {\tt Elt} is replaced with
{\tt Service} in the instantiation of {\tt SET} with
{\tt SERVICE}. What follows {\tt *} is renaming. {\tt Set} and
{\tt empty} are renamed as {\tt SvSet} and {\tt empSvSet},
respectively. Other operators are used without renaming.
The instantiated {\tt SET} with {\tt SERVICE} in which {\tt Set} and
{\tt empty} are renamed as mentioned is imported with {\tt protecting}
in {\tt SV-SET}. In this case, {\tt SET} is called a {\it template
  module} and {\tt TRIV} is called a {\it parameter module}. Note that
a template module is not always a parameterized module. Template modules
with no parameters will be explained in Section~\ref{sec:objectbase}.

Command {\tt open} make a given module, {\tt SV-SET}
in this case, available.
%% =======================================================================
\small
\begin{verbatim}
  open SV-SET .
   reduce #(sv(1,closed) sv(2,open)) . -- to 2.

   op svs : -> SvSet .
   reduce #(sv(1,closed) svs) = # svs + 1 . -- to true.
  close
\end{verbatim}
\normalsize
%% =======================================================================
In {\tt SV-SET}, \stt{(sv(1,closed) sv(2,open))} is a term of sort
{\tt SvSet} and represents a set of services consists of two elements.
Thereby, \stt{\#(sv(1,closed) sv(2,open))} is a term of {\tt Nat} which
reduces to {\tt 2} using equations of {\tt SET} as left-to-right
rewrite rules. When {\tt svs} is a term of sort {\tt SvSet},
\stt{(sv(1,closed) svs)} is also a term of sort {\tt SvSet} which
represents a set of services including at least one {\tt closed}
service where {\tt svs} represents the rest of the set. Thus,
\stt{\#(sv(1,closed) svs)} reduces to \stt{\# svs + 1}.

%% ===============================================================
\section{Transition Rules}
\label{sec:rules}
%% ===============================================================
Let us consider the following module:
%% =======================================================================
\small
\begin{verbatim}
  module! UPDATE {
   using(SV-SET)
  
   [State]
   op < _ > : SvSet -> State {constr}
   var SVS : SvSet    
   var N : Nat
  
   trans [c2o]: 
    < sv(N,closed) SVS > => < sv(N,open) SVS > .
  
   ctrans [o2r]: 
    < sv(N,open) SVS > => < sv(N,ready) SVS >
    if # SVS > 0 . 
  }
\end{verbatim}
\normalsize
%% =======================================================================
Module {\tt UPDATE} specifies a {\it state machine}. We say a ``global state''
as a state of the state machine in order to avoid the confusion with
local states of services. A ground term of sort {\tt State} represents
a global state consisting of a set of services, where the set
\{$\ \mbstt{<}\ svs\ \mbstt{>}\mid svs$ is a ground term of {\tt
  SvSet}\} represents the state space. Two transition rules, labeled
by {\tt c2o} and {\tt o2r}, define the state transition over the
global states.  Transition rule {\tt c2o} specifies that a {\tt closed}
service appearing in a global state is changed to {\tt open}, and {\tt o2r}
specifies that an {\tt open} service is changed to {\tt ready} if
there is at least one other service, where {\tt ctrans} means ``conditional
trans''.

Command {\tt select} is similar to {\tt open} except that it does not
allow to declare new sorts, operators, equations, and so on. 
Command {\tt execute} makes \cafeobj try to apply transition
rules until no one can be applied.
%% =======================================================================
\small
\begin{verbatim}
  select UPDATE .
   execute < sv(1,closed) sv(2,open) > .
     -- to < sv(1,ready)  sv(2,ready) > .

   execute < sv(1,closed) > .
     -- to < sv(1,open) > .
\end{verbatim}
\normalsize
%% =======================================================================
Rule {\tt c2o} makes state \stt{<~sv(1,closed)~sv(2,open)~>} transit
to \stt{<~sv(1,open)~sv(2,open)~>} then rule {\tt o2r} makes transit
it to \stt{<~sv(1,ready)~sv(2,open)~>} and successively makes it
transit to \stt{<~sv(1,open)~sv(2,open)~>}. On the other hand,
only rule {\tt c2o} can be applied to global state \stt{<~sv(1,closed)~>}
because it has only one element.

%% ===============================================================
\subsection{Formalization of State Machines in \cafeobj}
\label{sec:statemachine}
%% ===============================================================
This section summarizes the formal definitions of state machines in
\cafeobj. Please refer to \cite{Futatsugi15} for detailed
definitions.
\begin{definition}[transition rule]
  Let {\tt State} be a sort of global states, $l$ and $r$ terms of
  sort {\tt State}, and let $c$ be a term of sort {\tt Bool}, then a
  triple $R = [l,r,c]$ is called a \ul{transition rule} and
  represented as ``\stt{ctrans $l$ => $r$ if $c$ .}''~(or ``\stt{trans
    $l$ => $r$ .}'' when $c$ is \stt{true}).
\end{definition}
\begin{definition}[transition]
  Let $\mathit{St}$ be a set of global states (i.e.\ ground terms of sort {\tt
    State}), and let $Rule$ be a set of transition rules, then a pair of
  global states $(S,S')\in \mathit{Tr}\subseteq \mathit{St}\times \mathit{St}$ is called a
  \ul{transition specified by} $Rule$ iff there exists a transition
  rule $R=[l,r,c]\in Rule$ and some ground substitution $\sigma$ such
  that $S=l\sigma$, $S'=r\sigma$, and $c\sigma$ reduces to $true$. We
  also say $R$ \ul{can be applied to} $S$ and say $S'$ is a \ul{next
    state} of $S$\!.
\end{definition}
\begin{definition}[state machine]
  Let $Rule$ be a set of transition rules, then a \ul{state machine}
  is a triple $(\mathit{St},\mathit{Tr},In)$ where $\mathit{St}$ is a set of global state,
  $\mathit{Tr}\subseteq \mathit{St}\times \mathit{St}$ is a set of transitions specified by
  $Rule$, and $In \subseteq \mathit{St}$. An element of $In$ is called an
  \ul{initial state}.
\end{definition}
\begin{definition}[transition sequence]
  Let $(\mathit{St},\mathit{Tr},In)$ be a state machine, then a \ul{transition sequence} is a
  sequence of global states $(\mathit{S_0},\mathit{S_1},\dots,\mathit{S_n})$ where each adjacent
  pair $(\mathit{S_i},\mathit{S_{i+1}}) \in \mathit{Tr}$. 
\end{definition}
\begin{notation}[$S\alpha,\alpha S,\alpha\beta$]
  Let $S$ be a global state, and let $\alpha=(\mathit{S_0},\mathit{S_1},\dots,\mathit{S_n})$ be a
  transition sequence, then \ul{$S\alpha$} is the transition sequence
  such that $S\alpha=(S,\mathit{S_0},\mathit{S_1},\dots,\mathit{S_n})$.  \ul{$\alpha S$} is the
  transition sequence such that $\alpha S=(\mathit{S_0},\mathit{S_1},\dots,\mathit{S_n},S)$.  Let
  $\alpha=(\mathit{S_0},\mathit{S_1},\dots,\mathit{S_n})$ and
  $\beta=(\mathit{S_{n+1}},\mathit{S_{n+2}},\dots,\mathit{S_{n+m}})$ be transition sequences,
  then \ul{$\alpha\beta$} is the transition sequence such that
  $\alpha\beta=(\mathit{S_0},\mathit{S_1},\dots,\mathit{S_n},\mathit{S_{n+1}},\mathit{S_{n+2}},\dots,\mathit{S_{n+m}})$.
\end{notation}
\begin{definition}[reachable]
  Let $(\mathit{St},\mathit{Tr},In)$ be a state machine, then a global state $S\in \mathit{St}$
  is \ul{reachable} iff there exists a transition sequence
  $(\mathit{S_0},\mathit{S_1},\dots,\mathit{S_n})$ where $\mathit{S_0}\in In$ and $S=\mathit{S_n}$. Note that $\mathit{S_0}\in
  In$ is reachable because $(\mathit{S_0})$ is a transition sequence with $n=0$.
\end{definition}
\begin{definition}[invariant]
  Let $(\mathit{St},\mathit{Tr},In)$ be a state machine, then a global state predicate
  $p$ is an \ul{invariant} iff $p(S)=true$ holds for any reachable
  global state $S$\!.
\end{definition}

%% ===============================================================
\section{Search Predicates}
\label{sec:searchpredicate}
%% ===============================================================
What is called {\it search predicates} can be used to conduct
reachability analysis for such state machines specified in
\cafeobj:
%% =======================================================================
\small
\begin{verbatim}
  pred _=(*,1)=>+_ : State State
  pred _=(*,1)=>+_if_suchThat_{_} : State State Bool Bool Info
\end{verbatim}
\normalsize
%% =======================================================================

Let us consider the following code fragment:
%% =======================================================================
\small
\begin{verbatim}
  select UPDATE .
   reduce < sv(1,closed) sv(2,open) > =(*,1)=>+ < SVS > .  -- to true.
   reduce < sv(3,closed) sv(4,ready) > =(*,1)=>+ < SVS > . -- to true.
   reduce < sv(5,open) > =(*,1)=>+ < SVS > .               -- to false.
\end{verbatim}
\normalsize
%% =======================================================================
By reducing the term in the code fragment, \cafeobj finds any next
states of the given global state, such as
\stt{<~sv(1,open)~sv(2,open)~>}\footnote{{\tt *}, {\tt 1}, and {\tt +}
  specify the range of search. If {\tt 2} is used instead of {\tt *},
  \cafeobj tries to find at most two next states. If {\tt 3} is used
  instead of {\tt 1}, \cafeobj finds all of the global states reachable from the
  given global state with at most three state transitions. If {\tt *} is used
  instead of {\tt +}, \cafeobj also includes the given global state as a
  search target.  Only \stt{=(*,1)=>+} is used in this dissertation.}.  The
first reduction returns true because both transition rules are
applicable.  The second one also returns true but only rule {\tt c2o}
is applicable. The third one returns false.

\cafeobj can find next states of a given global state such that some
conditions hold in those next states. Let us consider the following
code fragment\footnote{Since the final part of the {\tt reduce} sentence,
  {\tt \{~true~\}}, is for debugging, please ignore it.}:
%% =======================================================================
\small
\begin{verbatim}
  open UPDATE .
   pred anyOpen : SvSet .
   eq anyOpen(sv(N,open) SVS) = true .
   var CC : Bool .
   reduce 
    < sv(1,closed) sv(2,open) > =(*,1)=>+ < SVS > if CC
      suchThat CC implies anyOpen(SVS) { true } .        -- to true.
\end{verbatim}
\normalsize
%% =======================================================================
The reduction returns true in which \cafeobj finds any next states of
the given global state such that at least one {\tt open} service is
appearing. In this case, transition rule {\tt c2o} makes such next
state.  Note that when the conditional search predicate tries a
transition rule, it binds the rule's condition to Boolean variable
{\tt CC} placed at {\tt i\!f} clause. The {\tt suchThat} clause uses
{\tt CC} to check \stt{anyOpen(SVS)} only when the rule is applied.

On the other hand, when we want to check some condition holds in all of the
possible next states, we need some trick. The following code fragment
checks whether all of the possible next states of global state
\stt{<~sv(1,closed)~sv(2,open)~>} include at least one {\tt open} services:
%% =======================================================================
\small
\begin{verbatim}
  reduce not (
   < sv(1,closed) sv(2,open) > =(*,1)=>+ < SVS > if CC
     suchThat not ((CC implies anyOpen(SVS)) == true) { true } ) .
                                                        -- to false.
\end{verbatim}
\normalsize
%% =======================================================================
This style of coding is we call the {\it double negation idiom}
because it returns true when it CANNOT find any next states of the
given global state such that NO open service is appearing. The reduction
proceeds as follows:
\begin{enumerate}
\item Try to match LHS of {\tt c2o} to the given global state.
\item Also try to match the rule's condition (i.e.\ {\tt true} because
  the rule is unconditional) to {\tt CC} and the substituted RHS
  (i.e.\ \stt{<~sv(1,open)~sv(2,open)~>}) to \stt{<~SVS~>}.
\item Evaluate the substituted {\tt suchThat} clause which reduces to
  false \\ because \stt{anyOpen(sv(1,open) sv(2,open))} reduces to
  true.
\item Then, continuing the search to find a next state where the {\tt suchThat} clause holds,
  try to match LHS of {\tt o2r} to
  the given global state, the condition (i.e.\ \stt{\# SVS > 0}) to {\tt CC},
  and the substituted RHS (i.e.\ \stt{<~sv(2,ready)~sv(1,closed)~>}) to
  \stt{<~SVS~>}.
\item Evaluate the substituted {\tt suchThat} clause which reduces to
  true because \stt{sv(2,ready) sv(1,closed)} does not include any
  open services.
\item Then the search predicate returns true and the whole term
  reduces to false.
\end{enumerate}
This means that there is a next states of global state
\stt{<~sv(1,closed)~sv(2,open)~>} which does not include any {\tt open}
services; that is global state
\stt{<~sv(1,closed)~sv(2,ready)~>}.

Note that this is a typical example where we need \stt{\_ == true}. In
\cafeobj, $term1$ {\tt ==} $term2$ reduces to {\tt true} if both terms
are reduced to be the same term and to {\tt false} otherwise. On the
other hand, $term1$ {\tt =} $term2$ reduces to {\tt true} iff $term1$
{\tt ==} $term2$ reduces to {\tt true}. The following code fragment
shows difference between \stt{\_ = \_} and \stt{\_ == \_ }.
%% =======================================================================
\small
\begin{verbatim}
  reduce anyOpen(sv(1,closed)) = true .
                               -- no reduction occurs.
  reduce anyOpen(sv(1,closed)) == true . 
                               -- reduce to false.
\end{verbatim}
\normalsize
%% =======================================================================
In this case, \cafeobj cannot decide \stt{anyOpen(SVS)} does or does
not hold because the definition of {\tt anyOpen} is incomplete and
thus the first reduction above can reduce to neither {\tt true} nor
{\tt false}.  The second one using \stt{\_ == true} reduces to
{\tt false}, which is the reason why {\tt suchThat} clause in the
double negation idiom works as we intended.

%% ===============================================================
\subsection{Formalization of Search Predicates}
\label{sec:formalSearch}
%% ===============================================================
This section describes the search predicates more formally.  
\begin{definition}[unconditional search predicate]
  Let $Rule$ be a set of transition rules, and let $S$ and $S'$ be
  terms of sort {\tt State}. The \ul{unconditional search predicate,
    $FS(S,S')$} is represented as ``\stt{$S$ =(*,1)=>+ $S'$}''
  and holds iff there exists a transition rule $R=[l,r,c]\in Rule$ and
  a substitution $\sigma$ such that $S\sigma=l\sigma$ holds,
  $S'\sigma=r\sigma$ holds, and $c\sigma$ reduces to true.
\end{definition}
\begin{definition}[conditional search predicate]
  Let $Rule$ be a set of transition rules, $S$ and $S'$ terms of
  sort {\tt State}, and $CC$ and $B$ terms of sort {\tt Bool}. The
  \ul{conditional search predicate}, \ul{$CFS(S,S',CC,B)$} is
  represented as ``\stt{$S$ =(*,1)=>+ $S'$ if $CC$ suchThat $B$ \{
    $debug\_info$ \}}''\\ and holds iff there exists a transition
  rule $R=[l,r,c]\in Rule$ and a substitution $\sigma$ such that
  $S\sigma=l\sigma$ holds, $S'\sigma=r\sigma$ holds,
  $CC\sigma=c\sigma$ holds, and $B\sigma$ reduces to true.
  $B$ typically has a form ``\stt{$CC$ implies $p(S,S')$}'' where
  $p(S,S')$ is a predicate of global states.
\end{definition}

%% ===============================================================
\section{Verification by Proof Scores}
\label{sec:pscore}
%% ===============================================================
A {\it proof score} is an executable specification in \cafeobj such
that if executed as expected, then the desired theorem is
proved~\cite{FutatsugiGO12pps}. Verification by proof scores is an
interactive developing process to think through meaning of the
specification that is very important aspect of developing trusted
systems.

For example, let us verify that in module {\tt UPDATE} there should be
a next state of global state $S$ when at least two services included in $S$
are not {\tt ready}.
%% =======================================================================
\small
\begin{verbatim}
  module! ProofUPDATE {
   protecting(UPDATE)
  
   -- Theorem to be proved.
   pred theorem : Nat LocalState Nat LocalState SvSet
  
   vars N N1 N2 : Nat
   vars Lst1 Lst2 : LocalState .
   var SVS : SvSet
   var SS : State
  
   eq theorem(N1,Lst1,N2,Lst2,SVS)
     = ((Lst1 == ready) = false and (Lst2 == ready) = false)
       implies < sv(N1,Lst1) sv(N2,Lst2) SVS > =(*,1)=>+ SS .
  
   -- Axiom of Nat
   eq (1 + N > 0) = true .
  
   -- Arbitrary constants.
   ops st1 st2 : -> LocalState
   ops n1 n2 : -> Nat
   op svs : -> SvSet
  }
\end{verbatim}
\normalsize
%% =======================================================================
Module {\tt ProofUPDATE} gets ready for verification; it defines the
theorem to be proved and declares several arbitrary constants.  Note
that we require an axiom for natural numbers which says that the
successor of a natural number is always greater than 0.

Firstly, we begin with the most general case where all the aruguments of
{\tt theorem} are arbitrary constants:
%% =======================================================================
\small
\begin{verbatim}
  -- The most general case.
  open ProofUPDATE .
   reduce theorem(n1,st1,n2,st2,svs) . -- to false.
  close
\end{verbatim}
\normalsize
%% =======================================================================
This case is too general for \cafeobj to find any next states.
We should split the case into cases which collectively cover
the general case.  There are three case; (1) both services are closed,
(2) both services are open, and (3) one service is closed and another
is open. The following is a proof score for the three cases.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 1: Both services are closed.
  open ProofUPDATE .
   eq st1 = closed .
   eq st2 = closed .
   reduce theorem(n1,st1,n2,st2,svs) . -- to true.
  close
  
  -- Case 2: Both services are open.
  open ProofUPDATE .
   eq st1 = open .
   eq st2 = open .
   reduce theorem(n1,st1,n2,st2,svs) . -- to true.
  close
  
  -- Case 3: A closed service and an open service.
  open ProofUPDATE .
   eq st1 = closed .
   eq st2 = open .
   reduce theorem(n1,st1,n2,st2,svs) . -- to true.
  close
\end{verbatim}
\normalsize
%% =======================================================================
Verification is successfully done because all of the cases collectively covering
the most general case are proved.
%% ===============================================================
\section{Constructor-based Inductive Theorem Prover (CITP)}
\label{sec:CITP}
%% ===============================================================
As described above, interactive theorem proving is a systematic
process to split general cases into collectively covering cases until 
all of the cases are specific enough to be proved. Thereby, a proof score should
be written more carefully when case splitting becomes deeper. It
sometimes causes to carelessly forget some cases to be proved. In
fact, it may take considerable time to convince that the three cases in
the previous section collectively cover all of the cases.

In order to assist to develop proof scores which are more systematic
and easier to understand, \cafeobj provides CITP method consisting of
several special commands. The following is a list of part of CITP
commands\footnote{As its name suggests, CITP has capability to
  automatically produce inductive goals based on constructors, however
  we use it only for management of proof trees in this dissertation.}:
\begin{itemize}
\item \stt{:goal \{ eq $term$ = true . \}}\\ Define the goal to be
  proved and let it be the current case. Multiple goal equations
  can be specified.
\item \stt{:ctf \{ eq $LHS$ = $RHS$ . \}}\\
  Split the current case into two cases adding \stt{eq~$LHS$~=~$RHS$~.} to one case and\\
  \stt{eq~($LHS$~=~$RHS$)~=~false~.} to another.
\item \stt{:csp \{ eq $LH\mathit{S_1}$ = $RH\mathit{S_1}$ . eq $\mathit{LHS_2}$ = $\mathit{RHS_2}$ . $\dots$ \}}\\
  Split the current case into cases adding 
  \stt{eq~$\mathit{LHS_i}$~=~$\mathit{RHS_i}$~.} to each case.
\item \stt{:apply (rd)}\\
 Reduce the goal in the current case.
\item \stt{:def $name$ = :ctf \{ $\dots$ \}}\\
  \stt{:def $name$ = :csp \{ $\dots$ \}}\\
  Name the case splitting tactic.
\item \stt{:apply ($name_1\ name_2$)}\\ 
  Combine named case splitting tactics. When tactic $name_1$ splits an case into
  $n$ cases and tactic $name_2$ splits into $m$ cases, the current case is
  split into totally $n\times m$ cases.  It can also specify tactic
  {\tt rd}, i.e.\ \stt{:apply~($n_1\ n_2$~rd)}, which means reducing
  the goal in every split case.
\item \stt{:init [$label$] by \{ $substitution$ \}}\\
  Introduce a $labeled$ lemma proven by other proof scores. $substitution$ specifies
  how to unify the lemma to the current case. Detailed examples will be explained
  in Chapter~\ref{chap:verification}.
\item \stt{describe proof}\\
 Describe the proof tree consisting of split cases. Proven cases are shown by ``*'' marks.
\item \stt{show proof}\\
Summarize the proof tree consisting of split cases. Proven cases are shown by ``*'' marks.
\end{itemize}

The following is a proof score of CITP version of the example in the previous section:
%% =======================================================================
\small
\begin{verbatim}
  select ProofUPDATE .
  :goal {
    eq theorem(n1,st1,n2,st2,svs) = true .
  }
  :def csp-st1 = :csp {
   eq st1 = closed .
   eq st1 = open .
   eq st1 = ready .
  }
  :def csp-st2 = :csp {
   eq st2 = closed .
   eq st2 = open .
   eq st2 = ready .
  }
  :apply (csp-st1 csp-st2 rd)
  describe proof
\end{verbatim}
\normalsize
%% =======================================================================
Firstly, the goal to be proved should represent the most general case
where all the aruguments of {\tt theorem} are arbitrary constants.
Then, since class {\tt LocalState} has only
three constants ({\tt closed, open} , and {\tt ready}) as constructors
in module {\tt UPDATE}, there are three cases where {\tt st1} (and
also {\tt st2}) is one of the three constants in each of cases. Thereby
the combination of case splitting for {\tt st1} and {\tt st2}
collectively covers all of the cases.

The final command, \stt{describe proof}, describes the proof tree as
follows:
%% =======================================================================
\small
\begin{verbatim}
  ==> root*
      -- context module: #Goal-root
      -- targeted sentence:
        eq theorem(n1, st1, n2, st2, svs) = true .
  [csp-st1] 1*
      -- context module: #Goal-1
      -- assumption
        eq [csp-st1]: st1 = closed .
      -- targeted sentence:
        eq theorem(n1, st1, n2, st2, svs) = true .
  [csp-st2] 1-1*
      -- context module: #Goal-1-1
      -- assumptions
        eq [csp-st1]: st1 = closed .
        eq [csp-st2]: st2 = closed .
      -- discharged sentence:
        eq [RD]: theorem(n1, st1, n2, st2, svs) = true .
  [csp-st2] 1-2*
      -- context module: #Goal-1-2
      -- assumptions
        eq [csp-st1]: st1 = closed .
        eq [csp-st2]: st2 = open .
      -- discharged sentence:
        eq [RD]: theorem(n1, st1, n2, st2, svs) = true .
  [csp-st2] 1-3*
      -- context module: #Goal-1-3
      -- assumptions
        eq [csp-st1]: st1 = closed .
        eq [csp-st2]: st2 = ready .
      -- discharged sentence:
        eq [RD]: theorem(n1, st1, n2, st2, svs) = true .
  [csp-st1] 2*
      -- context module: #Goal-2
      -- assumption
        eq [csp-st1]: st1 = open .
      -- targeted sentence:
        eq theorem(n1, st1, n2, st2, svs) = true .
  [csp-st2] 2-1*
      -- context module: #Goal-2-1
      -- assumptions
        eq [csp-st1]: st1 = open .
        eq [csp-st2]: st2 = closed .
      -- discharged sentence:
        eq [RD]: theorem(n1, st1, n2, st2, svs) = true .
  [csp-st2] 2-2*
      -- context module: #Goal-2-2
      -- assumptions
        eq [csp-st1]: st1 = open .
        eq [csp-st2]: st2 = open .
      -- discharged sentence:
        eq [RD]: theorem(n1, st1, n2, st2, svs) = true .
  [csp-st2] 2-3*
      -- context module: #Goal-2-3
      -- assumptions
        eq [csp-st1]: st1 = open .
        eq [csp-st2]: st2 = ready .
      -- discharged sentence:
        eq [RD]: theorem(n1, st1, n2, st2, svs) = true .
  [csp-st1] 3*
      -- context module: #Goal-3
      -- assumption
        eq [csp-st1]: st1 = ready .
      -- targeted sentence:
        eq theorem(n1, st1, n2, st2, svs) = true .
  [csp-st2] 3-1*
      -- context module: #Goal-3-1
      -- assumptions
        eq [csp-st1]: st1 = ready .
        eq [csp-st2]: st2 = closed .
      -- discharged sentence:
        eq [RD]: theorem(n1, st1, n2, st2, svs) = true .
  [csp-st2] 3-2*
      -- context module: #Goal-3-2
      -- assumptions
        eq [csp-st1]: st1 = ready .
        eq [csp-st2]: st2 = open .
      -- discharged sentence:
        eq [RD]: theorem(n1, st1, n2, st2, svs) = true .
  [csp-st2] 3-3*
      -- context module: #Goal-3-3
      -- assumptions
        eq [csp-st1]: st1 = ready .
        eq [csp-st2]: st2 = ready .
      -- discharged sentence:
        eq [RD]: theorem(n1, st1, n2, st2, svs) = true .
\end{verbatim}
\normalsize
%% =======================================================================
This means that the most general case ({\tt root}) is split into three
cases ({\tt 1}, {\tt 2}, and {\tt 3}) using {\tt csp-st1} each of
which is also split into three case (for example, {\tt 1-1},
{\tt 1-2}, and {\tt 1-3}) using {\tt csp-st2}.  ``*'' marks show
all of the cases are successfully proved.

%% ===============================================================
%% \chapter{Models and Representations of Cloud Orchestration}
\chapter{Theorem Proving Framework}
\label{chap:model}
%% ===============================================================
The theorem proving framework proposed by this dissertation aims to
facilitate interactive proof development by allowing proof developers
to devote their time to thinking through meaning of their own
specifications and specific reasons why the specifications have some
desired properties rather than reinventing how to construct proof
scores or proving many specific versions of some common lemmas,
thereby reducing overall development time. By doing so, the framework
is expected to raise the skill level of novice proof developers and to
enable a number of engineers to efficiently develop the proof score
for a practical scale problem.

The framework supports developers using mainly two means to reuse
proof developments. Firstly, it provides a procedure how to develop
proof scores to verify leads-to properties as well as invariant
properties of cloud orchestration specifications. For every such
property, there are several proof goals all of which should reduce to
true. A proof score for each property consists of proof case trees
each of which corresponds to one of the proof goal. The root of a
proof case tree represents the most general case of the proof
goal. When the goal does not reduce to true in the root case, it
should be split into more concrete sub-cases which collectively cover
the root case. Such case splitting should be continued until all the
leaf cases reduce to true and then the proof goal is verified. The proof
development procedure provided by the framework prescribes what kind
of set of proof goals should be sufficient to verify invariant and
leads-to properties of specifications and guides how to split cases to
develop proof case trees. Proof developers can easily follow this
procedure to make the specific proof goals for their own
specifications and to proceed case splitting until all the goals
reduce to true.
 
Secondly, the framework provides many reusable lemmas that are
commonly used in the course of verification for invariant and leads-to
properties of cloud orchestration specifications. The provided lemmas
are already proved in a general level of abstraction and can be reused
simply by renaming included general terms to some specific ones
without reproving.

The reason why the framework can provide such a proof development
procedure and reusable lemmas for the specific problem domain, cloud
orchestration in our case, is because it makes specific specifications
adopt a general structure and behavior model for the domain and its
representation.  Proof developers can describe such specifications
only by instantiating logical templates provided by the framework and
adding small specific part of codes.

The reusable entities provided by the framework are four kinds of logic
templates, a lot of general predicates/operators included in the templates,
and a lot of lemmas about such predicates/operators which are proved in the general
level of abstraction. The framework also provides general sufficient
conditions to verify invariant and leads-to properties of cloud orchestration
specifications and provides a procedure to develop proof trees whose goals
are the sufficient conditions.

The rest of this chapter describes the general structure and behavior model and
its representation. The reusable entities provided by the framework will
be described in Chapter~\ref{chap:reusable} and the proof development procedure
will be described in Chapter~\ref{chap:verification}.

%% ===============================================================
\section{Structure Models and Representations}
\label{sec:structuremodel}
%% ===============================================================
Cloud Orchestration is automation of operations such as set-up,
scale-out, scale-in, or shutdown of cloud systems. In order to verify
correctness of an automated operation of a cloud system, we need to
model the structure of the target cloud system and the behavior of the
operation. We say ``model'' which means abstractly and formally
specifying the structure and behavior. A specified model is represented
by a formal specification language, namely \cafeobj in this dissertation.

CloudFormation models a structure of a cloud system simply as a set
of {\it resources} on IaaS platform of AWS. The model is called a {\it
  template} which is represented by JSON as illustrated in
Fig.~\ref{fig:AWSExample}.  A resource has an identifier and a type
and includes several {\it properties} which may depend on other
resources.

On the other hand, TOSCA's model of a cloud system is more structured
to manage any types of cloud resources, as well as inside VMs, and any
types of operations such as scale-out, scale-in, shutdown, and so on.
A TOSCA's model, called a {\it topology}, is represented by XML
as illustrated in Fig~\ref{fig:topology}. A topology consists of a set
of {\it nodes} and a set of {\it relationships} between nodes. A node
has several {\it capabilities} and {\it requirements}. A relationship
relates a requirement of a source node to a capability of a target
node.

In order to cover many different kinds of models of cloud system
structures, our framework provides a generic model of a cloud system
structure which consists of several {\it classes} of {\it
  objects}. For example, in the case of CloudFormation, a cloud system
consists of two classes (resource and property) of objects whereas
TOSCA models that a cloud system consists of four classes (node,
relationship, capability, and requirement). For a while, we explain
our framework using the simple CloudFormation template shown in
Fig.~\ref{fig:AWSExample} and the case of TOSCA topologies will be
explained in Chapter~\ref{chap:appTOSCA}.

An object has a {\it type}\footnote{Do not think a {\it type} is that
  of programming languages which is called {\it sort} in \cafeobj. A
  type is just an attribute of an object. We use the term because both
  CloudFormation and TOSCA use it.}, an {\it identifier}(ID), a {\it
  local state}, and possibly {\it links} to other objects. In the case
of the example shown in Fig.~\ref{fig:AWSExample}, a resource object
whose type is AWS::EC2::Instance has its ID as MyInstance. The type of
MyEIP resource is AWS::EC2::EIP. MyEIP has a property but its ID is
hidden and we assume it is MyEIP::InsID since its parent is MyEIP and
its type is InstanceId. MyEIP::InsID has a link to MyInstance. Local
states of objects are used for automation of operations, which will be
explained in Section~\ref{sec:behaviormodel}. 

An object belongs to a class and thus a class is a set of objects. We
assume this set consists of countably infinite objects each of which
has its fixed ID and type. Local states or links of objects may be
dynamically changed.  A class specifies the set of possible types, the set
of possible local states of its objects. A class also specifies how its
objects link to other objects.

Users of the framework should design representation of the system
model in \cafeobj language.  A class is represented as a \cafeobj
module that defines a sort of its objects, a constructor of the sort,
a set of literals of types, and a set of literals of local states.  An
object is represented as a ground constructor term of the sort.

For the example shown in Fig.~\ref{fig:AWSExample}, three objects may
be represented as the following ground terms:
%% =======================================================================
\small
\begin{verbatim}
  res(ec2Instance, myInstance, initial)
  res(ec2Eip, myEIP, initial)
  prop(instanceId,myEIP::InsID,notready,myEIP,myInstance)
\end{verbatim}
\normalsize
%% =======================================================================
Although the users of the framework can freely design the
representation of objects, typically the constructor name represents
the class of the object ({\tt res}, {\tt prop}), the first argument is
its type ({\tt ec2Instance}, {\tt ec2Eip}, {\tt instanceId}), the
second is its identifier ({\tt myInstance}, {\tt myEIP},
{\tt myEIP::InsID})\footnote{In this dissertation, we often use an identifier
  to designate an object which has the identifier for the sake of
  brevity.}, and the third is its local state. The fourth argument of the
property object represents a link to its parent, {\tt myEIP}, and the
fifth represents that the property depends on {\tt myInstance}. The
example of \cafeobj modules representing resource and property classes
will be shown in Chapter~\ref{chap:reusable}.
Note that a link is represented by an identifier of the linked object
in our framework.
%% ===============================================================
\section{Behavior Models and Representations}
\label{sec:behaviormodel}
%% ===============================================================
The framework models the behavior of an automated operation of a cloud
system as a state transition system in which a set of {\it transition rules} of
states specifies the behavior. We say a {\it global state} as a state
of the state machine in order to avoid the confusion with local states
of objects. A global state is a finite set of objects each of which is
included in some class. A transition rule makes a global state transit
to another global state where local states or links of some objects
are changed.

In the case of a template of CloudFormation, a global state consists
of finite number of resources and their properties. CloudFormation
tries to start all of the resources according to the dependency specified by
the template. In this dissertation, we use a very simple behavior model of
CloudFormation as an example; a local state of a resource is firstly
{\it initial} and becomes {\it started} but a dependent resource can
be {\it started} after all of the resources it depends become {\it started}.
The dependency is specified such that a property linking some resource
is firstly {\it notready} and becomes {\it ready} when the linked
resource is {\it started} and a resource can be {\it started} when all
of its properties become {\it ready}.  Figure~\ref{fig:R01R02}
illustrates the model where solid arrows show changes of local states
and dashed arrows show transition rules.
\begin{figure}
\centering
\includegraphics[height=4cm,natwidth=720,natheight=405,clip,trim=50 260 300 20]{R01R02.png}
\caption{Simple Behavior Model of CloudFormation}
\label{fig:R01R02}
\end{figure}

A global state is represented in \cafeobj as a ground constructor term
of sort {\tt State}, which is typically a tuple of sets of objects,
each of the sets is a finite subset of a class.  In the case of
CloudFormation, sort {\tt State} is defined as a pair of a set of
resources and a set of properties and the global state shown in
Fig.~\ref{fig:AWSExample} is represented as follows:\footnote{Module
  {\tt LINKS} and several sorts of constants will be explained in the
  next chapter.}
%% =======================================================================
\small
\begin{verbatim}
  module! STATE {
    protecting(LINKS)
    [State]
    op <_,_> : SetOfResource SetOfProperty -> State {constr}
  }
  
  open STATE . 
   -- Constants
   ops ec2Instance ec2Eip : -> RSTypeLt .
   ops myInstance myEIP : -> RSIDLt .
   ops myEIP::InsID : -> PRIDLt .
   op instanceId : -> PRTypeLt .
   op s0 : -> State .
   eq s0 =
    < (res(ec2Instance, myInstance, initial) 
       res(ec2Eip, myEIP, initial)),
      (prop(instanceId, myEIP::InsID, notready, myEIP, myInstance)) >
\end{verbatim}
\normalsize
%% =======================================================================
The behavior is modeled and represented by a set of two transition
rules as follows:
%% =======================================================================
\small
\begin{verbatim}
  module! STATERules {
   protecting(STATEfuns)
  
   -- Variables
   vars IDRS IDRRS : RSID 
   var IDPR : PRID
   var TRS : RSType
   var TPR : PRType
   var SetRS : SetOfResource
   var SetPR : SetOfProperty
  
   -- Start an initial resource
   --  if all of its properties are ready.
   ctrans [R01]:
      < (res(TRS,IDRS,initial) SetRS), SetPR >
   => < (res(TRS,IDRS,started) SetRS), SetPR > 
      if allPROfRSInStates(SetPR,IDRS,ready) .
  
   -- Let a not-ready property be ready 
   --  if its referring resource is started.
   trans [R02]:
      < (res(TRS,IDRRS,started) SetRS), 
        (prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR) >
   => < (res(TRS,IDRRS,started) SetRS), 
        (prop(TPR,IDPR,ready   ,IDRS,IDRRS) SetPR) > .
  }
\end{verbatim}
\normalsize
%% =======================================================================
Predicate \stt{allPROfRSInStates(SetPR,IDRS,ready)} checks a set of
properties {\tt SetPR} whether every property of resource {\tt IDRS}
is {\tt ready}, which will be explained in Section~\ref{sec:linkpred}.
Thus, rule {\tt R01} means that an {\tt initial} resource becomes {\tt
  started} when all of its properties are {\tt ready}.  The LHS of
rule {\tt R02} includes a resource and a property.  The second link of
the property is the identifier of the resource, which means the
property refers the resource.  Thereby, rule {\tt R02} means that a {\tt
  notready} property becomes {\tt ready} when it refers a {\tt
  started} resource.

%% ===============================================================
\section{Simulation of Models}
\label{sec:simulation}
%% ===============================================================
\cafeobj provides {\tt execute} command to execute a state machine
trying to apply transition rules as long as possible.
%% =======================================================================
\small
\begin{verbatim}
  open STATERules .
   -- Constants
   ops ec2Instance ec2Eip : -> RSTypeLt .
   ops myInstance myEIP : -> RSIDLt .
   ops myEIP::InsID : -> PRIDLt .
   op instanceId : -> PRTypeLt .
   op s0 : -> State .
   eq s0 =
     < (res(ec2Instance, myInstance,initial)
        res(ec2Eip,myEIP,initial)),
       (prop(instanceId,myEIP::InsID,notready,myEIP,myInstance)) > .
        
   execute s0 . 
   -- will be produced 
   -- < (res(ec2Instance, myInstance,started)
   --    res(ec2Eip,myEIP,started)),
   --   (prop(instanceId,myEIP::InsID,ready,myEIP,myInstance)) > .
\end{verbatim}
\normalsize
%% =======================================================================
The followings are part of log messages of the execution above, which
shows that firstly rule {\tt R01} makes {\tt myInstance} transit
from {\it initial} to {\it ready}, then {\tt R02} makes
{\tt myEIP::InsID} transit from {\it notready} to {\it ready}, and
finally {\tt R01} makes {\tt myEIP} transit from {\tt initial} to
{\it started}.
%% =======================================================================
\small
\begin{verbatim}
...
1>[2] apply trial #1
-- rule: ctrans [R01]: 
          (< (res(TRS,IDRS,initial) SetRS) , SetPR >) 
       => (< (res(TRS,IDRS,started) SetRS) , SetPR >)
       if allPROfRSInStates(SetPR,IDRS,ready)
    { IDRS |-> myInstance, 
      TRS |-> ec2Instance, 
      SetRS |-> res(ec2Eip,myEIP,initial), 
      SetPR |-> prop(instanceId,myEIP::InsID,notready,myEIP,myInstance)
    }
...
1>[19] match success #1
1<[19] (< (res(ec2Eip,myEIP,initial) res(ec2Instance,myInstance,initial)),
          (prop(instanceId,myEIP::InsID,notready,myEIP,myInstance)) >)
   --> (< (res(ec2Instance,myInstance,started) res(ec2Eip,myEIP,initial)),
          (prop(instanceId,myEIP::InsID,notready,myEIP,myInstance)) >)
1>[20] rule: trans [R02]:
          (< (res(TRS,IDRRS,started) SetRS),
             (prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR) >)
       => (< (res(TRS,IDRRS,started) SetRS),
             (prop(TPR,IDPR,ready,IDRS,IDRRS) SetPR) >)
    { IDPR |-> myEIP::InsID,
      TPR |-> instanceId,
      IDRS |-> myEIP,
      SetPR |-> empPR,
      IDRRS |-> myInstance,
      TRS |-> ec2Instance,
      SetRS |-> res(ec2Eip,myEIP,initial)
    }
1<[20] (< (res(ec2Eip,myEIP,initial) res(ec2Instance,myInstance,started)),
          (prop(instanceId,myEIP::InsID,notready,myEIP,myInstance)) >)
   --> (< (res(ec2Instance,myInstance,started) res(ec2Eip,myEIP,initial)),
          (prop(instanceId,myEIP::InsID,ready,myEIP,myInstance)) >)
1>[21] apply trial #1
...
1>[42] match success #1
1<[42] (< (res(ec2Eip,myEIP,initial) res(ec2Instance,myInstance,started)),
          (prop(instanceId,myEIP::InsID,ready,myEIP,myInstance)) >)
   --> (< (res(ec2Eip,myEIP,started) res(ec2Instance,myInstance,started)),
          (prop(instanceId,myEIP::InsID,ready,myEIP,myInstance)) >)

(< (res(ec2Instance,myInstance,started) res(ec2Eip,myEIP,started)),
   (prop(instanceId,myEIP::InsID,ready,myEIP,myInstance)) >):State
\end{verbatim}
\normalsize
%% =======================================================================

%% ===============================================================
\chapter{General Templates and Predicate Libraries}
\label{chap:reusable}
%% ===============================================================
The framework uses the template mechanism of \cafeobj to provide a
general way to model cloud orchestration, predefined predicate
libraries, and proved lemmas together with their proof scores.
%% ===============================================================
\section{Template Modules of Objects}
\label{sec:objectbase}
%% ===============================================================
Template module {\tt OBJECTBASE} defines nine sorts and more than ten
operators/predicates of objects, which generally and minimally defines
what an object is in a class. The template can be instantiated and
imported in a module for each class of objects, where the imported
sorts and operators can be used just by renaming appropriately. For
the example shown in Fig.~\ref{fig:AWSExample}, following module
{\tt RESOURCE} describes specifications of the resource class for
CloudFormation\footnote{{\tt OBJECTBASE} is a template with no
  parameter and is used to instantiate a new module and to rename
  predefined sorts/operators.}.
%% =======================================================================
\small
\begin{verbatim}
  module! RESOURCE {
    -- Instantiation of Template
    extending(OBJECTBASE
      * {sort Object -> Resource,
         sort ObjIDLt -> RSIDLt,
         sort ObjID -> RSID,
         sort ObjTypeLt -> RSTypeLt,
         sort ObjType -> RSType,
         sort ObjStateLt -> RSStateLt,
         sort ObjState -> RSState,
         sort SetOfObject -> SetOfResource,
         sort SetOfObjState -> SetOfRSState,
         op empObj -> empRS,
         op empState -> empSRS,
         op existObj -> existRS,
         op existObjInStates -> existRSInStates,
         op uniqObj -> uniqRS,
         op #ObjInStates -> #ResourceInStates,
         op getObject -> getResource,
         op allObjInStates -> allRSInStates,
         op allObjNotInStates -> allRSNotInStates,
         op someObjInStates -> someRSInStates}
    )
  
    -- Constructor
    -- res(RSType, RSID, RSState) is a Resource.
    op res : RSType RSID RSState -> Resource {constr}
  
    -- Variables
    var TRS : RSType
    var IDRS : RSID
    var SRS : RSState
  
    -- Selectors
    eq type(res(TRS,IDRS,SRS)) = TRS .
    eq id(res(TRS,IDRS,SRS)) = IDRS .
    eq state(res(TRS,IDRS,SRS)) = SRS .
  
    -- Local States
    ops initial started : -> RSStateLt {constr}
  }
\end{verbatim}
\normalsize
%% =======================================================================
The following is a list of nine sorts predefined by
template module {\tt OBJECTBASE}:
\begin{itemize}
\item \stt{Object} (renamed as \stt{Resource} in this case)\\
  Sort for objects themselves.
\item \stt{ObjIDLt} (as \stt{RSIDLt})\\
  Subsort of {\tt ObjID} for identifier literals. A literal is a
  constant for which {\tt OBJECTBASE} predefines a special equality
  predicate such that $\_ = \_$ is exactly the same as $\_ == \_ $ .
\item \stt{ObjID} (as \stt{RSID})\\
  Sort for identifiers of objects.
\item \stt{ObjTypeLt} (as \stt{RSTypeLt})\\
  Subsort of {\tt ObjType} for type literals.
\item \stt{ObjType} (as \stt{RSType})\\
  Sort for types of objects.
\item \stt{ObjStateLt} (as \stt{RSStateLt})\\
  Subsort of {\tt ObjState} for local state literals.
\item \stt{ObjState} (as \stt{RSState})\\
  Sort for local states of objects.
\item \stt{SetOfObject} (as \stt{SetOfResource})\\
  Soft for sets of objects.
\item \stt{SetOfObjState} (as \stt{SetOfRSState})\\
  Sort for sets of local states of objects.
\end{itemize}

The following is a list of part of operators predefined by
template module {\tt OBJECTBASE} whereas argument $\mathit{obj}$ is an object,
$id$ is an identifier of an object, $seto$ is a set of objects, and
$setls$ is a set of local states of objects:
\begin{itemize}
\item \stt{empObj} (renamed as \stt{empRS} in this case)\\
  Constant representing an empty set of objects.
\item \stt{empState} (as \stt{empSRS})\\
  Constant representing an empty set of local states of objects.
\item \stt{existObj} (as \stt{existRS})\\ 
  Predicate used as \stt{existObj($seto$,$id$)} which holds iff some
  object with identifier $id$ is included in $seto$;\\$~~~~\exists o\in
  seto: \mbstt{id}(o)=id$.
\item \stt{existObjInStates} (as \stt{existRSInStates})\\
  Predicate used as \stt{existObjInStates($seto$,$id$,$setls$)} which
  holds iff some object with identifier $id$ is included in $seto$ and
  its local state is included in $setls$;\\$~~~~\exists o\in seto:
  (\mbstt{id}(o)=id \land \mbstt{state}(o)\in setls)$.
\item \stt{uniqObj} (as \stt{uniqRS})\\
  Predicate used as \stt{uniqObj($seto$)} which holds iff the
  identifier of each object is unique in $seto$;\\$~~~~\forall o,o'\in
  seto:(o\ne o'\ra\mbstt{id}(o)\ne\mbstt{id}(o'))$.
\item \stt{\#ObjInStates} (as \stt{\#ResourceInStates})\\ 
  Operator used as \stt{\#ObjInStates($setls$,$seto$)} which returns
  the number of objects in $seto$ whose local states are
  included in $setls$.
\item \stt{getObject} (as \stt{getResource})\\ 
  Operator used as \stt{getObject($seto$,$id$)} which returns an
  object in $seto$ whose identifier is $id$.
\item \stt{allObjInStates} (as \stt{allRSInStates})\\
  Predicate used as \stt{allObjInStates($seto$,$setls$)} which holds iff
  the local states of all the objects in $seto$ are included
  in $setls$;\\$~~~~\forall o\in seto:\mbstt{state}(o)\in setls$.
\item \stt{allObjNotInStates} (as \stt{allRSNotInStates})\\
  Predicate used as \stt{allObjNotInStates($seto$,$setls$)} which holds iff
  the local states of all the objects in $seto$ are not included
  in $setls$;\\$~~~~\forall o\in seto:\mbstt{state}(o)\not\in setls$.
\item \stt{someObjInStates} (as \stt{someRSInStates})\\ 
  Predicate used as \stt{someObjInStates($seto$,$setls$)} which holds
  iff there exists an objects in $seto$ whose local state is included
  in $setls$;\\$~~~~\exists o\in seto:\mbstt{state}(o)\in setls$.
\end{itemize}

The module importing the instantiated template can extend it to
freely define a constructor of objects and local state literals.  In
this case, module {\tt RESOURCE} defines a constructor ({\tt res}) of
sort {\tt Resource} whose arguments are a type, an identifier, and a
local state of the resource. It also defines two local state literals,
{\tt initial} and {\tt started}, of a resource.

In addition, the module should implement three selector operators,
{\tt type}, {\tt id}, and {\tt state}, each of which takes a resource
as an argument and returns the type, the identifier, and the local
state of the resource respectively and {\tt OBJECTBASE} uses them to
implement the predefined general operators\footnote{{\tt OBJECTBASE}
  declares and uses these operators and so {\tt RESOURCE} only should
  define them by equations.}.

Similarly, following module {\tt PROPERTY} specifies the property class 
for the example shown in Fig.~\ref{fig:AWSExample}.
%% =======================================================================
\small
\begin{verbatim}
  module! PROPERTY {
    protecting(RESOURCE)
  
    -- Instantiation of Template
    extending(OBJECTBASE
      * {sort Object -> Property,
         sort ObjIDLt -> PRIDLt,
         sort ObjID -> PRID,
         sort ObjTypeLt -> PRTypeLt,
         sort ObjType -> PRType,
         sort ObjStateLt -> PRStateLt,
         sort ObjState -> PRState,
         sort SetOfObject -> SetOfProperty,
         sort SetOfObjState -> SetOfPRState,
         op empObj -> empPR,
         op empState -> empSPR,
         op existObj -> existPR,
         op existObjInStates -> existPRInStates,
         op uniqObj -> uniqPR,
         op #ObjInStates -> #PropertyInStates,
         op getObject -> getProperty,
         op allObjInStates -> allPRInStates,
         op allObjNotInStates -> allPRNotInStates,
         op someObjInStates -> somePRInStates}
    )
  
    -- Constructor
    -- prop(PRType, PRID, PRState, RSID, RSID) is a Property.
    op prop : PRType PRID PRState RSID RSID -> Property {constr}
  
    -- Variables
    var TPR : PRType
    var IDPR : PRID
    var SPR : PRState
    vars IDRS1 IDRS2 : RSID
  
    -- Selectors
    op parent : Property -> RSID
    op refer : Property -> RSID
    eq type(prop(TPR,IDPR,SPR,IDRS1,IDRS2)) = TPR .
    eq id(prop(TPR,IDPR,SPR,IDRS1,IDRS2)) = IDPR .
    eq state(prop(TPR,IDPR,SPR,IDRS1,IDRS2)) = SPR .
    eq parent(prop(TPR,IDPR,SPR,IDRS1,IDRS2)) = IDRS1 .
    eq refer(prop(TPR,IDPR,SPR,IDRS1,IDRS2)) = IDRS2 .
  
    -- Local States
    ops notready ready : -> PRStateLt {constr}
  }
\end{verbatim}
\normalsize
%% =======================================================================
Firstly, module {\tt PROPERTY} imports module {\tt RESOURCE} using
{\tt protecting} because a property object links to its parent
resource and also links to its referring resource.

Module {\tt PROPERTY} defines a constructor ({\tt prop}) of sort
{\tt Property} whose arguments are a type, an identifier, a local
state, and links of the property. As noted before, a link is
represented by an identifier of the linked object.  It also defines
two local state literals, {\tt notready} and {\tt ready}, of a property.

In addition to the mandatory selectors ({\tt type}, {\tt id}, and
{\tt state}), module {\tt PROPERTY} declares and defines two more
selectors, {\tt parent} and {\tt refer}, each of which returns a
parent resource and a referring resource of the property respectively.

%% ===============================================================
\section{Template Modules for Links}
\label{sec:linkpred}
%% ===============================================================
In addition to the operators provided by template module {\tt OBJECTBASE}, two
template modules {\tt OBJLINKMANY2ONE} and {\tt OBJLINKONE2ONE}
provide many predefined operators/predicates for links between
objects. Representing object structures by using links, instead of
nesting structures, enables the framework to be easily applied to any
kinds of model structures and to effectively provide a predefined set
of operators/predicates.

A template module {\tt OBJLINKMANY2ONE} takes one parameter module of
a class whose object links to another object. In order to provide
predefined operators for links, the template module assumes that the
parameter module defines eleven specific sorts and five specific
operators. For example, it assumes that a parameter module defines
{\tt Object} as a sort for linking objects, {\tt LObject} as a sort
for linked objects, {\tt link} as a selector of {\tt Object} which
returns the identifier of linked object, and so on. When the actual
parameter module defines those sorts and operators with the different
names from ones assumed, \cafeobj allows to specify correspondence of
the names. In the case of CloudFormation, the sort for linking objects
is {\tt Property}, the sort for linked objects is {\tt Resource}, and
the selectors are {\tt parent} and {\tt refer} defined by module
{\tt PROPERTY}.  The following module {\tt LINKS} imports
{\tt OBJLINKMANY2ONE} twice for both kinds of links specifying the
correspondence of the names:
%% =======================================================================
\small
\begin{verbatim}
  module! LINKS {
    -- A Property links to its parent Resource
    extending(OBJLINKMANY2ONE(
      PROPERTY {sort Object -> Property,
                sort ObjID -> PRID,
                sort ObjType -> PRType,
                sort ObjState -> PRState,
                sort SetOfObject -> SetOfProperty,
                sort SetOfObjState -> SetOfPRState,
                sort LObject -> Resource,
                sort LObjID -> RSID,
                sort LObjState -> RSState,
                sort SetOfLObject -> SetOfResource,
                sort SetOfLObjState -> SetOfRSState,
                op link -> parent,
                op empLObj -> empRS,
                op existLObj -> existRS,
                op existLObjInStates -> existRSInStates,
                op getLObject -> getResource}
      )
      * {op hasLObj -> hasParent,
         op getXOfZ -> getRSOfPR,
         op getZsOfX -> getPRsOfRS,
         op getZsOfXInStates -> getPRsOfRSInStates,
         op getXsOfZs -> getRSsOfPRs,
         op getXsOfZsInStates -> getRSsOfPRsInStates,
         op getZsOfXs -> getPRsOfRSs,
         op getZsOfXsInStates -> getPRsOfRSsInStates,
         op allZHaveX -> allPRHaveRS,
         op allZOfXInStates -> allPROfRSInStates,
         op ifOfXThenInStates -> ifOfRSThenInStates,
         op ifXInStatesThenZInStates -> ifRSInStatesThenPRInStates}
    )
  
    -- A Property links to its referring Resource
    extending(OBJLINKMANY2ONE(
      PROPERTY {sort Object -> Property,
                sort ObjID -> PRID,
                sort ObjType -> PRType,
                sort ObjState -> PRState,
                sort SetOfObject -> SetOfProperty,
                sort SetOfObjState -> SetOfPRState,
                sort LObject -> Resource,
                sort LObjID -> RSID,
                sort LObjState -> RSState,
                sort SetOfLObject -> SetOfResource,
                sort SetOfLObjState -> SetOfRSState,
                op link -> refer,
                op empLObj -> empRS,
                op existLObj -> existRS,
                op existLObjInStates -> existRSInStates,
                op getLObject -> getResource}
      )
      * {op hasLObj -> hasRefRS,
         op getXOfZ -> getRRSOfPR,
         op getZsOfX -> getPRsOfRRS,
         op getZsOfXInStates -> getPRsOfRRSInStates,
         op getXsOfZs -> getRRSsOfPRs,
         op getXsOfZsInStates -> getRRSsOfPRsInStates,
         op getZsOfXs -> getPRsOfRRSs,
         op getZsOfXsInStates -> getPRsOfRRSsInStates,
         op allZHaveX -> allPRHaveRRS,
         op allZOfXInStates -> allPROfRRSInStates,
         op ifOfXThenInStates -> ifOfRRSThenInStates,
         op ifXInStatesThenZInStates -> ifRRSInStatesThenPRInStates}
      )
  }
\end{verbatim}
\normalsize
%% =======================================================================
The following is a list of eleven sorts assumed by
module {\tt OBJLINKMANY2ONE}:
\begin{itemize}
\item \stt{Object} (actually named as \stt{Property} in this case)\\
  Sort for linking objects.
\item \stt{ObjID} (as \stt{PRID})\\
  Sort for identifiers of linking objects.
\item \stt{ObjType} (as \stt{PRType})\\
  Sort for types of linking objects.
\item \stt{ObjState} (as \stt{PRState})\\
  Sort for local states of linking objects.
\item \stt{SetOfObject} (as \stt{SetOfProperty})\\
  Sort for sets of linking objects.
\item \stt{SetOfObjState} (as \stt{SetOfPRState})\\
  Sort for sets of local states of linking objects.
\item \stt{LObject} (as \stt{Resource})\\
  Sort for linked objects.
\item \stt{LObjID} (as \stt{RSID})\\
  Sort for identifiers of linked objects.
\item \stt{LObjState} (as \stt{RSState})\\
  Sort for local states of linked objects.
\item \stt{SetOfLObject} (as \stt{SetOfResource})\\
  Sort for sets of linked objects.
\item \stt{SetOfLObjState} (as \stt{SetOfRSState})\\
  Sort for sets of local states of linked objects.
\end{itemize}

The following is a list of five operators assumed by
module {\tt OBJLINKMANY2ONE} whereas argument $\mathit{obj}$ is a linking
object, $lid$ is an identifier of a linked object, $setlo$ is a set of
linked objects, and $setlls$ is a set of local states of linked
objects:
\begin{itemize}
\item \stt{link} (actually named as \stt{parent} and \stt{refer} in this case)\\
  Selector used as \stt{link($\mathit{obj}$)} which returns the identifier of
  the object linked by $\mathit{obj}$.
\item \stt{empLObj} (as \stt{empRS})\\
  Constant representing an empty set of linked objects.
\item \stt{existLObj} (as \stt{existRS})\\
  Predicate used as \stt{existLObj($setlo$,$lid$)} which holds iff a
  linked object with identifier $lid$ is included in
  $setlo$;\\$~~~~\exists lo\in setlo:\mbstt{id}(lo)=lid$.
\item \stt{existLObjInStates} (as \stt{existRSInStates})\\
  Predicate used as \stt{existLObjInStates($setlo$,$lid$,$setlls$)}
  which holds iff a linked object with identifier $lid$ is included
  in $setlo$ and its local state is included in
  $setlls$;\\$~~~~\exists lo\in setlo:(\mbstt{id}(lo)=lid\land
  \mbstt{state}(lo)\in setlls)$.
\item \stt{getLObject} (as \stt{getResource})\\
  Operator used as \stt{getLObject($setlo$,$lid$)} which returns an
  object in $setlo$ whose identifier is $lid$.
\end{itemize}
Note that {\tt LINKS} imports {\tt OBJLINKMANY2ONE} twice but only
selector {\tt link} is specified differently, {\tt parent} and {\tt
  refer}, and others are the same.

Many operators/predicates between linking (Z) and linked (X) objects
are provided. In this case, each of them is twice renamed differently.
The following is a list of part of operators predefined by template
module {\tt OBJLINKMANY2ONE} whereas argument $\mathit{obj}$ is a linking
object, $seto$ is a set of linking objects, $setls$ is a set of local
states of linking objects, $\mathit{lobj}$ is a linked object, $lid$ is an
identifier of a linked object, $setlo$ is a set of linked objects, and
$setlls$ is a set of local states of linked objects:
\begin{itemize}
\item \stt{hasLObj} (renamed as \stt{hasParent} and \stt{hasRefRS} in this case)\\
  Predicate used as \stt{hasLObj($\mathit{obj}$,$setlo$)} which holds iff
  the object linked by $\mathit{obj}$ is included in $setlo$;\\$~~~~\exists lo\in
  setlo:\mbstt{id}(lo)=\mbstt{link}(\mathit{obj})$.
\item \stt{getXOfZ} (as \stt{getRSOfPR} and \stt{getRRSOfPR})\\
  Operator used as \stt{getXOfZ($setlo$,$\mathit{obj}$)} which returns an
  object linked by $\mathit{obj}$ and included in $setlo$. When there is no such
  object in $setlo$, what it returns is undefined.
\item \stt{getZsOfX} (as \stt{getPRsOfRS} and \stt{getPRsOfRRS})\\
  Operator used as \stt{getZsOfX($seto$,$\mathit{lobj}$)} which returns a subset
  $seto$ each of whose element object links to $\mathit{lobj}$.
\item \stt{getZsOfXInStates} (as \stt{getPRsOfRSInStates} and \stt{getPRsOfRRSInStates})\\
  Operator used as \stt{getZsOfXInStates($seto$,$\mathit{lobj}$,$setls$)} which
  returns a subset of $seto$ each of whose element object links to
  $\mathit{lobj}$ and is in one of local states of $setls$.
\item \stt{getXsOfZs} (as \stt{getRSsOfPRs} and \stt{getRRSsOfPRs})\\
  Operator used as \stt{getXsOfZs($setlo$,$seto$)} which returns a
  subset of $setlo$ each of whose element object is linked by some
  object included in $seto$.
\item \stt{getXsOfZsInStates} (as \stt{getRSsOfPRsInStates} and \stt{getRRSsOfPRsInStates})\\
  Operator used as \stt{getXsOfZsInStates($setlo$,$seto$,$setlls$)}
  which returns a subset of $setlo$ each of whose element object is
  linked by some object included in $seto$ and is in one of local
  states of $setlls$.
\item \stt{getZsOfXs} (as \stt{getPRsOfRSs} and \stt{getPRsOfRRSs})\\
  Operator used as \stt{getZsOfXs($seto$,$setlo$)} which returns a
  subset of $seto$ each of whose element object links to some object
  included in $setlo$.
\item \stt{getZsOfXsInStates} (as \stt{getPRsOfRSsInStates} and \stt{getPRsOfRRSsInStates})\\
  Operator used as \stt{getZsOfXsInStates($seto$,$setlo$,$setls$)}
  which returns a subset of $seto$ each of whose element object links
  to some object included in $setlo$ and is in one of local states of
  $setls$.
\item \stt{allZHaveX} (as \stt{allPRHaveRS} and \stt{allPRHaveRRS})\\
  Predicate used as \stt{allZHaveX($seto$,$setlo$)} which holds iff
  every object included in $seto$ has objects linked by it
  which are included in $setlo$;\\$~~~~\forall o\in seto,\exists lo\in
  setlo:\mbstt{id}(lo)=\mbstt{link}(o)$.
\item \stt{allZOfXInStates} (as \stt{allPROfRSInStates} and \stt{allPROfRRSInStates})\\
  Predicate used as \stt{allZOfXInStates($seto$,$lid$,$setls$)} which
  holds iff every object included in $seto$ whose link is $lid$
  is in one of locals state in $setls$;\\$~~~~\forall o\in
  seto:(\mbstt{link}(o)=lid\ra\mbstt{state}(o)\in setls)$.
\item \stt{ifOfXThenInStates} (as \stt{ifOfRSThenInStates} and \stt{ifOfRRSThenInStates})\\
  Predicate used as \stt{ifOfXThenInStates($\mathit{obj}$,$lid$,$setls$)} which
  holds iff the link of $\mathit{obj}$ is not $lid$ or the local state of
  $\mathit{obj}$ is included in
  $setls$;\\$~~~~\mbstt{link}(\mathit{obj})=lid\ra\mbstt{state}(\mathit{obj})\in setls$.
\item \stt{ifXInStatesThenZInStates}\\
(as \stt{ifRSInStatesThenPRInStates} and \stt{ifRRSInStatesThenPRInStates})\\
  Predicate used as
  \stt{ifXInStatesThenZInStates($setlo$,$setlls$,$seto$,$setls$)}
  which holds iff every object included in $setlo$ whose local
  sate is included in $setlls$ is linked by objects included in $seto$
  each of which is in one of local states in $setls$;
  \vspace{-0.3cm}
  \begin{eqnarray*}
    &&\forall lo\in setlo:(\mbstt{state}(lo)\in setlls\ra\\
    &&~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    \forall o\in seto: (\mbstt{link}(o)=\mbstt{id}(lo)\ra\mbstt{state}(o)\in setls)).
  \end{eqnarray*}
\end{itemize}

Similarly module {\tt OBJLINKONE2ONE} provides predicates for one to
one relationships between objects, which will be explained in
Section~\ref{sec:TOSCAstructRep}.

%% ===============================================================
\section{Proved Lemmas for Predefined Predicates}
\label{sec:lemma}
%% ===============================================================
In the course of verification, a lot of lemmas about predefined
predicates are commonly required.  The framework provides many 
typical lemmas which are already proved in a general
level of abstraction
and can be used for any instantiated predicates without individual
proofs. Most of proved lemmas provided together with proof scores
written in \cafeobj.
%% ===============================================================
\subsection{Basic Lemmas}
\label{sec:baselemma}
%% ===============================================================
\begin{lemma}[Implication Lemma]
  Let {\tt A} and {\tt B} be Boolean terms in \cafeobj, then \stt{A
    implies B} is equivalent to \stt{A and B = A}.
\end{lemma}
A lemma typically has a form $A \ra B$. When using this to prove
a $goal$, we may write a proof score in \cafeobj as follows:
%% =======================================================================
\small
\begin{verbatim}
  reduce (A implies B) implies goal .
\end{verbatim}
\normalsize
%% =======================================================================
However, this style is somewhat inconvenient. Remember that CITP
method tries to prove a fixed set of goals in many cases. If several lemmas are
effective to different cases, we should use a complicated goal set such as:
%% =======================================================================
\small
\begin{verbatim}
  :goal {
    eq (A1 implies B1) and (A2 implies B2) ... implies goal1 = true .
    eq (A1 implies B1) and (A2 implies B2) ... implies goal2 = true .
    ...
  }
\end{verbatim}
\normalsize
%% =======================================================================
This style is not only complicated but also very expensive to execute.
\cafeobj internally represents a logical formula in the algebraic
normal form (ANF), in which a formula represented as ANDed terms are
XORed. For example, formula \stt{(A implies B) implies goal} is
represented as \stt{A xor B xor goal xor (A and B) xor (A and goal)
  xor (A and B and goal)}. The ANF of a goal would become
exponentially long along with the number of lemmas.

Using the Implication Lemma, we can define lemmas in an independent
style from goals as follows:
%% =======================================================================
\small
\begin{verbatim}
  eq (A1 and B1) = A1 .
  eq (A2 and B2) = A2 .
  ...
  :goal {
    eq goal1 = true .
    eq goal2 = true .
    ...
  }
\end{verbatim}
\normalsize
%% =======================================================================

\begin{lemma}[Set Predicate Lemma]
Let {\tt S} be a set of object, {\tt P} a predicate of an object,
{\tt allObjP} a predicate of a set of objects where
\stt{allObjP(S)} holds iff \stt{P(O)} holds for every object {\tt O}
in {\tt S}. Then, if \stt{allObjP(S)} does not hold, then there exists
an object {\tt O'} and a set {\tt S'} of objects such that \stt{S=(O'
  S')} holds and \stt{P(O')} does not hold\footnote{Many proved lemmas
  including the Set Predicate Lemma are proved using the mathematical induction
  about constructors. Therefor, the user should not additionally define
  constructors of predefined sorts.}.
\end{lemma}
\begin{corollary}
Let {\tt S} be a set of object, {\tt P} a predicate of an object,
{\tt someObjP} a predicate of a set of objects where
\stt{someObjP(S)} holds iff \stt{P(O)} holds for some object {\tt O}
in {\tt S}. Then, if \stt{someObjP(S)} holds, then there exists an
object {\tt O'} and a set {\tt S'} of objects such that \stt{S=(O'
  S')} holds and \stt{P(O')} holds.
\end{corollary}
Since a cloud system structure is modeled as a collection of several
classes of objects, proof is often split into two cases where all the
elements in a certain set of objects do or do not satisfy a certain
condition.  For example, since the condition of rule {\tt R01} is 
\stt{allPROfRSInStates(SetPR, IDRS,ready)}, proof is split into two
cases; all the properties of resource {\tt IDRS} are or are not
{\tt ready}.

Template module {\tt OBJECTBASE} predefines a general predicate {\tt
  allObjP} that uses an object predicate {\tt P} and checks if
\stt{P(O)} holds for every object {\tt O} in a given set of
objects. Similarly it predefines a general predicate {\tt
  someObjP}. Here, it is important to note that many predicates
provided by the template modules are ones instantiated from {\tt
  allObjP} or {\tt someObjP}.

For example, {\tt allZOfXInStates} is instantiated from {\tt allObjP}
where \stt{P(O)} holds iff {\tt O} is in one of given local
states whenever it links to a given linked object.  As explained in
Section~\ref{sec:linkpred}, {\tt allPROfRSInStates} is renamed
from {\tt allZOfXInStates} and thus the Set Predicate Lemma can be used to
split cases where the condition of rule {\tt R01} does or does not
hold as follows:
%% =======================================================================
\small
\begin{verbatim}
  :csp {
    eq allPROfRSInStates(setPR,idRS,ready) = true .
    eq setPR = (PR' setPR') .
  }
\end{verbatim}
\normalsize
%% =======================================================================
Note that in this case, {\tt PR'} should be a property whose parent is
resource {\tt idRS} but is not {\tt ready} (i.e.\ is {\tt
  notready}). Thus, it can be represented as
\stt{prop(tpr,idPR,notready,idRS,idRRS)} where {\tt tpr}, {\tt idPR},
and {\tt idRRS} are arbitrary constants. Then, the following case splitting
collectively covers all of the cases:
%% =======================================================================
\small
\begin{verbatim}
  :csp {
    eq allPROfRSInState(setPR,idRS,ready) = true .
    eq setPR = (prop(tpr,idPR,notready,idRS,idRRS) setPR') .
  }
\end{verbatim}
\normalsize
%% =======================================================================

For another example, since {\tt existRS} is instantiated from {\tt
  someObjP}, a typical case splitting code is as follows:
%% =======================================================================
\small
\begin{verbatim}
  :csp {
    eq existRS(setRS,idRS) = false .
    eq setRS = (res(trs,idRS,srs) setRS') .
  }
\end{verbatim}
\normalsize
%% =======================================================================

%% ===============================================================
\subsection{Lemmas for Link Predicates}
\label{sec:linklemma}
%% ===============================================================
The framework provides many proved lemmas for predefined predicates
provided by\\ {\tt OBJLINKMANY2ONE} and {\tt OBJLINKONE2ONE}. This
section describes two of them with example usages.

\begin{lemma}[Many-2-One Lemma 07]
  Let {\tt S\_X} be a set of linking objects, {\tt S\_Z} a set of
  linked objects, {\tt St\_X} a set of local states of linking
  objects, {\tt St\_Z} a set of local states of linked objects, and
  let {\tt SX} be a local state of linking object where {\tt SX} is not
  included in {\tt St\_X}. Then, \stt{allObjInStates(S\_X,St)} implies
  \stt{ifXInStatesThenZInStates(S\_X,St\_X,S\_Z,St\_Z)}.
\end{lemma}
This lemma is represented in \cafeobj as follows\footnote{\stt{prec:~64} 
means the operator precedence of {\tt when} is 64 (very low) and 
{\tt r-assoc} means it is right associative.}:
%% =======================================================================
\small
\begin{verbatim}
  vars B1 B2 : Bool
  pred (_when _) : Bool Bool { prec: 64 r-assoc }
  eq (B1 when B2)
     = B2 implies B1 .

  var S_X : SetOfLObject
  var S_Z : SetOfObject
  var SX : LObjState
  var St_X : SetOfLObjState
  var St_Z : SetOfObjState
  pred m2o-lemma07 : SetOfLObject LObjState SetOfLObjState 
                     SetOfObject SetOfObjState
  eq m2o-lemma07(S_X,SX,St_X,S_Z,St_Z)
     = allObjInStates(S_X,SX) implies 
       ifXInStatesThenZInStates(S_X,St_X,S_Z,St_Z)
     when not (SX \in St_X) .
\end{verbatim}
\normalsize
%% =======================================================================
In the course of verification of the transition rule set in
Section~\ref{sec:behaviormodel}, we need an invariant which says that
every {\tt started} parent resource has {\tt ready} properties
only. It is represented as follows:
%% =======================================================================
\small
\begin{verbatim}
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  pred inv-ifRSStartedThenPRReady : State
  eq inv-ifRSStartedThenPRReady(< SetRS,SetPR >)
     = ifRSInStatesThenPRInStates(SetRS,started,SetPR,ready) .
\end{verbatim}
\normalsize
%% =======================================================================
In order to show the invariant property of {\tt
  inv-ifRSStartedThenPRReady}, we need a lemma which says that if all of the
resources are {\tt initial} then {\tt inv-ifRSStartedThenPRReady}
holds.  The lemma could be defined as follows:
%% =======================================================================
\small
\begin{verbatim}
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  pred lemma1 : SetOfResource SetOfProperty
  eq lemma1(SetRS,SetPR) =
    allRSInStates(SetRS,initial) implies
    ifRSInStatesThenPRInStates(SetRS,started,SetPR,ready) .
\end{verbatim}
\normalsize
%% =======================================================================
Although this lemma may be intuitively true, a typical pitfall of
developing proof scores is regarding some lemma as intuitive and
skipping to prove it, which often results in leaving critical errors
in specifications. However, recalling that we get {\tt allRSInStates}
by renaming {\tt allObjInStates} and similarly
{\tt ifRSInStatesThenPRInStates} by renaming\\
{\tt ifXInStatesThenZInStates}, this lemma can be obtained by renaming {\tt
  m2o-lemma07} as follows:
%% =======================================================================
\small
\begin{verbatim}
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  pred m2o-lemma07-renamed : SetOfResource SetOfProperty
  eq m2o-lemma07-renamed(SetRS,SetPR)
     = allRSInStates(SetRS,initial) implies 
       ifRSInStatesThenPRInStates(SetRS,started,SetPR,ready)
     when not (initial \in started) .
\end{verbatim}
\normalsize
%% =======================================================================
Since \stt{not (initial $\backslash$in started)} is true, the {\tt
  when} clause can be omitted. This is why we use {\tt when} instead
of {\tt implies} assuming it will be omitted when renamed. Using the
Implication Lemma, this lemma can be define as follows:
%% =======================================================================
\small
\begin{verbatim}
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  eq [m2o-lemma07]:
     (allRSInStates(SetRS,initial) and
      ifRSInStatesThenPRInStates(SetRS,started,SetPR,ready))
    = allRSInStates(SetRS,initial) .
\end{verbatim}
\normalsize
%% =======================================================================

\begin{lemma}[Many-2-One Lemma 11]
  Let {\tt S\_X} be a set of linking objects, {\tt S\_Z} a set of
  linked objects, {\tt St\_X} a set of local states of linking
  objects, {\tt St\_Z} a set of local states of linked objects, and
  {\tt Z} and {\tt Z'} linked objects where {\tt Z} and {\tt Z'}
  are identical (i.e.\ whose identifiers, links, and types are the
  same) and only their local states are different\footnote{Exactly
    speaking, {\tt Z} and {\tt Z'} are terms of \cafeobj representing
    when the same object in the model is in the different local
    states.}.  Then, if the local state of {\tt Z'} is included in
  {\tt St\_Z}, \stt{ifXInStatesThenZInStates(S\_X,St\_X,(Z S\_Z),St\_Z)}
  implies\\ \stt{ifXInStatesThenZInStates(S\_X,St\_X,(Z' S\_Z),St\_Z)}.
\end{lemma}
This lemma is represented in \cafeobj as follows:
%% =======================================================================
\small
\begin{verbatim}
  vars O1 O2 : Object
  pred changeObjState : Object Object
  eq changeObjState(O1,O2)
     = (id(O1) = id(O2)) and 
       (link(O1) = link(O2)) and
       (type(O1) = type(O2)) .

  vars Z Z' : Object
  var S_X : SetOfLObject
  var S_Z : SetOfObject
  var St_X : SetOfLObjState
  var St_Z : SetOfObjState
  pred m2o-lemma11 : Object Object SetOfLObject SetOfLObjState
                                   SetOfObject SetOfObjState
  eq m2o-lemma11(Z,Z',S_X,St_X,S_Z,St_Z)
     = ifXInStatesThenZInStates(S_X,St_X,(Z S_Z),St_Z) implies
       ifXInStatesThenZInStates(S_X,St_X,(Z' S_Z),St_Z) 
     when (state(Z') \in St_Z) and changeObjState(Z,Z') .
\end{verbatim}
\normalsize
%% =======================================================================
In order to show the invariant property of {\tt
  inv-ifRSStartedThenPRReady} above, we also need another lemma which
says that {\tt inv-ifRSStartedThenPRReady} keeps to hold when rule
{\tt R02} is applied and makes a property transit from {\tt notready}
to {\tt ready}.  The lemma could be defined as follows:
%% =======================================================================
\small
\begin{verbatim}
  vars IDRS IDRRS : RSID 
  var IDPR : PRID
  var TPR : PRType
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  pred lemma2 : SetOfResource PRType PRID RSID RSID SetOfProperty
  eq lemma2(SetRS,TPR,IDPR,IDRS,IDRRS,SetPR)
    = ifRSInStatesThenPRInStates
      (SetRS,started,(prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR),ready)
    implies
      ifRSInStatesThenPRInStates
      (SetRS,started,(prop(TPR,IDPR,   ready,IDRS,IDRRS) SetPR),ready) .
\end{verbatim}
\normalsize
%% =======================================================================
Again this lemma may be intuitively true because its antecedent part
requires that some properties should be {\tt ready} and one specific
property with identifier {\tt IDPR} changes its local state from {\tt
  notready} to {\tt ready}. And again this lemma can also be obtained by
renaming {\tt m2o-lemma11} as follows:
%% =======================================================================
\small
\begin{verbatim}
  vars IDRS IDRRS : RSID 
  var IDPR : PRID
  var TPR : PRType
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  pred m2o-lemma11-renamed : SetOfResource PRType PRID 
                             RSID RSID SetOfProperty
  eq m2o-lemma11-renamed(SetRS,TPR,IDPR,IDRS,IDRRS,SetPR) =
    = ifRSInStatesThenPRInStates
      (SetRS,started,(prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR),ready)
    implies
      ifRSInStatesThenPRInStates
      (SetRS,started,(prop(TPR,IDPR,   ready,IDRS,IDRRS) SetPR),ready)
     when (state(prop(TPR,IDPR,ready,IDRS,IDRRS)) \in ready) and 
          changeObjState(prop(TPR,IDPR,notready,IDRS,IDRRS),
                         prop(TPR,IDPR,   ready,IDRS,IDRRS)) .
\end{verbatim}
\normalsize
%% =======================================================================
The {\tt when} clause reduces to true and can be omitted. Using the
Implication Lemma, this lemma can be define as follows:
%% =======================================================================
\small
\begin{verbatim}
  vars IDRS IDRRS : RSID 
  var IDPR : PRID
  var TPR : PRType
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  eq [m2o-lemma11]:
     (ifRSInStatesThenPRInStates
      (SetRS,started,(prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR),ready)
     and
      ifRSInStatesThenPRInStates
      (SetRS,started,(prop(TPR,IDPR,   ready,IDRS,IDRRS) SetPR),ready))
     = 
      ifRSInStatesThenPRInStates
      (SetRS,started,(prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR),ready) .
\end{verbatim}
\normalsize
%% =======================================================================

%% ===============================================================
\subsection{Cyclic Dependency Lemma}
\label{sec:cyclelemma}
%% ===============================================================
A rule typically produces dependency of objects.  For example, rule
{\tt R01} in Section~\ref{sec:behaviormodel} makes {\tt myEIP} transit
from {\tt initial} to {\tt started} when its property {\tt
  myEIP::InsID} is {\tt ready}, which means {\tt myEIP} depends on
{\tt myEIP::InsID}.  Similarly, rule {\tt R02} makes property {\tt
  myEIP::InsID} depend on its referring resource {\tt myInstance}.

If such dependency is cyclic it should be troublesome because there
may be a situation where each of objects in the cycle is waiting for
its dependent object and no rule is applicable to any of them. Such
situation is called a deadlock.  For example, if {\tt myInstance} had
a property referring {\tt myEIP}, then these two resources would be
mutually dependent and no transition rule could be applied.

In order to start transitions and reach a desired final state, a cloud
system should not include such cyclic dependency. Verification of the
system requires (1) to formalize that the dependency is acyclic, (2)
to prove the invariant property of the acyclicness, and (3) to prove
that when acyclic there exists at least one applicable transition rule
and the state machine continues to transit. The framework provides a
template module to formalize acyclicness of dependency for (1) and a
lemma that guarantees existence of applicable rules for (3). It also
provides several common techniques and proved lemmas for (2).

%% ===============================================================
\subsubsection{Formalization of Dependency and Acyclicness}
%% ===============================================================
This section will describe a formal definition of cyclic dependency
and show examples using the CloudFormation example case shown in
Fig.~\ref{fig:AWSExample} and transition rules {\tt R01} and {\tt R02}
in Section~\ref{sec:behaviormodel}.

\begin{notation}[$X \in C$]
Let $C$ be a class of objects in a cloud system, and let $X$ be an object
the system consisting of, then we denote \ul{$X \in C$} when $X$ is of
$C$.
\end{notation}

\begin{notation}[$st(X,S)$]
Let $S$ be a global state of a cloud system, and let $X$ be an object in
$S$\!, then \ul{$st(X,S)$} is the local state of $X$ in the context of
$S$\!.
\end{notation}

\begin{definition}[can make an object transit]
Let $R = [l,r,c]$ be a transition rule, $C$ a class of objects, $S$
a global state, and $X$ an object of $C$. We say \ul{$R$ can
  make $X$ transit in $S$} iff there exists a ground substitution
$\sigma$ such that $S = l\sigma$, $c\sigma$ reduces to true, and
$st(X,l\sigma) \ne st(X,r\sigma)$. We also say \ul{$R$ can make $X$
  transit from $st(X,l\sigma)$ to $st(X,r\sigma)$ in $S$}\!.  Let $s$
and $s'$ be local states of $C$, then we say \ul{$R$ can make an object
  of $C$ transit form $s$ to $s'$} iff there exists a global state $S$
such that $R$ can make an object of $C$ transit form $s$ to $s'$ in $S$\!.
\end{definition}

\begin{definition}[pre-transit local states]
Let $R$ be a transition rule, and $C$ a class of objects, then
the \ul{pre-transit local states of $R$ for $C$}, denoted
\ul{$prels(R,C)$}, is the set of local states of $C$ where $s \in
prels(R,C)$ iff there exists some local state $s'$ of $C$ such that
$R$ can make an object of $C$ transit from $s$ to $s'$.
\end{definition}
For example, if $st(\mbstt{myInstance},S)$ is {\it initial} then
\stt{R01} can make \stt{myInstance} transit from {\it initial} to {\it
  started} in $S$ and thus $prels(\mbstt{R01},\mbstt{Resource})$ is
$\{~\mbstt{initial}~\}$. Note that a transition rule can make objects
of more than one classes transit.

\begin{notation}($S[X/s]$)\
Let $S$ be a global state, $C$ a class of objects, $X$ an object
of $C$ in $S$\!, and $s$ a local state of $C$, then
\ul{$S[X/s]$} is the global state such that:
\begin{itemize}
\item $S[X/s]$ consists of the identical objects (i.e.\ identifiers and
  types are the same) as $S$\!,
\item each link of objects in $S[X/s]$ is the same as $S$\!, and
\item $st(X,S[X/s])=s$ and $\forall X'\ne X:st(X',S[X/s])=st(X',S)$.
\end{itemize}
This notation can specify more than one objects such that
\ul{$S[X_1/s_1,X_2/s_2,\dots]$}.  Let $\Sigma$ be a set of pairs of
an object and a local state, $\Sigma = \{~ (X_1,s_1), (X_2,s_2), \dots~\}$,
then we denote \ul{$S[\Sigma]$} as $S[X_1/s_1,X_2/s_2,\dots]$.
\end{notation}
Let $\mathit{S_0}$ be the following global state:
%% =======================================================================
\small
\begin{verbatim}
  < ( res(ec2Instance, myInstance, initial)
      res(ec2Eip, myEIP, initial) ),
    ( prop(instanceId, myEIP::InsID, notready, myEIP, myInstance) ) >
\end{verbatim}
\normalsize
%% =======================================================================
Let us denote an object by its identifier and let $\Sigma_0$ be a set
of pairs of an object and a local state such that $\Sigma_0=\{$
$(\mbstt{myInstance,started}),$ $(\mbstt{myEIP::InsID,ready})\}$, then
$\mathit{S_0}[\Sigma_0]$ is the following global state:
%% =======================================================================
\small
\begin{verbatim}
  < ( res(ec2Instance, myInstance, started)
      res(ec2Eip, myEIP, initial) ),
    ( prop(instanceId, myEIP::InsID, ready, myEIP, myInstance) ) >
\end{verbatim}
\normalsize
%% =======================================================================

\begin{definition}[depends on]
Let $S$ be a global state, $X$ and $X'$ objects in $S$\!, and $R$
a transition rule where $R$ cannot make $X$ transit in $S$\!.  We say
\ul{$X$ depends on $X'$ in $S$ w.r.t.\ $R$}, denoted \ul{$\mathit{dep}_R(X,
  X',S)$}, iff there exists a set $\Sigma$ of pairs of an object and a
local state such that $\Sigma$ includes a pair whose first element is
$X'$, $R$ can make $X$ transit in $S[\Sigma]$, and $\Sigma$ is
minimal.  Here we say ``minimal'' which means that there exists no
subset $\Sigma'$ of $\Sigma$ such that $R$ can make $X$ transit in
$S[\Sigma']$. We also say \ul{$X$ depends on $X'$ in $S$}\!, denoted
\ul{$\mathit{dep}(X, X',S)$}, when there exists some transition rule $R$ such
that $\mathit{dep}_R(X,X',S)$.
\end{definition}
For example, rule {\tt R01} can make {\tt myEIP} transit from {\tt
  initial} to {\tt started} in $\mathit{S_0}[\Sigma_0]$, however, there is a
subset of $\Sigma_0$ such that
$\Sigma_{R01}=\{\mbstt{(myEIP:InsID,ready)}\}$ where rule {\tt R01}
can make {\tt myEIP} transit also in $\mathit{S_0}[\Sigma_{R01}]$. Thereby, {\tt
  myEIP} depends only on {\tt myEIP:InsID} but not on {\tt myInstance}
in $\mathit{S_0}$ w.r.t.\ {\tt R01}. Similarly, when
$\Sigma_{R02}=\{(\mbstt{myInstance,started})\}$, rule {\tt R02} can
make {\tt myEIP::InsID} transit from {\tt notready} to {\tt ready} in
$\mathit{S_0}[\Sigma_{R02}]$ and thus {\tt myEIP::InsID} depends on {\tt
  myInstance} in $\mathit{S_0}$ w.r.t.\ {\tt R02}.

\begin{definition}[depending set]
Let $X$ be an object, $R$ a transition rule, and $S$ a global
state, then the \ul{depending set of $X$ in $S$}\!, denoted
\ul{$DS(X,S)$}, is recursively defined as (1) if $X$ depends on some
other object $X'$ in $S$ then $X'$ is included in
$DS(X,S)$, i.e.\ $\forall X': (\mathit{dep}(X,X',S) \ra X'\in DS(X,S))$, and
(2) if $X' \in DS(X,S)$ and $X'$ depends on some other object $X''$
in $S$ then $X''$ is included in $DS(X,S)$, i.e.\ $\forall
X',X'': (X'\in DS(X,S) \land \mathit{dep}(X',X'',S) \ra X''\in DS(X,S))$.
\end{definition}

\begin{definition}[no cyclic dependency]
Let $C$ be a class, $X$ an object of $C$, and $S$ a global
state. We say \ul{$X$ is in no cyclic dependency in $S$}\!, denoted
\ul{$noCycle(X,S)$}, iff $X$ itself is not included in $DS(X,S)$. We
also say \ul{there is no cyclic dependency of $C$ in $S$}\!, denoted
\ul{$noCycle_C(S)$}, iff all of the objects of $C$ in $S$ are in no cyclic
dependency in $S$\!.
\end{definition}
For example, $DS(\mbstt{myEIP},\mathit{S_0}) =
\{~\mbstt{myEIP::InsID},\mbstt{myInstance}~\}$ because {\tt myEIP}
depends on\\ \stt{myEIP::InsID} in $\mathit{S_0}$ w.r.t.\ {\tt R01} and
\stt{myEIP::InsID} depends on {\tt myInstance} in $\mathit{S_0}$ w.r.t.\ {\tt
  R02}. Since the depending set of {\tt myEIP} does not include {\tt
  myEIP} itself, {\tt myEIP} is in no cyclic dependency in $\mathit{S_0}$, and
there is no cyclic dependency of {\tt Resource} in $\mathit{S_0}$.
\begin{lemma}[Cyclic Dependency Lemma]
Let $S$ be a global state, $R$ a transition rule, and $C$ a
class of objects. If there is no cyclic dependency of $C$ in $S$
and there exists some object $X$ of $C$ in $S$ whose local state
is included in $prels(R,C)$, then there exists some object $O$ of $C$ in
$S$ such that the local state of $O$ is included in $prels(R,C)$ and the
depending set of $O$ includes no object of $C$ whose local
state is included in $prels(R,C)$, i.e.:
\begin{eqnarray*}
&&noCycle_C(S)\land\exists X\in C:(st(X,S)\in prels(R,C)) \ra\\
&&\:\:\:\:\:\:\:\:\:\exists O\in C:(st(O,S)\in prels(R,C)\ \land\\
&&\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\forall O'\in C:(O'\in DS(O,S)\ra st(O',S)\not\in prels(R,C)))
\end{eqnarray*}
\end{lemma}
Proof: Let $C^R$ be a set of objects of $C$ in $S$ whose local states
are included in $prels(R,C)$, i.e.\ $C^R=\{~O\mid O\in C~\land~
st(O,S)\in prels(R,C)~\}$. $C^R$ is not empty because it includes $X$.
If every object $O$ in $C^R$ has at least one object $O' \in C^R\cap
DS(O,S)$ then there should be some object $O$ in $C^R$ such that $O
\in DS(O,S)$ because $DS$ is transitive and $C^R$ is finite. However,
it means there is cyclic dependency of $C$ in $S$\!. $\Box$\\

\noindent
For example, let $\mathit{S_0}$ be a global state shown above, then there is no
cyclic dependency of {\tt Resource} in $\mathit{S_0}$ and there exists {\tt
  myEIP} whose local state is {\it initial}. Thereby, the Cyclic
Dependency Lemma ensures that there exists a {\tt Resource} object
whose local state is {\it initial} and whose depending set includes no
initial {\tt Resource} objects, which is {\tt myInstance}.

%% ===============================================================
\subsubsection{Focusing on One Class}
%% ===============================================================
When using the Cyclic Dependency Lemma, we can usually focus on one
class of objects. In the CloudFormation example case, we can focus on
{\tt Resource} objects and not on {\tt Property} objects; we should
consider no cyclic dependency of only {\tt Resource} objects and
existence of a {\tt Resource} object whose local state is in
$prels(\mbstt{R01,Resource})$, i.e.\ is {\tt initial}. The following
is a modified version of the formalization focusing on one class.

\begin{definition}[depending set of the same class as]
Let $C$ be a class , $X$ an object of $C$, $R$ a transition
rule, and $S$ a global state, then the \ul{depending set of the same
class as $X$ in $S$}\!, denoted \ul{$\mathit{DS_C}(X,S)$}, is defined
as $\mathit{DS_C}(X,S)=\{~X'\in C\mid X'\in DS(X,S)~\}$
\end{definition}
\begin{lemma}
Let $C$ be a class, $X$ an object of $C$, and $S$ a global
state. If $X$ itself is not included in $\mathit{DS_C}(X,S)$, then $X$ is in no
cyclic dependency of $C$ in $S$\!.
\end{lemma}
\begin{corollary}
Let $S$ be a global state, $R$ a transition rule, and $C$ a
class of objects. If there is no cyclic dependency of $C$ in $S$ and
there exists some object $X$ of $C$ in $S$ whose local state is
included in $prels(R,C)$, then there exists some object $O$ of $C$ in
$S$ such that the local state of $O$ is included in $prels(R,C)$ and
$\mathit{DS_C}(O,S)$ includes no object whose local state is included in
$prels(R,C)$; typically $\mathit{DS_C}(O,S)$ is empty.
\end{corollary}
\begin{definition}[dependency chain]
Let $X_1, X_2, \dots,X_n$ be objects, and $S$ a global state, then the
\ul{dependency chain} in $S$\!, denoted \ul{$dc([X_1, X_2,\dots,
    X_n],S)$}, is defined as $\forall i \in \{1 \dots n-1\} : \mathit{dep}(X_i,
X_{i+1},S)$.
\end{definition}
For example, since {\tt myEIP} depends on {\tt myEIP::InsID} and it in
turn depends on {\tt myInstance} in $\mathit{S_0}$, there is a dependency chain
in $\mathit{S_0}$, $dc([\mbstt{myEIP,myEIP::InsID,myInstance}],\mathit{S_0})$.

\begin{definition}[directly depending set of the same class as]
Let $C$ be a class of objects, $X$ an object of $C$, and $S$ a
global state. The \ul{directly depending set of the same class as $X$
  in $S$}\!, denoted \ul{$\mathit{DDS_C}(X,S)$}, is defined as $\{~X'\mid\exists
dc([X,X_1,\dots,X_n,X'],S)\land X' \in C\land\forall i\in [1 \dots
  n]:X_i \not\in C~\}$. We also say \ul{$X$ directly depends on $X'$
  in $S$} when $X'\in \mathit{DDS_c}(X,S)$.
\end{definition}
When $X$ and $X'$ are objects of $C$, $X' \in \mathit{DDS_C}(X)$ means that
there exists a dependency chain in which the first object is $X$, the
last object is $X'$, and every object between $X$ and $X'$ is not of
$C$. For example, $\mathit{DDS_C}(\mbstt{myEIP},\mathit{S_0})$ $=\{~\mbstt{myInstance}~\}$
since there is a dependency chain
$dc([\mbstt{myEIP,myEIP::InsID,myInstance}],\mathit{S_0})$.

\begin{corollary}
Let $S$ be a global state, $R$ a transition rule, and $C$ a
class of objects. If there is no cyclic dependency of $C$ in $S$ and
there exists some object $X$ of $C$ in $S$ whose local state is
included in $prels(R,C)$, then there exists some object $O$ of $C$ in
$S$ such that the local state of $O$ is included in $prels(R,C)$ and
$\mathit{DDS_C}(O,S)$ includes no object whose local state is included in
$prels(R,C)$; typically $\mathit{DDS_C}(O,S)$ is empty.
\end{corollary}
%% ===============================================================
\subsubsection{Using a Template Module to Represent $noCycle_C$}
%% ===============================================================
Using the formalization of cyclic dependency explained above, the
framework provides a predicate, \stt{noCycle($S$)}, which checks there
is no cyclic dependency in the given global state $S$\!. Predicate {\tt
  noCycle} is defined by a template module, {\tt CYCLEPRED} and a
parameter module, {\tt PRMCYCLE}:
%% =======================================================================
\small
\begin{verbatim}
  module* PRMCYCLE {
    [Object < SetOfObject]
    op empObj : -> SetOfObject
    op _ _ : SetOfObject SetOfObject -> SetOfObject
    op _\in_ : Object SetOfObject -> Bool
  
    [State]
    op getAllObjInState : State -> SetOfObject
    op DDSC : Object State -> SetOfObject
  }

  module! CYCLEPRED(P :: PRMCYCLE) {
    var O  : Object
    vars V OS : SetOfObject
    var S : State
  
    pred noCycle : State
    pred noCycle : Object State
    pred noCycle : SetOfObject SetOfObject State
  
    eq noCycle(S)
       = noCycle(getAllObjInState(S),empObj,S) .
  
    eq noCycle(O,S)
       = noCycle(O,empObj,S) .
  
    eq noCycle(empObj,V,S)
       = true .
    eq noCycle((O OS),V,S)
       = if O \in V then false else noCycle(DDSC(O,S),(O V),S) fi
         and noCycle(OS,V,S) .
  }
\end{verbatim}
\normalsize
%% =======================================================================
Parameter module {\tt PRMCYCLE} requires five operator parameters
three of which can be defined just by using template module {\tt
  OBJECTBASE}.
The user of the framework should appropriately define {\tt
  getAllObjInState} and {\tt DDSC} because they are specific to each
problem. 
Given a global state {\tt S}, operator \stt{getAllObjInState(S)} should return
the set of all the objects of the specific class we focus; that is the
resource class in the CloudFormation example case. Operator
\stt{DDSC(O,S)} should return the directly depending set of the same class
as the given object {\tt O} in the given global state {\tt S}.

Using these operators, template module {\tt CYCLEPRED} defines predicate
{\tt noCylce}. Given
a global state {\tt S}, predicate \stt{noCycle(S)} transitively visits objects in
directly depending sets \stt{DDSC(O,S)} and checks not to find any
objects already visited.

In the CloudFormation example case, {\tt getAllObjInState} and {\tt DDSC} can be defined as
follows:
%% =======================================================================
\small
\begin{verbatim}
  module! STATECyclefuns {
    protecting(STATE)
  
    var RS : Resource
    var SetRS : SetOfResource
    var SetPR : SetOfProperty
  
    op getAllRSInState : State -> SetOfResource
    eq getAllRSInState(< SetRS,SetPR >) = SetRS .
  
    op DDSC : Resource State -> SetOfResource
    eq DDSC(RS,< SetRS,SetPR >)
      = if state(RS) = initial then
           getRRSsOfPRsInStates(SetRS,
                                getPRsOfRSInStates(SetPR,RS,notready),
                                initial)
        else empRS fi .
  }
\end{verbatim}
\normalsize
%% =======================================================================
Remember that rule {\tt R01} can make an {\tt initial} resource
transit when all of its properties are {\tt ready} and that rule {\tt
  R02} can make a {\tt notready} property when its parent is {\tt
  started}. As explained in Section~\ref{sec:linkpred},
\stt{getPRsOfRSInStates(SetPR,RS,notready)} returns a set of
properties which are included in the set {\tt SetPR} of properties,
whose parents are the resource {\tt RS}, and whose local states are
{\tt notready}. And \stt{getRRSsOfPRsInStates(SetRS,$setPR$,initial)}
returns a set of resources which are included in the set
{\tt SetRS} of resources, which are referred by one of the properties in the set $setPR$,
and whose local states are {\tt initial}. Thereby, $\mathit{DDS_C}(X,S)$ can be
defined by combining these operators.

Using {\tt getAllRSInState} and {\tt DDSC} as parameters template
module {\tt CYCLEPRED} can be instantiated as follows:
%% =======================================================================
\small
\begin{verbatim}
  extending(CYCLEPRED(
        STATECyclefuns {sort Object -> Resource,
                        sort SetOfObject -> SetOfResource,
                        op empObj -> empRS,
                        op getAllObjInState -> getAllRSInState})
        * {op noCycle -> noRSCycle}
        )
\end{verbatim}
\normalsize
%% =======================================================================
 {\tt Resource}, {\tt SetOfResource}, {\tt empRS}, and {\tt
   getAllRSInState} are specified as actual parameters where {\tt
   DDSC} is not specified because the name is the same as the formal
 parameter.  {\tt noCycle} is renamed as {\tt noRSCycle}.

%% ===============================================================
\subsubsection{Lemmas for Proving the Invariant Property of Acyclicness}
%% ===============================================================
In order to use the Cyclic Dependency Lemma, the user of the framework
should prove the invariant property of $noCycle_C$, especially should
prove that $noCycle_c(S) \ra noCycle_C(S')$ for any global state $S$
and any possible next state $S'$ of $S$\!. Although such proof is
specific to each problem, there are several common techniques and the
framework provides several proved lemmas for them.

It is often the case where a transition rule decreases dependencies
between objects when it is applied. For example, when rule {\tt R01}
is applied to a global state, it makes a resource object transit from
{\tt initial} to {\tt started}. If the resource object is referred by
some {\tt notready} property object, then the property depends on the
resource in the global state w.r.t.\ {\tt R02} and does not depend on it in the
next state. Similarly, when rule {\tt R02} is applied, it makes a
property object transit from {\tt notready} to {\tt ready} and the
dependency between the property and its parent resource disappears.
Thereby, when these rules are applied, the depending sets will become
smaller than in the previous global states.

\begin{lemma}[Depending Subset Lemma]
Let $S$ and $S'$ be global states, then if $DS(X,S')$ $\subseteq DS(X,S)$ for all
objects $X$ in $S$\!, then $noCycle(S) \ra noCycle(S')$.
\end{lemma}
Proof: $noCycle(S)$ means that $X\not\in DS(X,S)$ for any $X$ in $S$\!,
which implies that $X\not\in DS(X,S')$ because $DS(X,S')\subseteq
DS(X,S)$.  $\Box$

\begin{corollary}
Let $C$ be a class of objects and let $S$ and $S'$ be global states.  If
$\mathit{DS_C}(X,S')\subseteq \mathit{DS_C}(X,S)$ for all objects $X$ of $C$ in $S$\!,
then $noCycle_C(S) \ra noCycle_C(S')$.
\end{corollary}

\begin{corollary}
Let $C$ be a class of objects and let $S$ and $S'$ be global states.  If
$\mathit{DDS_C}(X,S')\subseteq \mathit{DDS_C}(X,S)$ for all objects $X$ of $C$ in $S$\!,
then $noCycle_C(S) \ra noCycle_C(S')$.
\end{corollary}

\begin{lemma}[Many-2-One Lemma 24]
  Let {\tt S\_X} be a set of linking objects, {\tt S\_Z} a set of
  linked objects, {\tt St\_X} a set of local states of linking
  objects, and let {\tt X} and {\tt X'} be linking objects where {\tt X}
  and {\tt X'} are identical and only their local states are different
  Then, if the local state of {\tt X'} is not included in {\tt St\_X},
  \stt{getXsOfZsInStates((X' S\_X),S\_Z,St\_X)} is a subset of or equal to
  \stt{getXsOfZsInStates((X S\_X),S\_Z,St\_X))}.
\end{lemma}
This Many-2-One Lemma 24 is represented in \cafeobj as follows:
%% =======================================================================
\small
\begin{verbatim}
  vars X X' : LObject
  var S_X : SetOfLObject
  var S_Z : SetOfObject
  var St_X : SetOfLObjState
  pred m2o-lemma24 : LObject LObject SetOfLObject
                     SetOfObject SetOfLObjState .
  eq m2o-lemma24(X,X',S_X,S_Z,St_X)
     = subset(getXsOfZsInStates((X' S_X),S_Z,St_X),
              getXsOfZsInStates((X  S_X),S_Z,St_X))
     when id(X) = id(X') and not state(X') \in St_X .
\end{verbatim}
\normalsize
%% =======================================================================
In the CloudFormation example case, in order to show the invariant
property of {\tt noRSCycle}, the corollary of the Depending Subset
Lemma ensures that we should only prove that {\tt DDSC} becomes a
subset of itself when rule {\tt R01} or {\tt R02} is applied. It then
requires another lemma which says that {\tt getRRSsOfPRsInStates}
becomes a subset of itself when rule {\tt R01} is applied and makes a
resource transit from {\tt initial} to {\tt started}.  The lemma could
be defined as follows:
%% =======================================================================
\small
\begin{verbatim}
  var IDRS : RSID 
  var TRS : RSType
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  pred lemma3 : RSType RSID SetOfResource SetOfProperty
  eq lemma3(TRS,IDRS,SetRS,SetPR)
    = subset(getRRSsOfPRsInStates((res(TRS,IDRS,started) SetRS),
                                  SetPR,initial), 
             getRRSsOfPRsInStates((res(TRS,IDRS,initial) SetRS),
                                  SetPR,initial) .
\end{verbatim}
\normalsize
%% =======================================================================
As explained in Section~\ref{sec:linkpred}, {\tt getRRSsOfPRsInStates}
is renamed from {\tt getXsOfZsInStates} and thus this lemma can be obtained
by renaming {\tt m2o-lemma24} as follows:
%% =======================================================================
\small
\begin{verbatim}
  vars RS RS' : Resource
  var SetRS : SetOfResource
  var SetSRS : SetOfRSState
  var SetPR : SetOfProperty
  ceq [m2o-lemma24]:
    subset(getRRSsOfPRsInStates((RS' SetRS),SetPR,SetSRS),
           getRRSsOfPRsInStates((RS  SetRS),SetPR,SetSRS))
    = true
    if id(RS) = id(RS') and not state(RS') \in SetSRS .
\end{verbatim}
\normalsize
%% =======================================================================

In the other cases, systems are intentionally designed to have some constraints
to avoid cyclic dependencies. For example, if a system is constrained to
have no cyclic chains of links of objects, then there should be no
cyclic dependency in the system no matter how the local states of the
objects transit. Since the purpose of such constraints is to simplify
complicated controls of dependencies of objects, it is typically easier
to check the constraints than to use $noCycle$ defined above.

\begin{notation}[$rel(X,X',S)$]
  Let $S$ be a global state, and let $X$ and $X'$ be objects in $S$\!.  When
  there is some relationship $r$ between $X$ and $X'$, we denote it
  as \ul{$r(X,X',S)$}. Note that ``$X$ depends on $X'$ in $S$'' is one
  of such relationships.
\end{notation}

\begin{definition}[directly relating set]
Let $S$ be a global state, $X$ an object in $S$\!, and $r$ a
relationship of objects. Then, the \ul{directly relating set of $X$ in
  $S$ w.r.t.\ $r$}, denoted \ul{$\mathit{DRS_r}(X,S)$}, is defined as
$\mathit{DRS_r}(X,S)=\{~X'\mid r(X,X',S)~\}$.
\end{definition}

\begin{definition}[relating set]
Let $X$ be an object, $S$ a global state, and $r$ a relationship
of objects, then the \ul{relating set of $X$ in $S$
  w.r.t.\ $r$}, denoted \ul{$\mathit{RS_r}(X,S)$}, is recursively defined
as (1) $\forall X': (r(X,X',S) \ra X'\in \mathit{RS_r}(X,S))$, and (2)
$\forall X',X'': (X'\in \mathit{RS_r}(X,S) \land r(X',X'',S) \ra X''\in
\mathit{RS_r}(X,S))$.
\end{definition}

\begin{definition}[no cyclic relationship]
Let $X$ be an object, $S$ a global state, and $r$ a relationship
of objects, then we say \ul{$X$ is in no cyclic relationship in $S$
  w.r.t.\ $r$}, denoted \ul{$noCycle_r(X,S)$}, iff $X$ itself is not
included in $\mathit{RS_r}(X,S)$.
\end{definition}

\begin{lemma}
\label{lemma:simplerel}
Let $C$ is a class, $X$ an object of $C$, $S$ a global state,
and $r$ a relationship of objects. If $\mathit{DDS_c}(X,S)$ is a subset of
$\mathit{DRS_R}(X,S)$ for all $X$ in $S$\!, then $noCycle_r(X,S)$ implies
$noCycle_c(X,S)$ for all $X$, i.e.:
\[\forall X:\mathit{DDS_c}(X,S)\subseteq \mathit{DRS_r}(X,S) \ra \forall X: (noCycle_r(X,S) \ra
noCycle_C(X,S))\]
\end{lemma}
Proof: $\mathit{DDS_c}(X,S)\subseteq \mathit{DRS_r}(X,S)$ means that $\mathit{DS_c}(X,S)\subseteq
\mathit{RS_r}(X,S)$.  Thereby, if $noCycle_c(X,S)$ does not holds, then $X\in
\mathit{DS_C}(X,S)$ and $X\in \mathit{RS_r}(X,S)$, which is a contradiction. $\Box$\\

This lemma allows the user of the framework to define {\tt DDSC}
implementing some simpler relationship $r$ instead of the true $\mathit{DDS_C}$
and use {\tt noCycle} defined by using the {\tt DDSC} instead of the true
$noCycle_c$. For example, when we adopt the constraint of no cyclic
chains of links in the CloudFormation example case, {\tt DDSC} can be
simply defined as follows:
%% =======================================================================
\small
\begin{verbatim}
  var RS : Resource
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  eq DDSC(RS,< SetRS,SetPR >)
    = getRRSsOfPRs(SetRS,getPRsOfRS(SetPR,RS)) .
\end{verbatim}
\normalsize
%% =======================================================================
However {\tt noCycle} defined by using the simpler {\tt DDSC} above is
 not the true $noCycle_C$, we can use the Cyclic Dependency Lemma if
 we can prove the invariant property of {\tt noCycle}.

%% ===============================================================
\chapter{Verification Procedure of Leads-to Properties}
\label{chap:verification}
%% ===============================================================
The framework provides an overall verification procedure for a kind of
liveness properties, {\it leads-to} properties adopted from UNITY
logic~\cite{DBLP:books/daglib/0067338}, as well as invariant
properties.  The procedure assists the users of the framework to
systematically think and develop proof scores for verification of
cloud orchestration.

A typical property of an automated system setup operation, which we
want to verify, is that the operation surely brings a cloud system to
a global state where all of its resources are started.  We say ``surely''
to mean that the system always reaches some final state from any
initial states. This kind of reachability is one of the most important
properties of practical automation of cloud systems.

Futatsugi~\cite{Futatsugi15} defines leads-to property based on
transition sequences of state machines and proposes a set
of sufficient conditions for it as follows:
\begin{definition}[$p~\mbstt{leads-to}~q$]
\label{def:leadsto}
  Let $TS=(\mathit{St},\mathit{Tr},In)$ be a state machine, $p$ and $q$ predicates of
  $\mathit{St}$, $\mathit{St}^R\subseteq \mathit{St}$ the set of reachable states of $TS$, and
  $\Theta$ the set of transition sequences of $TS$, then
  \ul{$p~\mbstt{leads-to}~q$} defined as follows:
  \begin{eqnarray*}
  \forall S\alpha\in \Theta: (S\in \mathit{St}^R \land p(S) \land
  \forall S'\in S\alpha: \neg q(S')\\
  \ra \exists T\in \mathit{St}, \exists\beta\in\Theta:(q(T) \land S\alpha\beta T\in \Theta))
  \end{eqnarray*}
\end{definition}

\begin{lemma}
\label{def:p0leadstoq}
  Let $p_0$, $p$, and $q$ be predicates of $\mathit{St}$:
  $(p_0 \ra p) \land (p~\mbstt{leads-to}~q) \ra
  p_0~\mbstt{leads-to}~q$.
\end{lemma}

\begin{lemma}[sufficient conditions for leads-to]
\label{def:sufcond}
  Let $TS=(\mathit{St},\mathit{Tr},In)$ be a state machine, $p$ and $q$ predicates of
  $\mathit{St}$, $inv$ an invariant of $TS$, and $m$ a natural number
  function of $\mathit{St}$, then the following four conditions are sufficient
  for ($p~\mbstt{leads-to}~q$) to hold.
\begin{eqnarray*}
\forall (S,S')\in \mathit{Tr}:&&((inv(S)\land p(S)\land\neg q(S))\ra(p(S')\lor q(S')))\\
\forall (S,S')\in \mathit{Tr}:&&((inv(S)\land p(S)\land\neg q(S))\ra(m(S) > m(S')))\\
\forall S\in \mathit{St}:&&((inv(S)\land p(S)\land\neg q(S))\ra\exists S'\in \mathit{St}:(S,S')\in \mathit{Tr})\\
\forall S\in \mathit{St}:&&((inv(S)\land p(S)\land(m(S) = 0)) \ra q(S))
\end{eqnarray*}
\end{lemma}
Definition~\ref{def:leadsto} of ($p~\mbstt{leads-to}~q$) includes the
case where there is an infinite transition sequence
$\alpha_{\infty}\!=\!(\mathit{S_0},\mathit{S_1},\dots)$ such that predicate $q$ never holds in $\alpha_{\infty}$,
$\forall \mathit{S_i}\!\in\!\alpha_{\infty}\!:\!\neg q(\mathit{S_i})$,
but any prefix of $\alpha_{\infty}$ reaches a state where $q$ holds,
$\forall \alpha_i\!=\!(\mathit{S_0},\dots,\mathit{S_i}),\exists T\!\in\!\mathit{St},
\exists\beta\!\in\!\Theta\!:\!(q(T) \land S\alpha_i\beta T\in \Theta))$.
However, \stt{leads-to} may be
defined in a narrower sense where no such infinite transition sequence
is allowed. Here, we call the former as {\it weak-leads-to} and the
latter as {\it strong-leads-to}. The set of conditions proposed by
Lemma~\ref{def:sufcond} is sufficient to both meanings of leads-to
because the properly decreasing natural number function, $m$, ensures
that transition sequences never become infinite while keeping $q$ not
to hold. In the rest of this dissertation, we mean ($p~\mbstt{leads-to}~q$)
as ($p~\mbstt{strong-leads-to}~q$).

Let the automation of a setup operation be modeled as a state machine
$TS=(\mathit{St},\mathit{Tr},In)$ specified by sort {\tt State} and a set of transition
rules, and let
$Fn\subseteq \mathit{St}$ be a set of expected final states, reachability
we want to verify is formalized as ($init~\mbstt{leads-to}~final$) where
$init$ and $final$ are predicates for a given global state $S$ such
that $init(S)$ holds iff $S \in In$ and $final(S)$ holds iff $S \in
Fn$. 

The lemma~\ref{def:p0leadstoq} ensures that what we should do is to find a state
predicate $p$ such that $(init\ra p)$ and $p$ satisfies the sufficient
conditions for $(p~\mbstt{leads-to}~final)$. However such $p$ is
specific to the individual problem, one of the most typical and
general ones is that $p(S)$ means $S$ has a next state, i.e.\ $S$ will
transit.  When a state machine has such general $p$, it always
continues to transit until it reaches a final state.

\begin{definition}[continuous predicate]
  The \ul{continuous predicate, $cont$}, is the predicate which holds
  iff there exists some next state of a given state.  Let
  $TS=(\mathit{St},\mathit{Tr},In)$ be a state machine, then $\forall S\in \mathit{St}:cont(S)
  ~\mbstt{iff}~ \exists S'\in \mathit{St}:(S,S')\in \mathit{Tr}$.
\end{definition}

\begin{lemma}[sufficient conditions for $init~\mbstt{leads-to}~final$]
  Let $TS=(\mathit{St},\mathit{Tr},In)$ be a state machine, $inv$ a conjunction of
  some state predicates and $m$ a natural number function of $\mathit{St}$,
  then the following six conditions are sufficient for
  ($init~\mbstt{leads-to}~final$) to hold.
  \begin{eqnarray}
  \forall S\in \mathit{St}:&&(init(S)\ra cont(S))\\
  \forall (S,S')\in \mathit{Tr}:&&((inv(S)\land\neg final(S))
  \ra(cont(S')\lor final(S')))\\
  \forall (S,S')\in \mathit{Tr}:&&((inv(S)\land\neg final(S))\ra(m(S)> m(S')))\\
  \forall S\in \mathit{St}:&&((inv(S)\land cont(S)\land(m(S) = 0))\ra final(S))\\
  \forall S\in \mathit{St}:&&(init(S)\ra inv(S))\\
  \forall (S,S')\in \mathit{Tr}:&&(inv(S)\ra inv(S'))
  \end{eqnarray}
\end{lemma}
Proof: Let $p$ in the ``sufficient conditions for leads-to'' lemma
be $cont$, then $\forall (S,S')\in \mathit{Tr}:p(S)=true$ holds and
$\forall S\in \mathit{St}:(p(s)\ra\exists S'\in \mathit{St}:(S,S')\in \mathit{Tr})$. $\Box$\\

Condition~(1) means an initial state should be a
continuing state, i.e.\ it should start
transitions. Condition~(2) means transitions continue
until $final(S')$ holds. Condition~(3) implies that
$m(S)$ keeps to decrease properly while $final(S)$ does not
hold. Since $m(S)$ is a natural number, it should stop to decrease in
finite steps and the state machine should get to state $S'$ such that
$((cont(S')\ \lor\ final(S'))$ $\land\ (m(S') = 0))$.
Condition~(4) then ensures $final(S')$ holds. Here, $m$ is
called a {\it state measuring function}. When
condition~(5) and~(6) hold, each state
predicate included in $inv$ is called an invariant.

The rest of this chapter explains the verification procedure for six
sufficient conditions above using the CloudFormation example case and
the case of TOSCA topologies will be explained in
Chapter~\ref{chap:appTOSCA}.

%% ===============================================================
\section{Procedure: Definition of Predicates}
\label{sec:support}
%% ===============================================================
\noindent{\bf Step 0-1:} Define $init$ and $final$. \\ In the
CloudFormation example case, predicates $init(S)$ and $final(S)$ can
be represented by \cafeobj as follows:
%% =======================================================================
\small
\begin{verbatim}
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  var S : State

  pred init : State
  eq init(< SetRS,SetPR >)
     = wfs(< SetRS,SetPR >) and
       noRSCycle(< SetRS,SetPR >) and
       allRSInStates(SetRS,initial) and 
       allPRInStates(SetPR,notready) .

  pred final : State
  eq final(< SetRS,SetPR >)
     = allRSInStates(SetRS,started) .

  pred wfs : State
  eq wfs(S)
     = wfs-atLeastOneRS(S) and
       wfs-uniqRS(S)       and wfs-uniqPR(S) and 
       wfs-allPRHaveRS(S)  and wfs-allPRHaveRRS(S) .

  pred wfs-atLeastOneRS : State
  eq wfs-atLeastOneRS(< SetRS,SetPR >) = not (SetRS = empRS) .

  pred wfs-uniqRS : State
  eq wfs-uniqRS(< SetRS,SetPR >) = uniqRS(SetRS) .

  pred wfs-uniqPR : State
  eq wfs-uniqPR(< SetRS,SetPR >) = uniqPR(SetPR) .

  pred wfs-allPRHaveRS : State
  eq wfs-allPRHaveRS(< SetRS,SetPR >) = allPRHaveRS(SetPR,SetRS) .

  pred wfs-allPRHaveRRS : State
  eq wfs-allPRHaveRRS(< SetRS,SetPR >) = allPRHaveRRS(SetPR,SetRS) .
\end{verbatim}
\normalsize
%% =======================================================================
Among conditions explicitly composing $init(S)$, one referring to no
local states of objects and being expected to be an invariant is
called a {\it wfs (well-formed state)} and we usually gather them and
define predicate {\tt wfs} as a conjunction of them. The reason why we
need several wfs predicates is because representing a global state as
a tuple of sets of objects is too general to represent structural
constraints, such as identifiers should be unique, there is no
dangling link, and so on. Each structural constraint is typically
represented as a wfs and should be an invariant. In addition, do not
forget to include $noCycle$ in the $init$ predicate when using the
Cyclic Dependency Lemma.\\

\noindent{\bf Step 0-2:} Define $cont$. \\ Since $cont(S)$ means that
state $S$ has at least one next state, it can be specified as follows
using the unconditional search predicate of \cafeobj:
%% =======================================================================
\small
\begin{verbatim}
  vars S SS : State
  eq cont(S) = (S =(*,1)=>+ SS) .
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 0-3:} Define $m$. \\ We should find a natural
number function that properly decreases in transitions. If we can
model a cloud system as a state machine where every transition rule
changes at least one local state of an object and there is no loop
transition, then the measuring function, $m$, can be easily defined as
the weighted sum of counting local states of all the classes of objects.
Suppose that local states of class $C$ are $st_C^0, st_C^1, \dots ,
st_C^{n_c}$ and they are straightforward, that is, there is no
backward transition, then $m$ can be $\sum_{C} \sum_{0 \le k \le n_C}
\#st_C^k \times (n_c - k)$ where $\#st_C^k$ is the number of objects
of class $C$ whose local state is $st_C^k$. For the CloudFormation
example case, $m$ can be defined as follows:
%% =======================================================================
\small
\begin{verbatim}
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  op m : State -> Nat
  eq m(< SetRS,SetPR >)
     = (#ResourceInStates(initial,SetRS) * 1) 
     + (#ResourceInStates(started,SetRS) * 0)
     + (#PropertyInStates(notready,SetPR) * 1) 
     + (#PropertyInStates(ready,SetPR) * 0) .
\end{verbatim}
\normalsize
%% =======================================================================
When a rule makes an object of class $C$ transit from state $s_c^k$ to
$st_C^{k+1}$, $\#st_C^k$ decreases by 1 and $\#st_C^{k+1}$ increases by 1 so that
$m(S')=m(S)-(n_c-k)+(n_c-k-1)=m(S)-1$ holds.

When the state machine has a rule without changing any local states
of objects, $m$ should include an additional term that decreases when
the rule is applied. But, instead, we recommend introducing some local
state representing whether the rule is already applied or not yet.

When there is a loop transition, $m$ should include an additional term
that properly decreases whenever a loop occurs. The simplest approach
is to introduce an object whose local state is a loop counter.\\

\noindent{\bf Step 0-4:} Define $inv$. \\ Invariants other than wfs
predicates are usually recognized to be necessary in the course of
proving conditions (1) to (6) above and are introduced by the users of
the framework. For example, the CloudFormation example case requires
an invariant {\tt inv-ifRSStartedThenPRReady} as explained in
Section~\ref{sec:lemma}.

Predicate $inv$ is a conjunction of all the invariants, however, the
straightforward representation is not so efficient. \cafeobj needs to
internally maintain long ANDed terms and to spend much processing
time. Fortunately, there is more efficient representation. Since the sufficient
conditions (2), (3), (4), and (6) include $inv$ in their antecedent
parts, it is enough to know whether each invariant does or does not
reduce to false. Thereby, we can define $inv$ such that it reduces to
false when one of invariants reduces to false as follows:
%% =======================================================================
\small
\begin{verbatim}
  var S : State

  pred inv : State

  -- wfs-*:
  ceq inv(S) = false if not wfs-atLeastOneRS(S) .
  ceq inv(S) = false if not wfs-allPRHaveRS(S) .
  ceq inv(S) = false if not wfs-allPRHaveRRS(S) .

  -- inv-*:
  ceq inv(S) = false if not inv-ifRSStartedThenPRReady(S) .
\end{verbatim}
\normalsize
%% =======================================================================
Note that only three of six wfs predicates are used to define $inv$,
since they directly take some roles in proofs.

As to sufficient conditions (5) and (6), $inv$ is also included in
their consequent parts, which case will be explained in
Section~\ref{sec:invariant}.\\

\noindent{\bf Step 0-5:} Prepare for using the Cyclic Dependency
Lemma. \\ When using the Cyclic Dependency Lemma, we firstly introduce
an object which is in one of the pre-transit local states of a
transition rule and then we claim that $\mathit{DDS_C}$ of the object includes
no object in the pre-transit local states.

CITP method used a {\tt :init} command to introduce a lemma on the way
of proofs.  The lemma should be defined in the non-execute mode and be
labeled in advance. The {\tt :init} command is used to specify the labeled lemma and
the appropriate substitution of variables.

In the CloudFormation example case, we will introduce an {\tt initial}
resource and claim that every resource in $\mathit{DDS_c}$ of the resource is
not {\tt initial}. The following conditional equation is defined in
advance and means that there is a contradiction when $\mathit{DDS_C}$ of the
specified resource includes any {\tt initial} resource.
%% =======================================================================
\small
\begin{verbatim}
  -- The Cyclic Dependency Lemma ensures
  -- an initial resource whose DDSC includes no initial resourecs.
  var T : RSType
  var IDRS : RSID
  var S : State
  ceq [Cycle :nonexec]: 
     true = false
     if someRSInStates(DDSC(res(T, IDRS, initial),S),initial) .
\end{verbatim}
\normalsize
%% =======================================================================
{\tt Cycle} is the label of this lemma and {\tt :nonexec} means that
this lemma is executed only when it is introduced by a {\tt :init}
command and variables {\tt T}, {\tt IDRS}, and {\tt S} are
substituted. The usage of an {\tt :init} command will be described in
the next section.\\

\noindent{\bf Step 0-6:} Prepare arbitrary constants. \\
Proof scores for the sufficient conditions requires many arbitrary constants.
We say such constants as {\it proof constants}.
In order to make the proof score be easy to understand, proof constants
are consistently named and declared. The following shows the definitions
of proof constants for the CloudFormation example case:
%% =======================================================================
\small
\begin{verbatim}
  ops idRS idRS' idRS1 : -> RSIDLt
  ops idRRS idRRS' idRRS1 : -> RSIDLt
  ops idPR idPR' idPR1 : -> PRIDLt
  ops sRS sRS' sRS'' sRS''' : -> SetOfResource
  ops sPR sPR' sPR'' sPR''' : -> SetOfProperty
  ops trs trs' trs'' trs''' : -> RSType
  ops tpr tpr' tpr'' tpr''' : -> PRType
  ops srs srs' srs'' srs''' : -> RSState
  ops spr spr' spr'' spr''' : -> PRState
  op stRS : -> SetOfRSState
  op stPR : -> SetOfPRState
\end{verbatim}
\normalsize
%% =======================================================================
%% ===============================================================
\section{Procedure: Proof of Sufficient Condition~(1)}
\label{sec:initcont}
%% ===============================================================
The verification procedure is basically a process to repeat three
actions; (1) pick up an unproved case which is then called the
{\it current case}, (2) split the current case into cases which
collectively cover the current case, (3) try to reduce the split cases
to true.\\

\noindent{\bf Step 1-0:} Define a predicate to be proved. \\
Predicate {\tt initcont} to represent condition~(1) can be defined as follows:
%% =======================================================================
\small
\begin{verbatim}
  var S : State
  pred initcont : State .
  eq initcont(S) = init(S) implies cont(S) .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 1-1:} Begin with the most general case. \\ In the
most general case for proof of condition~(1), the global
state consists of proof constants every of which represents an
arbitrary set of objects of each class. For the CloudFormation example
case, the most general case is as follows where {\tt sRS} and {\tt
  sPR} are proof constants for a set of resources and properties
respectively:
%% =======================================================================
\small
\begin{verbatim}
  :goal {eq initcont(< sRS, sPR >) = true .}
\end{verbatim}
\normalsize
%% =======================================================================
This case is too general to judge whether the condition does or does
not hold. Thereby, no reduction occurs.\\

\noindent{\bf Step 1-2:} Consider which rule is applied to the global
state in the current case. The rule is referred to as the {\it current
rule}.\\
One of the main benefits of interactive proof development is that
thinking through meaning of the specification leads to deep
understanding of it. If the developer of proofs cannot find the first
applied rule, it means insufficient understanding of the
specification. For the CloudFormation example case, the first rule is
{\tt R01}. \\

\noindent{\bf Step 1-3:} Split the current case into cases which
collectively cover the current case and one of which matches to LHS of
the current rule. \\ Since LHS of rule {\tt R01} requires the global
state to have at least one {\tt initial} resource, the current case is split
into three more cases, i.e.\ no resource, at least one {\tt initial}
or {\tt started} resource. In the following proof score, {\tt trs},
{\tt idRS}, and {\tt sRS'} are proof constants for a type of the
resource, an identifier of the resource, and a set of resources
respectively.
%% =======================================================================
\small
\begin{verbatim}
  :csp { 
    eq sRS = empRS .
    eq sRS = (res(trs,idRS,srs) sRS') .
  }
  -- Case 1: When there is no resource:
  :apply (rd) -- 1
  -- Case 2: When there is a resource:
  -- The state of the resource is initial or started.
  :csp { 
    eq srs = initial .
    eq srs = started .
  }
  -- Case 2-1: When the resource is initial:
  ... -- More case splitting needed.
  -- Case 2-2: When the resource idRS is started:
  :apply (rd) -- 2-2
\end{verbatim}
\normalsize
%% =======================================================================
Note that \stt{res(trs,idRS,srs)} represents an arbitrary resource.
The goal of Case 1 is proved because \stt{wfs-atLeastOneRS(S)} does
not hold and thus \stt{init(S)} does not hold. The goal of Case 2-2 is
also proved because \stt{allRSInStates(SetRS,initial)} does not hold.
Only Case 2-1 remains unproved and it then becomes the current case.\\

\noindent{\bf Step 1-4:} Split the current case into cases where
the condition of the rule does or does not hold. \\
Since the condition of rule {\tt R01} requires all the properties of the
{\tt initial} resource are {\tt ready}, Case 2-1 is split into two
more cases; all the properties are or are not {\tt ready}. As explained in
Section~\ref{sec:lemma}, the Set Predicate Lemma ensures that these cases are
represented as follows where {\tt tpr}, {\tt idPR}, {\tt idRRS}, and
{\tt sPR'} are proof constants for a type of the property, an
identifier of the property, an identifier of a resource referred by
the property, and a set of properties respectively:
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-1: When the resource is initial:
  -- The condition of R01 is allPROfRSInStates(sPR,idRS,ready) .
  :csp { 
    eq allPROfRSInStates(sPR,idRS,ready) = true .
    eq sPR = (prop(tpr,idPR,notready,idRS,idRRS) sPR') .
  }
  -- Case 2-1-1: When all properties of the resource are ready.
  :apply (rd) -- 2-1-1
  -- Case 2-1-2: When there is a not-ready property of the resource:
  ... -- More case splitting needed.
\end{verbatim}
\normalsize
%% =======================================================================
Note that \stt{prop(tpr,idPR,notready,idRS,idRRS)} represents an
arbitrary {\tt notready} property whose parent is {\tt idRS}. In Case
2-1-1, rule {\tt R01} can be applied, which means \stt{cont(S)} holds. Only
Case 2-1-2 remains unproved.\\

\noindent{\bf Step 1-5:} When there is a dangling link, split the
current case into cases where the linked object does or does not
exist. \\
In Case 2-1-2, property {\tt idPR} has a link to a resource with identifier
{\tt idRRS}. Thereby, it is split into three more cases; a resource
with identifier {\tt idRRS} does not exist, does exist and it is {\tt
  initial} or {\tt started}. The nonexistence can be represented as
predefined predicate {\tt existObj} (renamed to {\tt existRS} in this
case) does not hold. Case 2-1-2 is split into the following three
cases.

%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-1-2: When there is a not-ready property of the resource:
  -- The resource referred by the property does or does not exist.
  :csp {
    eq existRS(sRS',idRRS) = false .
    eq sRS' = (res(trs',idRRS,srs') sRS'') .
  }
  -- Case 2-1-2-1: When the referred resource does not exist:
  :apply (rd) -- 2-1-2-1
  -- Case 2-1-2-2: When the referred resource exists:
  -- The state of the resource is initial or started.
  :csp { 
    eq srs' = initial .
    eq srs' = started .
  }
  -- Case 2-1-2-2-1: When the resource idRRS is initial:
  ... -- More consideration needed.
  -- Case 2-1-2-2-2: When the resource idRRS is started:
  :apply (rd) -- 2-1-2-2-2
\end{verbatim}
\normalsize
%% =======================================================================
The goal of Case 2-1-2-1 is proved because \stt{wfs-allPRHaveRRS(S)}
does not holds and the goal of Case 2-1-2-2-2 is proved because
\stt{allRSInStates(SetRS,initial)} does not holds.  Only Case
2-1-2-2-1 remains unproved.\\

\noindent{\bf Step 1-6:} When falling in a cyclic situation, use the
Cyclic Dependency Lemma. \\
Since {\tt noRSCycle} is included in the {\tt init} condition and the
resource {\tt idRS} is {\tt initial}, the Cyclic Dependency Lemma
ensures there exists some {\tt initial} resource {\tt RS} such that no
resource in \stt{DDSC(RS,S)} is {\tt initial}. Recalling that we chose
{\tt idRS} as an arbitrary {\tt initial} resource in Step 1-3, we can
assume that resource {\tt idRS} itself is such {\tt RS} and can claim that there is a
contradiction when its $\mathit{DDS_C}$ includes any {\tt initial} resource
using a {\tt :init} command as follows:
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-1-2-2-1: When the resource idRRS is initial:
  -- The Cyclic Dependency Lemma rejects this case.
  :init [Cycle] by {
    T:RSType <- trs;
    IDRS:RSID <- idRS;
    S:State <- < sRS, sPR >;
  }
  :apply (rd) -- 2-1-2-2-1
\end{verbatim}
\normalsize
%% =======================================================================
The {\tt :init} command substitutes variable {\tt T} and {\tt IDRS}
with the type and identifier of the resource and {\tt S} with the
global state. It has the same effect as adding the following equation
into the current case:
%% =======================================================================
\small
\begin{verbatim}
  ceq true = false
     if someRSInStates(DDSC(res(trs, idRS, initial),< sRS, sPR >),
                       initial) .
\end{verbatim}
\normalsize
%% =======================================================================
Since $\mathit{DDS_C}$ of the resource
includes resource \stt{res(trs',idRRS,initial)}, there is a
contradiction and the goal of this case is proved.

The following is the result of a ``\stt{show proof}'' command, which shows
that goals of all of the split cases are proved and thus
condition~(1) is proved.
%% =======================================================================
\small
\begin{verbatim}
  root*
  [csp] 1*
  [csp] 2*
  [csp] 2-1*
  [csp] 2-1-1*
  [csp] 2-1-2*
  [csp] 2-1-2-1*
  [csp] 2-1-2-2*
  [csp] 2-1-2-2-1*
  [csp] 2-1-2-2-2*
  [csp] 2-2*
\end{verbatim}
\normalsize
%% =======================================================================

Figure~\ref{fig:procedure1} summarizes the procedure.
\begin{figure}
\centering
\includegraphics[height=11cm,natwidth=720,natheight=405,clip,trim=100 55 190 40]{procedure1.png}
\caption{Verification Procedure for Condition~(1)}
\label{fig:procedure1}
\end{figure}

%% ===============================================================
\section{Procedure: Proof of Sufficient Condition~(2)}
\label{sec:contcont}
%% ===============================================================
\noindent{\bf Step 2-0:} Define a predicate to be proved. \\ Using the
double negation idiom in Section~\ref{sec:searchpredicate}, predicate
{\tt contcont} for condition~(2) can be defined as follows:
%% =======================================================================
\small
\begin{verbatim}
  vars S SS : State
  var CC : Bool

  pred ccont : State State
  eq ccont(S,SS)
     = inv(S) and not final(S) implies cont(SS) or final(SS) .

  pred contcont : State
  eq contcont(S)
     = not (S =(*,1)=>+ SS if CC suchThat
            not ((CC implies ccont(S,SS)) == true)
            { true }) .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 2-1:} Begin with the cases each of which matches to
LHS of each rule. \\
Since condition~(2) checks every possible next state of
a given state $S$\!, we only need to prove the cases each of which
matches to each rule. For the CloudFormation example case, we can
begin with two cases for two rules as follows, which are too general:
%% =======================================================================
\small
\begin{verbatim}
  -- Goal of Condition (2) for rule R01
  :goal {
    eq contcont(< (res(trs,idRS,initial) sRS), sPR >) = true .
  }

  -- Goal of Condition (2) for rule R02
  :goal {
    eq contcont(< (res(trs,idRRS,started) sRS),
                  (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================

The rest of this section describes the procedure for condition~(2)
using the case of rule {\tt R01} as an example. The case of rule {\tt R02} will
be explained in Section~\ref{sec:initialcont}.\\

\noindent{\bf Step 2-2:} Split the current case for a rule into
cases where the condition of the rule does or does not hold. \\
Since the condition of rule {\tt R01} requires all the properties of the
{\tt initial} resource are {\tt ready}, the root case is split into
two cases; all the properties are or are not {\tt ready}.
%% =======================================================================
\small
\begin{verbatim}
  -- The condition of R01 does or does not hold for the resource of idRS.
  :ctf {
    eq allPROfRSInStates(sPR,idRS,ready) = true .
  }
  -- Case 1: When the condition of R01 holds:
  ... -- More case splitting needed
  -- Case 2: When the condition of R01 does not hold:
  :apply (rd) -- 2
\end{verbatim}
\normalsize
%% =======================================================================
Remember that in Step 1-4 explained above, we used a {\tt :csp}
command for case splitting based on the condition of rule {\tt R01}
because we need more consideration for the negative case.  In Step
2-2, we can simply use a {\tt :ctf} command, since Case 2 has no next
state and its goal can be proved. Thereby, only Case 1 remains unproved.\\

\noindent{\bf Step 2-3:} Split the current case into cases where
predicate $final$ does or does not hold in the next state.\\ 
In Case 1, rule {\tt R01} makes an {\tt initial} resource transit to
{\tt started} and the next state becomes a final state if all other
resources included the set {\tt sRS} of resources are already {\tt
  started}. Otherwise there is at least one other {\tt initial}
resource.  Using the Set Predicate Lemma, we can split the case as follows where
{\tt trs'}, {\tt idRS'}, and {\tt sRS'} are proof constants for a
type of the resource, an identifier of the resource, and a set of
resources respectively:
%% =======================================================================
\small
\begin{verbatim}
  -- Case 1: When the condition of R01 holds for the resource of idRS:
  -- All of the other resources are or are not started.
  :csp {
    eq allRSInStates(sRS,started) = true .
    eq sRS = (res(trs',idRS',initial) sRS') .
  }
  -- Case 1-1: When all of the other resources are started:
  :apply (rd) -- 1-1
  -- Case 1-2: When there is an initial resource:
  ... -- More case splitting needed
\end{verbatim}
\normalsize
%% =======================================================================
The goal of Case 1-1 is proved because the next state is final.  Case
1-2 remains unproved.\\

\noindent{\bf Step 2-4:} Similarly as Step 1-2, think which rule can
be applied to the next state. The rule is referred to as the {\it current
rule}.\\
Since the next state in Case 1-2 includes an {\tt initial} resource
with identifier {\tt idRS'}, rule {\tt R01} can be applied to it.\\

\noindent{\bf Step 2-5:} Similarly as Step 1-3, split the current case
into cases which collectively cover the current case and the next state of one of the split cases
matches to LHS of the current rule. \\ 
In this example, the next state of the current case already matches to LHS of rule {\tt R01}.\\

\noindent{\bf Step 2-6:} Similarly as Step 1-4, split the current case
into cases where the condition of the current rule does or does not
hold in the next state. \\
Again the Set Predicate Lemma can be used similarly as Step 1-4 as follows:
%% =======================================================================
\small
\begin{verbatim}
  -- Case 1-2: When there is an initial resource:
  :csp {
    eq allPROfRSInStates(sPR,idRS',ready) = true .
    eq sPR = (prop(tpr,idPR,notready,idRS',idRRS) sPR') .
  }
  -- Case 1-2-1: When all of properties of the resource idRS' are ready.
  :apply (rd) -- 1-2-1
  -- Case 1-2-2: When at least one of properties is not-ready.
  -- Because sPR is redefined, 
  -- allPROfRSInStates(sPR,idRS,ready) should be claimed again.
  :set(normalize-init,on)
  :init ( ceq B1:Bool = true if not B2:Bool . ) by {
    B1:Bool <- allPROfRSInStates(sPR,idRS,ready) ;
    B2:Bool <- allPROfRSInStates(sPR,idRS,ready) == true ;
  }
  :set(normalize-init,off)
  ... -- More consideration needed.
\end{verbatim}
\normalsize
%% =======================================================================
The goal of Case 1-2-1 is proved. Case 1-2-2 remains unproved and this
is somewhat troublesome for \cafeobj system.

Remember that in Step 2-2 we already introduced an equation which
claims that every property of the resource {\tt idRS} in the set of
properties {\tt sPR} is {\tt ready}. Here in Case 1-2-2, we need to
define that {\tt sPR} has a {\tt notready} property {\tt idPR}
(consequently its parent should not be the resource {\tt idRS}) and
the rest of properties are included in the set {\tt sPR'}. This breaks
the confluence property of equations; when reducing the term
\stt{allPROfRSInStates(sPR,idRS,ready)}, it reduces to true if
\cafeobj firstly uses the equation introduced in Step 2-2. But if
\cafeobj firstly uses the equation introduced here, it reduces to
\stt{allPROfRSInStates(sPR',idRS,ready)} and what we hope is the
former. However we should not break the confluence property, it is a
trade-off between the ideal and the consistent case splitting manner.
What is more important is to keep proof scores independent from the
reduction strategy of \cafeobj system. To do so, we have to write the
proof score such as it does nothing when
\stt{allPROfRSInStates(sPR,idRS,ready)} reduces to true but otherwise
it claims that the term reduces to true, which is the meaning of the {\tt
  :init} command above.

The command \stt{:set(normalize-init,on)} means that substituted
variables should be reduced to normal forms when the equation is
introduced by the {\tt :init} command; its default option is {\tt off}.
When the variable {\tt B1} reduces to true, {\tt B2} also reduces to
true and the equation to be introduced becomes ``\stt{ceq true = true if
  not true .}''  which has no meaning because the condition part never
holds.  When {\tt B1} reduces to
\stt{allPROfRSInStates(sPR',idRS,ready)}, {\tt B2} reduces to false
and thus the equation to be introduced becomes as follows, which we
want to claim:
%% =======================================================================
\small
\begin{verbatim}
  ceq allPROfRSInStates(sPR',idRS,ready) = true if not false .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 2-7:} Similarly as Step 1-5, when there is a
dangling link, split the current case into cases where the linked
object does or does not exist. \\
In Case 1-2-2, a property has a link to a resource with identifier
{\tt idRRS}. Thereby, it is split into three more cases; a resource
with identifier {\tt idRRS} does not exist, does exist and it is {\tt
  initial} or {\tt started}. The nonexistence can be represented as
predefined predicate {\tt existRS} does not hold. Case 1-2-2 is split
into the following three cases:
%% =======================================================================
\small
\begin{verbatim}
  -- Case 1-2-2: When at least one of properties is not-ready.
  ... -- Consideration above needed.
  -- The resource referred by the property does or does not exist.
  :csp {
    eq existRS(sRS',idRRS) = false .
    eq sRS' = (res(trs'',idRRS,srs'') sRS'') .
  }
  -- Case 1-2-2-1: When the referred resource does not exist:
  :apply (rd) -- 1-2-2-1
  -- Case 1-2-2-2: When the referred resource exists:
  -- The state of the resource is initial or started.
  :csp { 
    eq srs'' = initial .
    eq srs'' = started .
  }
  -- Case 1-2-2-2-1: When the resource idRRS is initial:
  ... -- More consideration needed.
  -- Case 1-2-2-2-2: When the resource idRRS is started:
  :apply (rd) -- 1-2-2-2-2
\end{verbatim}
\normalsize
%% =======================================================================
The goal of Case 1-2-2-1 is proved because \stt{wfs-allPRHaveRRS(S)}
does not holds and then \stt{inv(S)} does not hold as described in
Section~\ref{sec:support}.  The goal of Case 1-2-2-2-2 is also proved
because the {\tt notready} property {\tt idPR} refers the {\tt
  started} resource and so rule {\tt R02} is applicable in the next state.  Only Case
1-2-2-2-1 remains unproved.\\

\noindent{\bf Step 2-8:} Similarly as Step 1-6, when falling in a
cyclic situation, use the Cyclic Dependency Lemma. \\
If the invariant property of {\tt noRSCycle} is proved, we can use the
Cyclic Dependency Lemma in any reachable state. In Case 1-2-2-2-1,
there is an {\tt initial} resource {\tt idRS'} and so the lemma ensures
there exists some {\tt initial} resource {\tt RS} such that no
resource in \stt{DDSC(RS,S)} is {\tt initial}. Recalling that we chose
{\tt idRS'} as an arbitrary {\tt initial} resource in Step 2-3, we can
assume that itself is such {\tt RS} and can claim that there is a
contradiction when its $\mathit{DDS_C}$ includes any {\tt initial} resource
using a {\tt :init} command as follows:
%% =======================================================================
\small
\begin{verbatim}
  -- The Cyclic Dependency Lemma rejects this case.
  :init [Cycle] by {
    T:RSType <- trs';
    IDRS:RSID <- idRS';
    S:State <- < (res(trs,idRS,initial) sRS), sPR >;
  }
  :apply (rd) -- 1-2-2-2-1
\end{verbatim}
\normalsize
%% =======================================================================
The goal of this case is proved by the contradiction.

The following is the result of a ``\stt{show proof}'' command, which shows
that goals of all of the split cases are proved and thus
condition~(2) for rule {\tt R01} is proved:
%% =======================================================================
\small
\begin{verbatim}
  root*
  [ctf] 1*
  [csp] 1-1*
  [csp] 1-2*
  [csp] 1-2-1*
  [csp] 1-2-2*
  [csp] 1-2-2-1*
  [csp] 1-2-2-2*
  [csp] 1-2-2-2-1*
  [csp] 1-2-2-2-2*
  [ctf] 2*
\end{verbatim}
\normalsize
%% =======================================================================

Figure~\ref{fig:procedure2} summarizes the procedure for each transition rule.
\begin{figure}
\centering
\includegraphics[height=12cm,natwidth=720,natheight=405,clip,trim=60 0 180 0]{procedure2.png}
\caption{Verification Procedure for Condition~(2) for each rule}
\label{fig:procedure2}
\end{figure}

%% ===============================================================
\section{Procedure: Proof of Sufficient Condition~(3)}
\label{sec:mesmes}
%% ===============================================================
Since the antecedent part of condition~(3) is equivalent
to~(2), the proof procedure of~(3) is
almost the same as of~(2). \\

\noindent{\bf Step 3-0:} Use natural number axioms. \\
Since the standard sort {\tt Nat} of \cafeobj does not have enough
information to deduce natural number expressions, the framework provides
several axioms to be used for proof of condition~(3) and
(4).  The following is one of those axioms to be used
for the CloudFormation example:
%% =======================================================================
\small
\begin{verbatim}
  var N : Nat
  eq (1 + N) > N = true .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 3-1:} Define a predicate to be proved.\\
Using the double negation idiom in Section~\ref{sec:searchpredicate},
predicate {\tt mesmes} for condition~(3) can be defined
as follows:
%% =======================================================================
\small
\begin{verbatim}
  vars S SS : State
  var CC : Bool

  pred mmes : State State .
  eq mmes(S,SS)
     = inv(S) and not final(S) implies m(S) > m(SS) .

  pred mesmes : State .
  eq mesmes(S)
     = not (S =(*,1)=>+ SS if CC suchThat
            not ((CC implies mmes(S,SS)) == true)
            { true }) .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 3-2:} Begin with the cases each of which matches to
LHS of each rule. \\ 
\noindent{\bf Step 3-3:} Split the current case for a rule into
cases where the condition of the rule does or does not hold. 

For the CloudFormation example case, we can begin with two cases for
two rules. Since rule {\tt R01} is conditional, the general case
should be split into two cases according to Step 3-3. Then, the goals
of totally three cases can be proved and thus
condition~(3) is proved as follows:
%% =======================================================================
\small
\begin{verbatim}
  -- Goal of Condition (3) for rule R01
  :goal {
    eq mesmes(< (res(trs,idRS,initial) sRS), sPR >) = true .
  }
  -- The condition of R01 does or does not hold for S.
  :ctf {
    eq allPROfRSInStates(sPR,idRS,ready) = true .
  }
  -- Case 1: When the condition of R01 holds:
  :apply (rd) -- 1
  -- Case 1: When the condition of R01 does not hold:
  :apply (rd) -- 2

  -- Goal of Condition (3) for rule R02
  :goal {
    eq mesmes(< (res(trs,idRRS,started) sRS),
                (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
  }
  :apply (rd) -- goal
\end{verbatim}
\normalsize
%% =======================================================================

%% ===============================================================
\section{Procedure: Proof of Sufficient Condition~(4)}
\label{sec:mesfinal}
%% ===============================================================
\noindent{\bf Step 4-0:} Use natural number axioms. \\
Since the measuring function $m$ is defined as the sum of natural
numbers, $m(S) = 0$ means each of the numbers is also zero. Thereby,
when either \stt{\#ResourceInStates(initial,sRS)} or
\stt{\#PropertyInStates(notready,sPR)} is not zero, $m(S) = 0$ does
not hold and the goal is proved. The framework provides
several natural number axioms to enable such deduction as follows:
%% ===============================================================
\small
\begin{verbatim}
  vars N1 N2 : Nat
  var Nz : NzNat
  eq (N1 + N2 = 0) = (N1 = 0) and (N2 = 0) .
  eq (Nz = 0) = false .
\end{verbatim}
\normalsize
%% ===============================================================
Note that {\tt NzNat} is a subsort of {\tt Nat} which does not
include {\tt 0}.\\

\noindent{\bf Step 4-1:} Define a predicate to be proved. \\ Predicate
         {\tt mesfinal} for condition~(4) can be defined as follows:
%% =======================================================================
\small
\begin{verbatim}
  var S : State
  pred mesfinal : State .
  eq mesfinal(S)
     = inv(S) and cont(S) and m(S) = 0 implies final(S) .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 4-2:} Begin with the cases each of which matches to
LHS of each rule. \\ 
\noindent{\bf Step 4-3:} Split the current case for a rule into
cases where the condition of the rule does or does not hold. 

For the CloudFormation example case, we can begin with two cases for
two rules. Since rule {\tt R01} is conditional, the general case
should be split into two cases according to Step 4-3. Then, the goals
of totally three cases can be proved and thus condition~(4) is proved
as follows:
%% ===============================================================
\small
\begin{verbatim}
  -- Goal of Condition (4)' for rule R01
  :goal {
    eq mesfinal(< (res(trs,idRS,initial) sRS), sPR >) = true .
  }
  -- The condition of R01 does or does not hold for S.
  :ctf {
    eq allPROfRSInStates(sPR,idRS,ready) = true .
  }
  -- Case 1: When the condition of R01 holds:
  :apply (rd) -- 1
  -- Case 2: When the condition of R01 does not hold:
  :apply (rd) -- 2

  -- Goal of Condition (4)' for rule R02
  :goal {
    eq mesfinal(< (res(trs,idRRS,started) sRS),
                  (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
  }
  :apply (rd) -- goal
\end{verbatim}
\normalsize
%% ===============================================================

%% ===============================================================
\section{Procedure: Proof of Sufficient Condition~(5) \&~(6)}
\label{sec:invariant}
%% ===============================================================
Since predicate $inv$ typically is a conjunction of many predicates, it is
better to prove each of them separately. Suppose $inv(S) =
inv_1(S)\land inv_2(S)\land\dots\land inv_n(S)$, then we can
separately prove the invariant property of each $inv_k(S)$ since the
followings hold:
\[\forall S\in St: (\forall k:init(S)\ra inv_k(S))\ra(init(S)\ra inv(S))\]
\[\forall (S,S')\in \mathit{Tr}: (\forall k:inv(S)\ra inv_k(S'))\ra(inv(S)\ra inv(S'))\]

\vspace{0.3cm}
The rest of this section describes the proof procedure for three
typical kinds of invariants in the CloudFormation example case.

%% ===============================================================
\subsubsection*{Proof of Invariants for Local State Constraints}
%% ===============================================================
The most typical kind of invariants other that well-formed state
predicates is for constraints about local states of objects.  For
example, {\tt inv-ifRSStartedThenPRReady} says that every {\tt
  started} parent resource has {\tt ready} properties only.  It is
defined by using a predefined predicate {\tt ifXInStatesThenZInStates}
(renamed as {\tt ifRSInStatesThenPRInStates}). Since the framework
provides many lemmas for predefined predicates, it is easy to
prove the invariant property of such a predicate. \\

\noindent{\bf Step 5-0:} Define a predicate to be proved. \\ Predicate
         {\tt initinv} for condition~(5) can be defined
         as follows:
%% =======================================================================
\small
\begin{verbatim}
  vars S : State

  pred invK : State
  pred initinv : State
  eq initinv(S) = init(S) implies invK(S) .

  eq invK(S) = inv-ifRSStartedThenPRReady(S) .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 5-1:} Instantiate proved lemmas for predefined
predicates. \\
As described in Section~\ref{sec:linklemma}, proved lemma {\tt
  m2o-lemma07} can be instantiated and used for proof of
condition~(5) as follows:
%% ===============================================================
\small
\begin{verbatim}
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  -- Instantiating m2o-lemma07:
  -- eq m2o-lemma07(S_X,SX,St_X,S_Z,St_Z)
  --   = allObjInStates(S_X,SX) implies 
  --     ifXInStatesThenZInStates(S_X,St_X,S_Z,St_Z)
  --   when not (SX \in St_X) .
  eq [m2o-lemma07]:
      (allRSInStates(SetRS,initial) and 
       ifRSInStatesThenPRInStates(SetRS,started,SetPR,ready))
    = allRSInStates(SetRS,initial) .
\end{verbatim}
\normalsize
%% ===============================================================

\noindent{\bf Step 5-2:} Begin with the most general case. \\
The most general case is as follows where {\tt sRS} and {\tt
  sPR} are proof constants for a set of resources and properties
respectively:
%% ===============================================================
\small
\begin{verbatim}
  :goal {
    eq initinv(< sRS,sPR >) = true .
  }
  :apply (rd) -- goal
\end{verbatim}
\normalsize
%% ===============================================================
The instantiated proved lemma is effective enough to prove the most
general goal.\\

\noindent{\bf Step 6-0:} Define a predicate to be proved. \\ Using the
double negation idiom, predicate {\tt invinv} for
condition~(6) can be defined as follows:
%% =======================================================================
\small
\begin{verbatim}
  vars S SS : State
  var CC : Bool

  pred iinv : State State .
  eq iinv(S,SS) = inv(S) and invK(S) implies invK(SS) .

  pred invinv : State
  eq invinv(S)
     = not (S =(*,1)=>+ SS if CC suchThat
            not ((CC implies iinv(S,SS)) == true)
            { true }) .

  eq invK(S) = inv-ifRSStartedThenPRReady(S) .
\end{verbatim}
\normalsize
%% =======================================================================
However $inv(S)$ includes $inv_k(S)$, the antecedent part of
\stt{iinv(S)} doubly specifies \stt{invK(S)}. This is because {\tt
  inv(S)} is defined only to reduce to false when one of {\tt invK(S)}
reduces to false as described in Section~\ref{sec:support}.\\

\noindent{\bf Step 6-1:} Instantiate proved lemmas for predefined
predicates. \\ Rule {\tt R02} increases {\tt ready} properties which
has intuitively no effect on \\ {\tt inv-ifRSStartedThenPRReady}. As
explained in Section~\ref{sec:linklemma}, proved lemma {\tt
  m2o-lemma11} ensures it and can be used for proof of
condition~(6) as follows:
%% ===============================================================
\small
\begin{verbatim}
  vars IDRS IDRRS : RSID 
  var IDPR : PRID
  var TPR : PRType
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  -- Instantiating m2o-lemma11:
  -- eq m2o-lemma11(Z,Z',S_X,St_X,S_Z,St_Z)
  --   = ifXInStatesThenZInStates(S_X,St_X,(Z S_Z),St_Z)
  --       implies ifXInStatesThenZInStates(S_X,St_X,(Z' S_Z),St_Z) 
  --   when (state(Z') \in St_Z) and changeObjState(Z,Z') .
  eq [m2o-lemma11]:
     (ifRSInStatesThenPRInStates
      (SetRS,started,(prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR),ready)
     and
      ifRSInStatesThenPRInStates
      (SetRS,started,(prop(TPR,IDPR,   ready,IDRS,IDRRS) SetPR),ready))
     = 
      ifRSInStatesThenPRInStates
      (SetRS,started,(prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR),ready) .
\end{verbatim}
\normalsize
%% ===============================================================

\noindent{\bf Step 6-2:} Begin with the cases each of which matches to
LHS of each rule. \\ 
\noindent{\bf Step 6-3:} Split the current case for a rule into
cases where the condition of the rule does or does not hold. 

We can begin with two cases for two rules. Since rule {\tt R01} is
conditional, the general case should be split into two cases according
to Step 6-3. The first case should be split into more two cases
where the set of properties is or is not empty.
Then, the goals of all four cases can be proved and
thus condition~(6) is proved as follows:
%% ===============================================================
\small
\begin{verbatim}
  -- Goal of Condition (6) for rule R01
  :goal {
    eq invinv(< (res(trs,idRS,initial) sRS), sPR >) = true .
  }
  :ctf {
    eq allPROfRSInStates(sPR,idRS,ready) = true .
  }
  -- Case 1: When the condition of R01 holds:
  :ctf {
    eq sPR = empPR .
  }
  -- Case 1-1: sPR is empty.
  :apply (rd) -- 1-1
  -- Case 1-2: sPR is not empty.
  :apply (rd) -- 1-2
  -- Case 2: When the condition of R01 does not hold:
  :apply (rd) -- 2

  -- Goal of Condition (6) for rule R02
  :goal {
    eq invinv(< (res(trs,idRRS,started) sRS),
                (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
  }
  :apply (rd) -- goal
\end{verbatim}
\normalsize
%% ===============================================================

%% ===============================================================
\subsubsection*{Proof of Invariants for Structural Constraints}
%% ===============================================================
We should prove all of the wfs predicates as invariants, however, they are
included in $init$ and so we only need to prove
condition~(6) for each of them. Most of them check some
structural constraints of the cloud systems, which should usually keep
to hold when some transition rule changes a local state only and
does not change any links of some
object. When a wfs predicate is defined using predefined predicates, it
is easy to prove the invariant property of the wfs because the framework
provides many lemmas for the predefined predicates.

Here we use {\tt wfs-allPRHaveRS} as an example to show the procedure.\\

\noindent{\bf Step 6-0:} Define a predicate to be proved. 
%% =======================================================================
\small
\begin{verbatim}
  var S : State
  eq invK(S) = wfs-allPRHaveRS(S) .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 6-1:} Instantiate proved lemmas for predefined
predicates. \\ Since {\tt wfs-allPRHaveRS} uses the predefined
predicate {\tt allZHaveX}, the proved lemma \\ {\tt m2o-lemma05} can be
instantiated and used for proof of condition~(6) as
follows:
%% ===============================================================
\small
\begin{verbatim}
  var IDRS : RSID 
  var TPR : PRType
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  -- Instantiating m2o-lemma05:
  --  eq m2o-lemma05(X,X',S_Z,S_X) 
  --     = allZHaveX(S_Z,(X S_X)) implies allZHaveX(S_Z,(X' S_X))
  --     when id(X) = id(X') .
  eq [m2o-lemma05]:
     (allPRHaveRS(SetPR,(res(TRS,IDRS,initial) SetRS))
      and allPRHaveRS(SetPR,(res(TRS,IDRS,started) SetRS)))
    = allPRHaveRS(SetPR,(res(TRS,IDRS,initial) SetRS)) .
\end{verbatim}
\normalsize
%% ===============================================================

\noindent{\bf Step 6-2:} Begin with the cases each of which matches to
LHS of each rule. \\ 
\noindent{\bf Step 6-3:} Split the current case for a rule into
cases where the condition of the rule does or does not hold. 
%% ===============================================================
\small
\begin{verbatim}
  -- Goal of Condition (6) for rule R01
  :goal {
    eq invinv(< (res(trs,idRS,initial) sRS), sPR >) = true .
  }
  :ctf {
    eq allPROfRSInStates(sPR,idRS,ready) = true .
  }
  -- Case 1: When the condition of R01 holds:
  :apply (rd) -- 1
  -- Case 2: When the condition of R01 does not hold:
  :apply (rd) -- 2

  -- Goal of Condition (6) for rule R02
  :goal {
    eq invinv(< (res(trs,idRRS,started) sRS),
                (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
  }
  :apply (rd) -- goal
\end{verbatim}
\normalsize
%% ===============================================================

%% ===============================================================
\subsubsection*{Proof of $noCycle_C$ as an Invariant}
%% ===============================================================
We should prove the invariant property of $noCycle_C(S)$ in order to
use the Cyclic Dependency Lemma, however, it is included in $init$ and
thus we only need to prove condition~(6) for $noCycle_C$.
The Depending Subset Lemma in Section~\ref{sec:lemma}
ensures that we should prove that $\forall (S,S') \in \mathit{Tr}, \forall X\in
C:\mathit{DDS_C}(X,S')\subseteq \mathit{DDS_C}(X,S)$ instead of
condition~(6).\\

\noindent{\bf Step 6-0:} Define a predicate to be proved. 
%% =======================================================================
\small
\begin{verbatim}
  vars S SS : State
  var CC : Bool
  var RS : Resource
  -- When subset(DDSC(RS,SS),DDSC(RS,S)) holds for all RS,
  -- noRSCycle(S) implies noRSCycle(SS),
  pred invnoRSCycle : Resource State
  eq invnoRSCycle(RS,S) 
     = not (S =(*,1)=>+ SS if CC suchThat
            not ((CC implies subset(DDSC(RS,SS),DDSC(RS,S))) == true)
            { true }) .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 6-1:} Instantiate proved lemmas for predefined
predicates. \\ As described in Section~\ref{sec:lemma}, the proved
lemma {\tt m2o-lemma24} and {\tt set-lemma12} can be instantiated and
used for proof as follows:
%% ===============================================================
\small
\begin{verbatim}
  var S : State
  vars RS RS' : Resource
  var SetRS : SetOfResource
  var SetSRS : SetOfRSState
  var SetPR : SetOfProperty

  -- Instantiating set-lemma12:
  -- eq set-lemma12(S) = subset(S,S) .
  eq [set-lemma12]:
    subset(SetRS,SetRS) = true .

  -- Instantiating m2o-lemma24:
  -- eq m2o-lemma24(X,X',S_X,S_Z,St_X)
  --   = subset(getXsOfZsInStates((X' S_X),S_Z,St_X),
                getXsOfZsInStates((X S_X),S_Z,St_X))
  --   when id(X) = id(X') and not state(X') \in St_X .
  ceq [m2o-lemma24]:
    subset(getRRSsOfPRsInStates((RS' SetRS),SetPR,SetSRS),
           getRRSsOfPRsInStates((RS  SetRS),SetPR,SetSRS))
    = true
    if id(RS) = id(RS') and not state(RS') \in SetSRS .
\end{verbatim}
\normalsize
%% ===============================================================

\noindent{\bf Step 6-2:} Begin with the cases each of which matches to
LHS of each rule. \\ 
\noindent{\bf Step 6-3:} Split the current case for a rule into
cases where the condition of the rule does or does not hold. \\

The following is a proof score for $\mathit{DDS_C}(X,S')\subseteq \mathit{DDS_C}(X,S)$ for
rule {\tt R01}:
%% ===============================================================
\small
\begin{verbatim}
  :goal {
    eq invnoRSCycle(x,< (res(trs,idRS,initial) sRS), sPR >) = true .
  }
  :ctf {
    eq allPROfRSInStates(sPR,idRS,ready) = true .
  }
  -- Case 1: When the condition of R01 holds:
  :ctf {
    eq x = res(trs,idRS,initial) .
  }
  -- Case 1-1: X is the resource with identifier idRS.
  :apply (rd) -- 1-1
  -- Case 1-2: X is not the resource with identifier idRS.
  :ctf {
    eq state(x) = initial .
  }
  -- Case 1-2-1: The resource is initial.
  :apply (rd) -- 1-2-1
  -- Case 1-2-2: The resource is not initial.
  :apply (rd) -- 1-2-2
  -- Case 2: When the condition of R01 does not hold:
  :apply (rd) -- 2
\end{verbatim}
\normalsize
%% ===============================================================
Additionally two {\tt :ctf} commands are required to split Case 1 into
three more cases since the considering global state explicitly
includes a resource with identifier {\tt idRS}. The three cases are
where the considering resource {\tt x} is the resource {\tt idRS}
(Case 1-1), is not {\tt idRS} and is {\tt initial} (Case 1-2-1), and
is neither {\tt idRS} nor {\tt initial} (Case 1-2-2).\\

The following is a proof score for $\mathit{DDS_C}(X,S')\subseteq \mathit{DDS_C}(X,S)$ for
rule {\tt R02}:
%% ===============================================================
\small
\begin{verbatim}
  :goal {
    eq invnoRSCycle(x,
          < (res(trs,idRRS,started) sRS), 
            (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
  }
  :ctf {
    eq x = res(trs,idRRS,started) .
  }
  -- Case 1: X is the resource with identifier idRRS.
  :apply (rd) -- 1
  -- Case 2: X is not the resource with identifier idRRS.
  :ctf {
    eq state(x) = initial .
  }
  -- Case 2-1: The resource is initial.
  :ctf {
    eq id(x) = idRS .
  }
  -- Case 2-1-1: The identifier of X is idRS.
  :apply (rd) -- 2-1-1
  -- Case 2-1-2: The identifier of X is not idRS.
  :apply (rd) -- 2-1-2
  -- Case 2-2: The resource is not initial.
  :apply (rd) -- 2-2
\end{verbatim}
\normalsize
%% ===============================================================
Similarly, additional case splitting is required since the considering
global state includes two identifiers of resources. We need to
consider cases where {\tt x} is or is not {\tt idRS} or {\tt idRRS}.

%% ===============================================================
\section{A Lemma for Using Cyclic Dependency Lemma}
\label{sec:initialcont}
%% ===============================================================
Let us return to proof of condition~(2) for rule {\tt
  R02}.\\

\noindent{\bf Step 2-1:} Begin with the cases each of which matches to
LHS of each rule.
%% =======================================================================
\small
\begin{verbatim}
  -- Goal of Condition (2) for rule R02
  :goal {
    eq contcont(< (res(trs,idRRS,started) sRS),
                  (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 2-2:} Split the current case for a rule into
cases where the condition of the rule does or does not hold. \\
Rule {\tt R02} is unconditional.\\
\noindent{\bf Step 2-3:} Split the current case into cases where
predicate $final$ does or does not hold in the next state.\\
If all of the other resources are started, the next state is final.
But it is not the case because we know a notready property has
an initial parent resource. \\
\noindent{\bf Step 2-7:} When there is a dangling link, split the
current case into cases where the linked object does or does not
exist.
%% =======================================================================
\small
\begin{verbatim}
  -- The parent resource of the property does or does not exist.
  :csp {
    eq existRS(sRS,idRS) = false .
    eq sRS = (res(trs',idRS,srs') sRS') .
  }
  -- Case 1: When the parent resource of the property does not exist:
  :apply (rd) -- 1
  -- Case 2: When the parent resource of the property exists:
  -- The parent resource is initial or started.
  :csp {
    eq srs' = initial .
    eq srs' = started .
  }
  -- Case 2-1: When the parent resource is initial:
  ... -- More consideration needed.
  -- Case 2-2: When the parent resource is started:
  :apply (rd) -- 2-2
\end{verbatim}
\normalsize
%% =======================================================================
Case 2-1 for rule {\tt R02} is the same situation as Case 1-2 for {\tt
  R01} where there is an {\tt initial} resource in the next state and
the Cyclic Dependency Lemma ensures there exists some {\tt initial}
resource {\tt RS} such that no resource in \stt{DDSC(RS,S)} is {\tt
  initial}. Thus, here we need to write almost the same proof score as
of Case 1-2 for {\tt R01}. In addition, since we choose an arbitrary
{\tt initial} resource in Case 1-2 for {\tt R01}, we can assume itself
is the resource {\tt RS} which the Cyclic Dependency Lemma ensures to
exist. In this case, however, the {\tt initial} resource we have is
a parent of the property which rule {\tt R02} make transit. It means
that we should consider two similar cases where the resource {\tt RS}
is the parent resource or another arbitrary resource. We might have 
to repeat almost the same proof totally three times.

Thereby, it is wise to define a lemma and use it in the similar cases.
The lemma claims that if there is an {\tt initial} resource in a
global state then there exists a transition rule applicable to the
global state. It can be proved similar to the proof of
condition~1 as follows.

\noindent{\bf Step 1-0:} Define a predicate to be proved.
%% =======================================================================
\small
\begin{verbatim}
  vars B1 B2 : Bool

  pred (_when _) : Bool Bool { prec: 64 r-assoc }
  eq (B1 when B2)
     = B2 implies B1 .

  var S: State

  pred invcont : State
  eq invcont(S) 
    = cont(S) = true
    when inv(S) .
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 1-1:} Begin with the most general case.
%% =======================================================================
\small
\begin{verbatim}
  :goal {eq invcont(< (res(trs, idRS, initial) sRS), sPR >) = true .}
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 1-2:} Consider which rule is applied to the global
state in the current case. The rule is referred to as the {\it current
rule}.\\
The applicable transition may be {\tt R01} because the global state
includes an {\tt initial} resource.\\

\noindent{\bf Step 1-3:} Split the current case into cases which
collectively cover the current case and one of which matches to LHS of
the current rule. \\ 
The global state already matches to LHS of {\tt RO1}.\\

\noindent{\bf Step 1-4:} Split the current case into cases where
the condition of the rule does or does not hold.
%% =======================================================================
\small
\begin{verbatim}
  :csp { 
    eq allPROfRSInStates(sPR,idRS,ready) = true .
    eq sPR = (prop(tpr,idPR,notready,idRS,idRRS) sPR') .
  }
  -- Case 1: When all of or properties of the resource idRS are ready:
  :apply (rd) -- 1
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 1-5:} When there is a dangling link, split the
current case into cases where the linked object does or does not
exist.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2: When at least one of properties of the resource idRS is notready.
  -- The resource referred by the property does or does not exist.
  :csp {
    eq existRS(sRS,idRRS) = false .
    eq sRS = (res(trs',idRRS,srs) sRS') .
  }
  -- Case 2-1: When the resource referred by the property does not exist:
  :apply (rd) -- 2-1
  -- Case 2-2: When the resource referred by the property exists:
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 1-2:} Consider which rule is applied to the 
global state in the current case. \\
In this case, the transition rule to be applied may be {\tt R02} because the
global state includes a property.\\

\noindent{\bf Step 1-3:} Split the current case into cases which
collectively cover the current case and one of which matches to LHS of
the current rule. 
%% =======================================================================
\small
\begin{verbatim}
  -- The state of the resource is initial or started.
  :csp { 
    eq srs = initial .
    eq srs = started .
  }
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 1-6:} When falling in a cyclic situation, use the
Cyclic Dependency Lemma. 
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-2-1: When the resource idRRS is initial:
  -- The Cyclic Dependency Lemma rejects this case.
  :init [Cycle] by {
    T:RSType <- trs;
    IDRS:RSID <- idRS;
    S:State <- < (res(trs,idRS,initial) sRS), sPR >;
  }
  :apply (rd) -- 2-2-1
  -- Case 2-2-2: When the resource idRRS is started:
  :apply (rd) -- 2-2-2
\end{verbatim}
\normalsize
%% =======================================================================
Thus, all of the cases are successfully proved and we can assume that $cont(S)$
holds for any global state $S$ which include an {\tt initial}
resource.

Assuming that $inv$ holds, this lemma can be used as follows:
%% =======================================================================
\small
\begin{verbatim}
  var IDRS : RSID 
  var TRS : RSType
  var SetRS : SetOfResource
  var SetPR : SetOfProperty
  eq cont(< (res(TRS,IDRS,initial) SetRS), SetPR >) true .
\end{verbatim}
\normalsize
%% =======================================================================
Then, the proof of the sufficient condition~(2) for rule
{\tt R02} becomes very simple as follow:
%% =======================================================================
\small
\begin{verbatim}
  -- Goal of Condition (2) for rule R02
  :goal {
    eq contcont(< (res(trs,idRRS,started) sRS),
                  (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
  }
  -- The parent resource of the property does or does not exist.
  :csp {
    eq existRS(sRS,idRS) = false .
    eq sRS = (res(trs',idRS,srs') sRS') .
  }
  -- Case 1: When the parent resource of the property does not exist:
  :apply (rd) -- 1
  -- Case 2: When the parent resource of the property exists:
  -- The parent resource is initial or started.
  :csp {
    eq srs' = initial .
    eq srs' = started .
  }
  -- Case 2-1: When the parent resource is initial:
  :apply (rd) -- 2-1
  -- Case 2-2: When the parent resource is started:
  :apply (rd) -- 2-2
\end{verbatim}
\normalsize
%% =======================================================================

%% ===============================================================
\section{Recommended Module Structure}
%% ===============================================================
The framework provides a recommended module structure which the user
can adopt when developing proof scores for verifying the property
($init~\mbstt{leads-to}~final$). Using the recommended structure
results in proof scores which are consistent and easier to understand.
Figure~\ref{fig:modules} depicts the recommended module structure
whereas each box represents a module and each dashed arrow represents
a ``protecting'' or ``extending'' import of another module. An italic
name means a template module.

\begin{figure}
\centering
\includegraphics[height=9.5cm,natwidth=720,natheight=405,clip,trim=90 80 130 20]{modules.png}
%%trim=left bottom right top
\caption{Recommended Module Structure}
\label{fig:modules}
\end{figure}

The following list describes the role and content of each module:
\begin{itemize}
\item {\tt OBJECTCLASS}\Large$_n$\normalsize\\
  Module for each class of objects. This class should be named as
  representing the class appropriately. The name usually consists
  of upper case letters because the same name will be capitalized
  and used for the sort of the class. The contents of this module
  is as follows:
  \begin{enumerate}
  \item Protecting import the modules of other classes which this
    class links.
  \item Extending import the template module {\tt OBJECTBASE} and
    rename predefined sorts and operators for the class.
  \item Define the constructor of the class.
  \item Define literals of the type and local state of the class.
  \item Define the selectors of the class.
  \item Define operators that are specific to the class if any.
  \end{enumerate}
\item {\tt LINKS}\\
  Module for links between objects. 
  \begin{enumerate}
  \item Protecting import the modules of classes of links.
  \item Extending import the template modules {\tt OBJLINKONE2ONE} and
    {\tt OBJLINKMANY2ONE}, and rename predefined sorts and operators
    for links between objects.
  \end{enumerate}
\item {\tt STATE}\\
  Module for global states.
  \begin{enumerate}
  \item Protecting import {\tt LINKS}.
  \item Define sort {\tt State} for representing global states.  A
    global state is usually represented as a tuple of sets of objects,
    each of the sets is a finite subset of a class.
  \end{enumerate}
\item {\tt STATECyclefuns}\\
  Module for preparing to use the Cyclic Dependency Lemma.
  \begin{enumerate}
  \item Protecting import {\tt STATE}.
  \item Define operator {\tt getAllObjInState}.
  \item Define operator {\tt DDSC}.
  \end{enumerate}
\item {\tt STATEfuns}\\
  Module for defining many kinds of operators for global states.
  \begin{enumerate}
  \item Protecting import {\tt STATE}.
  \item Extending import the template module {\tt CYCLEPRED} with {\tt
    STATECyclefuns} as a parameter module, and rename predefined
    operator {\tt noCycle}.
  \item Define wfs predicates.
  \item Define predicates {\tt init}, {\tt final}, and {\tt wfs}.
  \item Define operators required to implement standard predicates
    above if any.
  \end{enumerate}
\item {\tt STATERules}\\
  Module for transition rules.
  \begin{enumerate}
  \item Protecting import {\tt STATEfuns}.
  \item Define transition rules.
  \end{enumerate}
\item {\tt ProofBase}\\
  Module for common definitions to prove six sufficient conditions.
  \begin{enumerate}
  \item Protecting import {\tt STATERules}.
  \item Define invariant predicates.
  \item Define predicate {\tt cont}.
  \item Define operator {\tt m}.
  \item Define predicate {\tt inv} such that it reduces to false when
    one of invariants reduces to false.
  \item Define problem specific lemmas if any.
  \item Prepare proof constants.
  \end{enumerate}
\item {\tt ProofInitCont}\\
  Module for proving sufficient condition~(1).
  \begin{enumerate}
  \item Protecting import {\tt ProofBase}.
  \item Define predicate {\tt initcont}.
  \item Define problem specific lemmas if any.
  \end{enumerate}
\item {\tt ProofContCont}\\
  Module for proving sufficient condition~(2).
  \begin{enumerate}
  \item Protecting import {\tt ProofBase}.
  \item Define predicate {\tt contcont}.
  \item Define problem specific lemmas if any.
  \end{enumerate}
\item {\tt ProofMeasure}\\
  Module for proving sufficient condition~(3).
  \begin{enumerate}
  \item Protecting import {\tt ProofBase}.
  \item Define predicate {\tt mesmes}.
  \item Define axioms of {\tt Nat}.
  \item Define problem specific lemmas if any.
  \end{enumerate}
\item {\tt ProofMesFinal}\\
  Module for proving sufficient condition~(4).
  \begin{enumerate}
  \item Protecting import {\tt ProofBase}.
  \item Define predicate {\tt mesfinal}.
  \item Define axioms of {\tt Nat}.
  \item Define problem specific lemmas if any.
  \end{enumerate}
\item {\tt ProofInv}\\
  Module for common definitions for proving sufficient
  condition~(5) and (6).
  \begin{enumerate}
  \item Protecting import {\tt ProofBase}.
  \item Define predicates {\tt invK}, {\tt initinv}, and {\tt invinv}.
  \end{enumerate}
\item {\tt Proofinv-*  Proofwfs-*}\\
  Module for proving each invariant. \\The name of this module is usually
  {\tt Proof+}$name\_of\_invariant$.
  \begin{enumerate}
  \item Protecting import {\tt ProofInv}.
  \item Define predicates {\tt invK} to be the invariant.
  \item Define lemmas if necessary.
  \end{enumerate}
\end{itemize}

%% ===============================================================
\section{Considerations on Sound Proof Scores}
\label{sec:soundProof}
%% ===============================================================
%% ===============================================================
\subsection{Usage of Equivalent Operator \_ == \_}
%% ===============================================================
As described in Section~\ref{sec:searchpredicate}, $term1$ {\tt ==}
$term2$ reduces to {\tt true} if both terms are reduced to be the same
term and to {\tt false} otherwise. On the other hand, $term1$ {\tt =}
$term2$ reduces to {\tt true} iff $term1$ {\tt ==} $term2$ reduces to
{\tt true}. This means that there is a case where $term1$ {\tt ==}
$term2$ reduces to {\tt false} and $term1$ {\tt =} $term2$ does not
so. Thus the users should not carelessly use \_ == \_ operator because
it may lead unintended results.

The framework recommends using \_ == \_ operator only in the
following three cases:
\begin{enumerate}
\item As equal operator \_ = \_ for literals: \\
  Three of sorts provided by the framework, such as ObjIDLt, ObjTypeLt
  and ObjStateLt, are to represent literals. A literal is a constant
  for which the framework predefines a special equality predicate such
  that $\_ = \_$ is exactly the same as $\_ == \_ $ . Since a Boolean
  term ``$ literal_1 = literal_2 $'' always reduces to false, the
  users should not write such Boolean terms in their proof scores.
\item In the double negation idiom: \\
  As described in Section~\ref{sec:searchpredicate}, the double
  negation idiom uses ``$\_ == true$'' to stop the search when
  there is a next state where the specified condition cannot
  reduce to either true or false.
\item To keep the confluence property in the case splitting:\\ The
  following set of three equations are not confluent because
  \stt{p(s)} reduces to true when equation (2) is used but it also
  reduces to \stt{p(s')} when equation (3) is firstly used:
  \begin{verbatim}
    pred p : SetOfObject
    eq p(O:Object S:SetOfObject) = p(S) . -- (1)
    ops s s' : -> SetOfObject
    op o : -> Object
    eq p(s) = true .                      -- (2)
    eq s = (o s') .                       -- (3)
  \end{verbatim}\vspace{-0.6cm}
  As described in Section~\ref{sec:contcont}, this situation sometimes
  occurs when being guided by the proof procedure of the
  framework. For example, in the current case, \stt{p(s)} matches to
  the condition part of a transition rule and the case should be split
  into two more cases where set of object \stt{s}, is or not is
  empty. While we may avoid this situation by changing the order of
  the case splitting guided by the framework, it requires careful
  considerations and results in proof scores difficult to understand
  and maintain. Thus, we decided to recommend writing proof codes
  which explicitly ensure the confluent property as follows:
  \begin{verbatim}
    :set(normalize-init,on)
    :init ( ceq B1:Bool = true if not B2:Bool . ) by {
      B1:Bool <- p(s) ;
      B2:Bool <- p(s) == true ;
    }
    :set(normalize-init,off)
  \end{verbatim}\vspace{-0.6cm}
  When \cafeobj processes as \stt{p(s)} reduces to true, the \stt{:init}
  command introduces the following meaningless equation:
  \begin{verbatim}
    ceq true = true if not true .
  \end{verbatim}\vspace{-0.6cm}
  Otherwise, when \stt{p(s)} reduces to \stt{p(s')}, it introduces the
  following desired equation:
  \begin{verbatim}
    ceq p(s') = true if not false .
  \end{verbatim}
\end{enumerate}

%% ===============================================================
\subsection{Usage of Search Predicates}
%% ===============================================================
When the behavior model is not {\it coherent}, search predicates may
not be able to search all possible transitions.  Coherence means that,
given a global state term $S$\!, for any next state $S^R$ of $S$ such
that some transition rule $R$ makes $S$ transit to $S^R$, if $S$
reduces to $S'$ then there exists some rule $R'$ which makes $S'$
transit to $S^{R'}$ such that both $S^R$ and $S^{R'}$ reduce to the
same global state term $S^*$~\cite{Maude14}.  Otherwise, there may be
two different next states of $S$ and a search predicate can search
only one of them depending on whether transition rules or equations
are used firstly.

In general, it is difficult to keep behavior model coherent. However,
if the users of the framework go along with the following three rules,
then search predicates can search next states of the given global
state terms without depending on the order to use transition rules and
equations:
\begin{enumerate}
\item A global state term included in the top goal of a proof should
  be a ground constructor term which consists of the constructors declared
  in the structure model and fresh proof constants, e.g., \stt{< sRS,sPR >}.
\item When a current case is split and an equation is introduced whose
  LHS is a proof constant in the current goal, RHS of the equation
  should be a ground constructor term which consists of the
  constructors declared in the structure model and fresh proof
  constants, e.g., \stt{eq sRS = (res(trs',idRS,srs') sRS') .}
  Moreover, any pair of equations in a proof case does not define the
  same proof constant.
\item A global state term included in LHS or RHS of a transition rule
  should be a constructor term, e.g., \stt{< (res(TRS,IDRS,started)
    SetRS), SetPR >}.
\end{enumerate}
Let the goal and proof constants in a proof case and transition rules
in the model follow the above rules. We say a term as {\it a ground
  semi-constructor term} iff it consists of only the constructors declared
in the structure model and proof constants.  We also say a ground term
{\it has a canonical form} iff it reduces to a single term regardless
of the order in which the equations are applied.
\begin{lemma}
\label{def:allcano}
  Let $c$ be a constructor whose arity is $n$ and let ground terms
  $g_i, 1\le i\le n$ have canonical forms. Then, ground term
  $c(g_1,\dots,g_n)$ has a canonical form.
\end{lemma}
\begin{lemma}
  A ground semi-constructor term in a proof case has a canonical form.
\end{lemma}
Proof: Let $a, b$ be proof constants in the proof case and let $a > b$
mean that there is an equation whose LHS is $a$ and RHS includes $b$
in the proof case, then $>$ is a partial order of proof constants
assuming that they follow the above rules. This lemma can be proved
using the mathematical induction about the partial order.
\vspace{-0.3cm}
\begin{description}
\setlength{\parskip}{0cm}
\setlength{\itemsep}{0cm}
\item {\bf Base case:} When the ground semi-constructor term does not
  include any defined proof constants, it is a ground constructor term
  and it always reduces to itself.
\item {\bf Induction case:} Let $a$ be a defined proof constant and
  let us assume that any ground semi-constructor term, including proof
  constants all of which are less than $a$, has a canonical form. Let
  $T$ be a ground semi-constructor term whose included proof constants
  are less than $a$ or $a$ itself. Any subterm of $T$ except $a$ has a
  canonical form because of the induction hypothesis. The equation
  which defines $a$ rewrites term $a$ to its RHS which has a canonical
  form because of the induction hypothesis. The
  lemma~\ref{def:allcano} guarantees that a term consisting of a
  constructor which has $a$ as its argument has a canonical form.
  Thus, all subterms of $T$ have canonical forms and $T$ itself does so.
  $\Box$
\end{description}
\begin{lemma}
\label{def:coherent}
  Let global state term $S$ be a ground semi-constructor term and $R$ a
  transition rule which makes $S$ transit to next state $S^R$. If $S$
  reduces to $S'$ then $R$ also makes $S'$ transit to $S'^R$ such
  that both $S^R$ and $S'^R$ reduce to the same global state term
  $S^*$.
\end{lemma}
Proof: Let LHS of $R$ be $C_L(V_1,\dots,V_n)$ where $C_L$ is a context
with $n$ holes and $V_i, 1\le i\le n$, are variables placed in the
holes.  Similarly, let RHS of $R$ be $C_R(V_1,\dots,V_n)$ although
context $C_R$ may have less than $n$ holes in which case several
$V_i$'s are omitted. When $R$ makes $S$ transit to $S^R$, each
variable $V_i$ matches to some subterm $t_i$ of $S$\!,
i.e. $S=C_L(t_1,\dots,t_n)$, thus $S^R=C_R(t_1,\dots,t_n)$. Let $t_i$
reduce to $t^*_i$, then $S'=C_L(t^*_1,\dots,t^*_n)$ because it is the
canonical form of $S$\!.  Similarly $S^R$ has a canonical form
$S^*=C_R(t^*_1,\dots,t^*_n)$.  On the other hand, LHS
$C_L(V_1,\dots,V_n)$ matches to $S'=C_L(t^*_1,\dots,t^*_n)$ where each
$V_i$ matches to $t^*_i$ and thus $R$ makes $S'$ transit to
$S^*$. $\Box$\\

When the goal and proof constants in a proof case and transition rules
in the model follow the above three rules, the global state given to
the search predicates is always a ground semi-constructor term. Then
Lemma~\ref{def:coherent} ensures that the result of the search does
not depend on the order to use transition rules and equations.

%% ===============================================================
\subsection{Usage of the Double Negation Idiom}
%% ===============================================================
It should be noted that the double negation idiom always returns true
when there is no next state. The typical pitfall is to give the idiom
a global state term which does not match to any LHS and condition of
transition rules. Since the idiom is used for the sufficient
conditions (2) (3) and (6), the users of the framework should
carefully check the goal of proofs especially in Step 2-1, 2-2, 3-2,
3-3, 6-2, and 6-3.

A simple but effective way to check this pitfall is
to temporally remove the inner ``\stt{not}'' in the double negation
idiom and see that the goal does not reduce to true. If the goal
reduces to true regardless of whether the inner condition is or is not
denied, it means that there is no next state of the given global
state.

%% ===============================================================
\chapter{Applying the Framework to TOSCA Specifications}
\label{chap:appTOSCA}
%% ===============================================================
This chapter describes how to use our framework to define behavior of
TOSCA types and to verify that a specified topology can correctly
automate to set up the cloud system.

%% ===============================================================
\section{Structure Model of TOSCA Templates}
\label{sec:TOSCAstructure}
%% ===============================================================
A TOSCA topology models a cloud system that it consists of
four classes of objects corresponding to the four main kinds of
elements of a topology, i.e.\ nodes, relationships, capabilities, and
requirements. There is an additional object, a message pool, to
represent messaging between resources inside of different VMs because
they cannot communicate directly. The message pool is simply a bag of
messages, which abstracts implementations of messaging.

There are several domain specific constraints of the structure:
\begin{enumerate}
\item A node should be hosted on at most one other node.
\item A relationship should not relate a capability and a
  requirement of the same node.
\item A local relationship should relate a capability and a
  requirement of the nodes hosted on the same virtual machine.
\item A remote relationship should relate a capability and a
  requirement of the nodes hosted on the different virtual machines.
\item We assume that types of capabilities and requirements are
  the same as relationships that link them in this dissertation for the sake
  of simplicity.
\end{enumerate}

%% ===============================================================
\subsection{Representation of the Example Structure Model}
\label{sec:TOSCAstructRep}
%% ===============================================================
Let us use a typical example where four node types and three
relationship types in Fig.~\ref{fig:exampletopology} participate in
automation of a setup operation.  There are nine nodes of four types,
nine capabilities, nine requirements, and nine relationships of three
types. An initial global state may be represented in \cafeobj as the
following ground term:
%% =======================================================================
\small
\begin{verbatim}
  < ( node(VM, VMApache, initial)
      node(OS, OSApache, initial)
      node(MW, ApacheWebServer, initial)
      node(SC, CRMApp, initial)
      node(SC, PhpModule, initial)
      node(VM, VMMySQL, initial)
      node(OS, OSMySQL, initial)
      node(MW, MySQL, initial)
      node(SC, CRMDB, initial) ),
    ( cap(hostedOn, VMApacheOS, closed, VMApache)
      cap(hostedOn, OSApacheSoftware, closed, OSApache)
      cap(hostedOn, ApacheWebServerWebapps, closed, ApacheWebServer)
      cap(hostedOn, ApacheWebServerModules, closed, ApacheWebServer)
      cap(dependsOn, PhpModulePhpApps, closed, PhpModule)
      cap(hostedOn, VMMySQLOS, closed, VMMySQL)
      cap(hostedOn, OSMySQLSoftware, closed, OSMySQL)
      cap(hostedOn, MySQLDatabases, closed, MySQL)
      cap(connectsTo, CRMDBClients, closed, CRMDB) ),
    ( req(hostedOn, OSApacheContainer, unbound, OSApache)
      req(hostedOn, ApacheWebServerContainer, unbound, ApacheWebServer)
      req(dependsOn, CRMAppPhpRuntime, unbound, CRMApp)
      req(connectsTo, CRMAppDatabase, unbound, CRMApp)
      req(hostedOn, CRMAppContainer, unbound, CRMApp)
      req(hostedOn, PhpModuleContainer, unbound, PhpModule)
      req(hostedOn, OSMySQLContainer, unbound, OSMySQL)
      req(hostedOn, MySQLContainer, unbound, MySQL)
      req(hostedOn, CRMDBContainer, unbound, CRMDB) ),
    ( rel(hostedOn, OSApacheHostedOnVMApache,
          VMApacheOS, OSApacheContainer)
      rel(hostedOn, ApacheHostedOnOSApache,
          OSApacheSoftware, ApacheWebServerContainer)
      rel(hostedOn, CRMAppHostedOnApache,
          ApacheWebServerWebapps, CRMAppContainer)
      rel(hostedOn, PhpModuleHostedOnApache,
          ApacheWebServerModules, PhpModuleContainer)
      rel(dependsOn, CRMAppDependsOnPhpModule,
          PhpModulePhpApps, CRMAppPhpRuntime)
      rel(hostedOn, OSMySQLHostedOnVMMySQL,
          VMMySQLOS, OSMySQLContainer)
      rel(hostedOn, MySQLHostedOnOSMySQL,
          OSMySQLSoftware, MySQLContainer)
      rel(hostedOn, CRMDBHostedOnMySQL,
          MySQLDatabases, CRMDBContainer)
      rel(connectsTo, CRMAppConnectsToCRMDB,
          CRMDBClients, CRMAppDatabase) ),
     empMsg > 
\end{verbatim}
\normalsize
%% =======================================================================
The constructor name represents the class of the object ({\tt node},
{\tt cap}, {\tt req}, {\tt rel}), the first argument is its type ({\tt
  VM}, {\tt hostedOn}, and so on), the second is its identifier ({\tt
  VMApache}, {\tt VMApacheOS}, and so on), and the third is its local
state.  The fourth argument of the capability or requirement object
represents a link to its parent.  The fourth and fifth arguments of
the relationship object represent links to its corresponding
capability and requirement respectively. The last term, {\tt empMsg},
represents an empty message pool.

The representation of these four classes can be easily defined using the
template module {\tt OBJECTBASE} provided by the framework. Module
{\tt NODE} for the node class is as follows:
%% =======================================================================
\small
\begin{verbatim}
  module! NODE {
      -- Instantiation of Template
      extending(OBJECTBASE
          * {sort ObjIDLt -> NDIDLt,
             sort ObjID -> NDID,
             sort ObjTypeLt -> NDTypeLt,
             sort ObjType -> NDType,
             sort ObjStateLt -> NDStateLt,
             sort ObjState -> NDState,
             sort Object -> Node,
             sort SetOfObject -> SetOfNode,
             sort SetOfObjState -> SetOfNDState,
             op empObj -> empND,
             op empState -> empSND,
             op existObj -> existND,
             op existObjInStates -> existNDInStates,
             op uniqObj -> uniqND,
             op #ObjInStates -> #NodeInStates,
             op getObject -> getNode,
             op allObjInStates -> allNDInStates,
             op allObjOfTypeInStates -> allNDOfTypeInStates,
             op allObjNotInStates -> allNDNotInStates,
             op someObjInStates -> someNDInStates})
    
    -- Constructor
    -- node(NDType, NDID, NDState) is a Node.
    op node : NDType NDID NDState -> Node {constr}
  
    -- There are four typical node types.
    ops VM OS MW SC : -> NDTypeLt {constr}
  
    -- Variables
    var TND : NDType
    var IDND : NDID
    var SND : NDState
  
    -- Selectors
    eq type(node(TND,IDND,SND)) = TND .
    eq id(node(TND,IDND,SND)) = IDND .
    eq state(node(TND,IDND,SND)) = SND .
  
    -- Local States
    ops initial created started : -> NDStateLt {constr}
    -- Predicate for Local States
    pred isCreated : NDState
    eq isCreated(initial) = false .
    eq isCreated(created) = true .
    eq isCreated(started) = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================
The types of nodes are {\tt VM} (virtual machine), {\tt OS} (operating
system), {\tt MW} (middleware), and {\tt SC} (software component).  The
local states of nodes are {\tt initial}, {\tt created}, and {\tt
  started}. Among them, {\tt created} and {\tt started} are {\tt
  isCreated}.

In addition to the predefined predicates/operators explained in
Section~\ref{sec:linkpred}, module {\tt NODE} instantiates a predicate
concerning the node types, {\tt allObjOfTypeInStates}, described as
follows whereas argument $seto$ is a set of linking objects, $setls$
is a set of local states of linking objects, and $ty$ is a type of an
object:
\begin{itemize}
\item \stt{allObjOfTypeInStates} (renamed as \stt{allNDOfTypeInStates})\\
  Predicate used as \stt{allObjOfTypeInStates($seto$,$ty$,$setls$)}
  which holds iff every object of type $ty$ in $seto$ is in one of
  local states of $setls$;\\$~~~~\forall o\in
  seto:\mbstt{type}(o)=ty\ra\mbstt{state}(o)\in setls$.
\end{itemize}

Since a capability links to its parent node, module {\tt CAPABILITY} for
its class protecting includes {\tt NODE} as follows:
%% =======================================================================
\small
\begin{verbatim}
  module! CAPABILITY {
    protecting(NODE)
  
    -- Instantiation of Template
    extending(OBJECTBASE
          * {sort ObjIDLt -> CPIDLt,
             sort ObjID -> CPID,
             sort ObjTypeLt -> CPTypeLt,
             sort ObjType -> CPType,
             sort ObjStateLt -> CPStateLt,
             sort ObjState -> CPState,
             sort Object -> Capability
             sort SetOfObject -> SetOfCapability,
             sort SetOfObjState -> SetOfCPState,
             op empObj -> empCP,
             op empState -> empSCP,
             op existObj -> existCP,
             op existObjInStates -> existCPInStates,
             op uniqObj -> uniqCP,
             op #ObjInStates -> #CapabilityInStates,
             op getObject -> getCapability,
             op allObjInStates -> allCPInStates,
             op allObjOfTypeInStates -> allCPOfTypeInStates,
             op allObjNotInStates -> allCPNotInStates,
             op someObjInStates -> someCPInStates})
  
    -- Constructor
    -- cap(CPType, CPID, CPState, NDID) is a Capability of a Node
    op cap : CPType CPID CPState NDID -> Capability {constr}
  
    -- Variables
    var TCP : CPType
    var IDCP : CPID
    var SCP : CPState
    var IDND : NDID
  
    -- Selectors
    op node : Capability -> NDID
    eq type(cap(TCP,IDCP,SCP,IDND)) = TCP .
    eq id(cap(TCP,IDCP,SCP,IDND)) = IDCP .
    eq state(cap(TCP,IDCP,SCP,IDND)) = SCP .
    eq node(cap(TCP,IDCP,SCP,IDND)) = IDND .
  
    -- Local States
    ops closed open available : -> CPStateLt {constr}
    -- Predicate for Local States
    pred isActivated : CPState
    eq isActivated(closed) = false .
    eq isActivated(open) = true .
    eq isActivated(available) = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================
Note that {\tt node} is a selector for a link to the parent node of
the capability. The local states of capabilities are {\tt closed},
{\tt open}, and {\tt available}. Among them, {\tt open} and {\tt
  available} are {\tt isActivated}.

Since a requirement also links to its parent node, module {\tt REQUIREMENT} for
its class protecting includes {\tt NODE} as follows:
%% =======================================================================
\small
\begin{verbatim}
  module! REQUIREMENT {
    protecting(NODE)
  
    -- Instantiation of Template
    extending(OBJECTBASE
          * {sort ObjIDLt -> RQIDLt,
             sort ObjID -> RQID,
             sort ObjTypeLt -> RQTypeLt,
             sort ObjType -> RQType,
             sort ObjStateLt -> RQStateLt,
             sort ObjState -> RQState,
             sort Object -> Requirement,
             sort SetOfObject -> SetOfRequirement,
             sort SetOfObjState -> SetOfRQState,
             op empObj -> empRQ,
             op empState -> empSRQ,
             op existObj -> existRQ,
             op existObjInStates -> existRQInStates,
             op uniqObj -> uniqRQ,
             op #ObjInStates -> #RequirementInStates,
             op getObject -> getRequirement,
             op allObjInStates -> allRQInStates,
             op allObjOfTypeInStates -> allRQOfTypeInStates,
             op allObjNotInStates -> allRQNotInStates,
             op someObjInStates -> someRQInStates})
  
    -- Constructor
    -- req(RQType, RQID, RQState, NDID) is a Requirement of a Node
    op req : RQType RQID RQState NDID -> Requirement {constr}
  
    -- Variables
    var TRQ : RQType
    var IDRQ : RQID
    var IDND : NDID
    var SRQ : RQState
  
    -- Selectors
    op node : Requirement -> NDID
    eq type(req(TRQ,IDRQ,SRQ,IDND)) = TRQ .
    eq id(req(TRQ,IDRQ,SRQ,IDND)) = IDRQ .
    eq state(req(TRQ,IDRQ,SRQ,IDND)) = SRQ .
    eq node(req(TRQ,IDRQ,SRQ,IDND)) = IDND .
  
    -- Local States
    ops unbound waiting ready : -> RQStateLt {constr}
}
\end{verbatim}
\normalsize
%% =======================================================================
Note that {\tt node} is a selector for a link to the parent node of
the requirement. The local states of requirements are {\tt unbound},
{\tt waiting}, and {\tt ready}.


Since a relationship links to both of its corresponding capability and
requirement, module {\tt RELATIONSHIP} for its class protecting
includes {\tt CAPABILITY} and {\tt REQUIREMENT} as follows:
%% =======================================================================
\small
\begin{verbatim}
  module! RELATIONSHIP {
    protecting(CAPABILITY + REQUIREMENT)
  
    -- Instantiation of Template
    extending(OBJECTBASE
          * {sort ObjIDLt -> RLIDLt,
             sort ObjID -> RLID,
             sort ObjTypeLt -> RLTypeLt,
             sort ObjType -> RLType,
             sort ObjStateLt -> RLStateLt,
             sort ObjState -> RLState,
             sort Object -> Relationship,
             sort SetOfObject -> SetOfRelationship,
             sort SetOfObjState -> SetOfRLState,
             op empObj -> empRL,
             op existObj -> existRL,
             op uniqObj -> uniqRL})
  
    -- Constructor
    -- rel(RLType, RLID, CPID, RQID) is a Relationship
    op rel : RLType RLID CPID RQID -> Relationship {constr}
  
    -- There are three typical relationship types.
    ops hostedOn dependsOn connectsTo : -> RLTypeLt {constr}
    -- Types of capabilities and requirements are the same as relationships
    [RLType < CPType RQType]
  
    -- Variables
    var TRL : RLType
    var IDRL : RLID
    var IDCP : CPID
    var IDRQ : RQID
  
    -- Selectors
    op cap : Relationship -> CPID
    op req : Relationship -> RQID
    eq type(rel(TRL,IDRL,IDCP,IDRQ)) = TRL .
    eq id(rel(TRL,IDRL,IDCP,IDRQ)) = IDRL .
    eq cap(rel(TRL,IDRL,IDCP,IDRQ)) = IDCP .
    eq req(rel(TRL,IDRL,IDCP,IDRQ)) = IDRQ .
  
    -- Predicate for Locality
    pred isLocalRL : Relationship
    eq isLocalRL(rel(hostedOn,IDRL,IDCP,IDRQ)) = true .
    eq isLocalRL(rel(dependsOn,IDRL,IDCP,IDRQ)) = true .
    eq isLocalRL(rel(connectsTo,IDRL,IDCP,IDRQ)) = false .
  }
\end{verbatim}
\normalsize
%% =======================================================================
Sort {\tt RLType} is declared as a subsort of {\tt CPType} and {\tt RQType}
which means types of relationships can be used as types of capabilities
and requirements.
The types of relationships are {\tt hostedOn}, {\tt dependsOn}, and
{\tt connectsTo}.  Among them, {\tt hostedOn} and {\tt dependsOn} are
{\tt isLocal}.  Note that {\tt cap} and {\tt req} are selectors for
links to the corresponding capability and requirement respectively of
the relationship.

Predefined predicates and operators for links between objects also can
be easily instantiated using the template modules {\tt
  OBJLINKMANY2ONE} and {\tt OBJLINKONE2ONE} as follows:
%% =======================================================================
\small
\begin{verbatim}
  module! LINKS {
    protecting(NODE + CAPABILITY + REQUIREMENT + RELATIONSHIP)
  
    -- Instantiation of Template
    -- A many-to-one link from a capability to its parent node
    extending(OBJLINKMANY2ONE(
          CAPABILITY {sort Object -> Capability,
                      sort ObjID -> CPID,
                      sort ObjType -> CPType,
                      sort ObjState -> CPState,
                      sort SetOfObject -> SetOfCapability,
                      sort SetOfObjState -> SetOfCPState,
                      sort LObject -> Node,
                      sort LObjID -> NDID,
                      sort LObjState -> NDState,
                      sort SetOfLObject -> SetOfNode,
                      sort SetOfLObjState -> SetOfNDState,
                      op getLObject -> getNode,
                      op existLObj -> existND,
                      op empLObj -> empND,
                      op link -> node,
                      op existLObjInStates -> existNDInStates})
          * {op getXOfZ -> getNDOfCP,
             op getZsOfX -> getCPsOfND,
             op getZsOfTypeOfX -> getCPsOfTypeOfND,
             op getZsOfXInStates -> getCPsOfNDInStates,
             op getZsOfTypeOfXInStates -> getCPsOfTypeOfNDInStates,
             op getXsOfZs -> getNDsOfCPs,
             op getXsOfZsInStates -> getNDsOfCPsInStates,
             op getZsOfXs -> getCPsOfNDs,
             op getZsOfXsInStates -> getCPsOfNDsInStates,
             op getZsOfTypeOfXsInStates -> getCPsOfTypeOfNDsInStates,
             op allZHaveX -> allCPHaveND,
             op allZOfXInStates -> allCPOfNDInStates,
             op allZOfTypeOfXInStates -> allCPOfTypeOfNDInStates,
             op ifXInStatesThenZInStates -> ifNDInStatesThenCPInStates,
             op ifXInStatesThenZOfTypeInStates
                -> ifNDInStatesThenCPOfTypeInStates}
          )
  
    -- Instantiation of Template
    -- A many-to-one link from a requirement to its parent node
    extending(OBJLINKMANY2ONE(
          REQUIREMENT {sort Object -> Requirement,
                       sort ObjID -> RQID,
                       sort ObjType -> RQType,
                       sort ObjState -> RQState,
                       sort SetOfObject -> SetOfRequirement,
                       sort SetOfObjState -> SetOfRQState,
                       sort LObject -> Node,
                       sort LObjID -> NDID,
                       sort LObjState -> NDState,
                       sort SetOfLObject -> SetOfNode,
                       sort SetOfLObjState -> SetOfNDState,
                       op getLObject -> getNode,
                       op existLObj -> existND,
                       op empLObj -> empND,
                       op link -> node,
                       op existLObjInStates -> existNDInStates})
          * {op getXOfZ -> getNDOfRQ,
             op getXsOfZs -> getNDsOfRQs,
             op getXsOfZsInStates -> getNDsOfRQsInStates,
             op getZsOfX -> getRQsOfND,
             op getZsOfTypeOfX -> getRQsOfTypeOfND,
             op getZsOfXInStates -> getRQsOfNDInStates,
             op getZsOfTypeOfXInStates -> getRQsOfTypeOfNDInStates,
             op getZsOfXs -> getRQsOfNDs,
             op getZsOfXsInStates -> getRQsOfNDsInStates,
             op getZsOfTypeOfXsInStates -> getRQsOfTypeOfNDsInStates,
             op allZHaveX -> allRQHaveND,
             op allZOfXInStates -> allRQOfNDInStates,
             op allZOfTypeOfXInStates -> allRQOfTypeOfNDInStates,
             op ifXInStatesThenZInStates -> ifNDInStatesThenRQInStates,
             op ifXInStatesThenZOfTypeInStates
                -> ifNDInStatesThenRQOfTypeInStates}
          )
  
    -- Instantiation of Template
    -- A one-to-one link from a relationship to its capability
    extending(OBJLINKONE2ONE(
          RELATIONSHIP {sort Object -> Relationship,
                        sort ObjID -> RLID,
                        sort ObjType -> RLType,
                        sort ObjState -> RLState,
                        sort SetOfObject -> SetOfRelationship,
                        sort SetOfObjState -> SetOfRLState,
                        sort LObject -> Capability,
                        sort LObjID -> CPID,
                        sort LObjState -> CPState,
                        sort SetOfLObject -> SetOfCapability,
                        sort SetOfLObjState -> SetOfCPState,
                        op getLObject -> getCapability,
                        op existLObj -> existCP,
                        op empLObj -> empCP,
                        op link -> cap,
                        op existLObjInStates -> existCPInStates})
          * {op existX -> existCP,
             op getXOfY -> getCPOfRL,
             op getXsOfYs -> getCPsOfRLs,
             op getXsOfYsInStates -> getCPsOfRLsInStates,
             op getYOfX -> getRLOfCP,
             op getYsOfXs -> getRLsOfCPs,
             op getYsOfXsInStates -> getRLsOfCPsInStates,
             op uniqX -> uniqCP,
             op YOfXInStates -> RLOfCPInStates,
             op ifXInStatesThenYInStates -> ifCPInStatesThenRLInStates,
             op ifYInStatesThenXInStates -> ifRLInStatesThenCPInStates,
             op allYHaveX -> allRLHaveCP,
             op allXHaveY -> allCPHaveRL,
             op onlyOneYOfX -> onlyOneRLOfCP}
          )
  
    -- Instantiation of Template
    -- A one-to-one link from a relationship to its relationship
    extending(OBJLINKONE2ONE(
          RELATIONSHIP {sort Object -> Relationship,
                        sort ObjID -> RLID,
                        sort ObjType -> RLType,
                        sort ObjState -> RLState,
                        sort SetOfObject -> SetOfRelationship,
                        sort SetOfObjState -> SetOfRLState,
                        sort LObject -> Requirement,
                        sort LObjID -> RQID,
                        sort LObjState -> RQState,
                        sort SetOfLObject -> SetOfRequirement,
                        sort SetOfLObjState -> SetOfRQState,
                        op getLObject -> getRequirement,
                        op existLObj -> existRQ,
                        op empLObj -> empRQ,
                        op link -> req,
                        op existLObjInStates -> existRQInStates})
          * {op existX -> existRQ,
             op getXOfY -> getRQOfRL,
             op getXsOfYs -> getRQsOfRLs,
             op getXsOfYsInStates -> getRQsOfRLsInStates,
             op getYOfX -> getRLOfRQ,
             op getYsOfXs -> getRLsOfRQs,
             op getYsOfXsInStates -> getRLsOfRQsInStates,
             op uniqX -> uniqRQ,
             op YOfXInStates -> RLOfRQInStates,
             op ifXInStatesThenYInStates -> ifRQInStatesThenRLInStates,
             op ifYInStatesThenXInStates -> ifRLInStatesThenRQInStates,
             op allYHaveX -> allRLHaveRQ,
             op allXHaveY -> allRQHaveRL,
             op onlyOneYOfX -> onlyOneRLOfRQ}
          )
  }
\end{verbatim}
\normalsize
%% =======================================================================
Links from capabilities to their parent nodes and from requirements to
their parent nodes are many-to-one, whereas links from relationships to
their corresponding capabilities and requirements are one-to-one.

In addition to the predefined predicates/operators explained in
Section~\ref{sec:linkpred}, module {\tt LINKS} uses {\tt
  OBJLINKMANY2ONE} to instantiate several operators concerning object
types. The following is a list of such operators whereas argument $seto$ is a
set of linking objects, $setls$ is a set of local states of linking
objects, $\mathit{lobj}$ is a linked object, $lid$ is an identifier of a linked
object, $setlo$ is a set of linked objects, $setlls$ is a set of local
states of linked objects, and $ty$ is a type of an object:
\begin{itemize}
\item \stt{allZOfTypeOfXInStates}\\
  (renamed as \stt{allCPOfTypeOfNDInStates} and \stt{allRQOfTypeOfNDInStates})\\
  Predicate used as
  \stt{allZOfTypeOfXInStates($seto$,$ty$,$lid$,$setls$)} which holds
  iff every object included in $seto$ whose type is $ty$ and whose
  link is $lid$ is in one of locals state in $setls$;\\$~~~~\forall
  o\in
  seto:(\mbstt{type}(o)=ty\land\mbstt{link}(o)=lid\ra\mbstt{state}(o)\in
  setls)$.
\item \stt{getZsOfTypeOfX} (as \stt{getCPsOfTypeOfND} and \stt{getRQsOfTypeOfND})\\
  Operator used as \stt{getZsOfTypeOfX($seto$,$ty$,$\mathit{lobj}$)} which
  returns a subset $seto$ each of\\ whose element object is of type $ty$
  and links to $\mathit{lobj}$.
\item \stt{getZsOfTypeOfXInStates}\\
  (as \stt{getCPsOfTypeOfNDInStates} and \stt{getRQsOfTypeOfNDInStates})\\
  Operator used as
  \stt{getZsOfTypeOfXInStates($seto$,$ty$$\mathit{lobj}$,$setls$)} which
  returns a subset of $seto$ each of whose element object is of type
  $ty$, links to $\mathit{lobj}$, and is in one of local states of $setls$.
\item \stt{getZsOfTypeOfXsInStates}\\
  (as \stt{getCPsOfTypeOfNDsInStates} and \stt{getRQsOfTypeOfNDsInStates})\\
  Operator used as
  \stt{getZsOfTypeOfXsInStates($seto$,$ty$,$setlo$,$setls$)} which
  returns a subset of $seto$ each of whose element object is of type
  $ty$, links to some object included in $setlo$, and is in one of
  local states of $setls$.
\item \stt{ifXInStatesThenZOfTypeInStates}\\
(as \stt{ifNDInStatesThenCPOfTypeInStates} and \stt{ifNDInStatesThenRQOfTypeInStates})\\
  Predicate used as
  \stt{ifXInStatesThenZOfTypeInStates($setlo$,$ty$,$setlls$,$seto$,$setls$)}
  which holds iff every object included in $setlo$ whose type
m  is $ty$ and whose local sate is included in $setlls$ is linked by
  objects included in $seto$ each of which is in one of local states
  in $setls$;
  \vspace{-0.3cm}
  \begin{eqnarray*}
    \forall lo\in setlo:&&(\mbstt{type}(lo)=ty\land\mbstt{state}(lo)\in setlls\ra\\
    &&\forall o\in seto: (\mbstt{link}(o)=\mbstt{id}(lo)\ra\mbstt{state}(o)\in setls)).
  \end{eqnarray*}
\end{itemize}

Module {\tt LINKS} also uses {\tt OBJLINKONE2ONE} to instantiate many
predicates/operators. The following is a list of such operators whereas argument
$\mathit{obj}$ is a linking object, $seto$ is a set of linking objects, $setls$
is a set of local states of linking objects, $\mathit{lobj}$ is a linked
object, $lid$ is an identifier of a linked object, $setlo$ is a set of
linked objects, and $setlls$ is a set of local states of linked
objects:
\begin{itemize}
\item \stt{existX} (renamed as \stt{existCP} and \stt{existRQ})\\
  Predicate used as \stt{existX($seto$,$lid$)} which holds iff some
  object whose link is $lid$ is included in $seto$;\\$~~~~\exists o\in
  seto: \mbstt{link}(o)=lid$.
\item \stt{getXOfY} (as \stt{getCPOfRL} and \stt{getRQOfRL})\\
  Operator used as \stt{getXOfY($setlo$,$\mathit{obj}$)} which returns an
  object linked by $\mathit{obj}$ and included in $setlo$.
\item \stt{getXsOfYs} (as \stt{getCPsOfRLs} and \stt{getRQsOfRLs})\\
  Operator used as \stt{getXsOfYs($setlo$,$seto$)} which returns a
  subset of $setlo$ each of whose element object is linked by some
  object included in $seto$.
\item \stt{getXsOfYsInStates} (as \stt{getCPsOfRLsInStates} and \stt{getRQsOfRLsInStates})\\
  Operator used as \stt{getXsOfYsInStates($setlo$,$seto$,$setlls$)}
  which returns a subset of $setlo$ each of whose element object is
  linked by some object included in $seto$ and is in one of local
  states of $setlls$.
\item \stt{getYOfX} (as \stt{getRLOfCP} and
  \stt{getRLOfRQ})\\ Operator used as \stt{getYOfX($seto$,$\mathit{lobj}$)}
  which returns an object which included in $seto$ and whose link is
  $\mathit{lobj}$.
\item \stt{getYsOfXs} (as \stt{getRLsOfCPs} and \stt{getRLsOfRQs})\\
  Operator used as \stt{getYsOfXs($seto$,$setlo$)} which returns a
  subset of $seto$ each of whose element object links to some object
  included in $setlo$.
\item \stt{getYsOfXsInStates} (as \stt{getRLsOfCPsInStates} and \stt{getRLsOfRQsInStates})\\
  Operator used as \stt{getYsOfXsInStates($seto$,$setlo$,$setls$)}
  which returns a subset of $seto$ each of whose element object links
  to some object included in $setlo$ and is in one of local states of
  $setls$.
\item \stt{uniqX} (as \stt{uniqCP} and \stt{uniqRQ})\\
  Predicate used as \stt{uniqX($seto$)} which holds iff the
  link of each object is unique in $seto$;\\$~~~~\forall o,o'\in
  seto:(o\ne o'\ra\mbstt{link}(o)\ne\mbstt{link}(o'))$.
\item \stt{YOfXInStates} (as \stt{RLOfCPInStates} and \stt{RLOfRQInStates})\\
  Predicate used as \stt{YOfXInStates($seto$,$lid$,$setls$)} which
  holds iff an object included in $seto$ whose link is $lid$
  is in one of locals state in $setls$;\\$~~~~\exists o\in
  seto:(\mbstt{link}(o)=lid\land\mbstt{state}(o)\in setls)$.
\item \stt{ifXInStatesThenYInStates}\\
(as \stt{ifCPInStatesThenRLInStates} and \stt{ifRQInStatesThenRLInStates})\\
  Predicate used as
  \stt{ifXInStatesThenYInStates($setlo$,$setlls$,$seto$,$setls$)}
  which holds iff every object included in $setlo$ whose local
  sate is included in $setlls$ is linked by an object included in $seto$
  which is in one of local states in $setls$;\\$~~~~
    \forall lo\in setlo:(\mbstt{state}(lo)\in setlls\ra \exists o\in
    seto: (\mbstt{link}(o)=\mbstt{id}(lo)\land\mbstt{state}(o)\in
    setls))$.
\item \stt{ifYInStatesThenXInStates}\\
(as \stt{ifRLInStatesThenCPInStates} and \stt{ifRLInStatesThenRQInStates})\\
  Predicate used as
  \stt{ifYInStatesThenXInStates($seto$,$setls$,$setlo$,$setlls$)}
  which holds iff every object included in $seto$ whose local
  sate is included in $setls$ links to an object included in $setlo$
  which is in one of local states in $setlls$;\\
  $~~~~\forall o\in seto:(\mbstt{state}(o)\in setls\ra \exists lo\in
    setlo: (\mbstt{link}(o)=\mbstt{id}(lo)\land\mbstt{state}(lo)\in
    setlls))$.
\item \stt{allYHaveX} (as \stt{allRLHaveCP} and \stt{allRLHaveRQ})\\
  Predicate used as \stt{allYHaveX($seto$,$setlo$)} which holds
  iff every object included in $seto$ has an object linked by it
  which is included in $setlo$;\\$~~~~\forall o\in seto,\exists lo\in
  setlo:\mbstt{id}(lo)=\mbstt{link}(o)$.
\item \stt{allXHaveY} (as \stt{allCPHaveRL} and
  \stt{allRQHaveRL})\\ Predicate used as
  \stt{allXHaveY($setlo$,$seto$)} which holds iff every object
  included in $setlo$ has an object which links to it and is included
  in $seto$;\\$~~~~\forall lo\in setlo,\exists o\in
  seto:\mbstt{id}(lo)=\mbstt{link}(o)$.
\item \stt{OnlyOneYOfX} (renamed as \stt{onlyOneRLOfCP} and
  \stt{onlyOneRLOfRQ})\\ Predicate used as
  \stt{OnlyOneYOfX($seto$,$lid$)} which holds iff only one object
  whose link is $lid$ is included in $seto$;\\$~~~~\exists o\in seto:
  \mbstt{link}(o)=lid\land(\forall o'\in seto:o\ne
  o'\ra\mbstt{link}(o)\ne\mbstt{link(o')})$.
\end{itemize}

A global state of the TOSCA structure models includes one additional
object, a message pool. There are two kinds of messages, open messages
and available messages, which will be explained in the next
section. The representation of the messages is defined as follows:
%% =======================================================================
\small
\begin{verbatim}
  module! MSG {
    protecting(LINKS)
    [Msg]
    -- An open message
    op opMsg : CPID -> Msg {constr}
    -- An available message
    op avMsg : CPID -> Msg {constr}
  
    vars IDCP1 IDCP2 : CPID 
    eq (opMsg(IDCP1) = opMsg(IDCP2))
       = (IDCP1 = IDCP2) .
    eq (avMsg(IDCP1) = avMsg(IDCP2))
       = (IDCP1 = IDCP2) .
    eq (opMsg(IDCP1) = avMsg(IDCP2))
       = false .
  }    
\end{verbatim}
\normalsize
%% =======================================================================
An open message (and also an available message) has an argument of the
identifier of a capability. Open messages are equal to each other iff
they have the same capability identifier, which is similar to
available messages. An open message and an available message are never
equal to each other.

The representation of a global state is defined by sort {\tt State} as
a tuple consisting of a set of nodes, a set of capabilities, a set of
requirements, a set of relationships, and a message pool as follows
whereas parameterized module {\tt BAG} defines generic bags similarly
to module {\tt SET} explained in Section~\ref{sec:module}:
%% =======================================================================
\small
\begin{verbatim}
  module! STATE {
    protecting(LINKS)
    protecting(BAG(MSG {sort Elt -> Msg})
        * {sort Bag -> PoolOfMsg,
           op empty -> empMsg})
  
    [State]
    op <_,_,_,_,_> : SetOfNode SetOfCapability SetOfRequirement 
                     SetOfRelationship PoolOfMsg -> State {constr}
  }
\end{verbatim}
\normalsize
%% =======================================================================

In addition to the instantiated operators from the predefined ones, it
requires to define several problem specific operators in module {\tt
  STATEfuns}. There are three kinds of them; (1) to represent
invariants for the consistency between messages and local states of
objects, (2) to represent invariants for the consistency between
capabilities and requirements connected by relationships, and (3) to
represent other problem specific constraints. All of these operators can
be easily implemented by combining predefined operators.

The following is a list of such operators whereas argument $setCP$ is a set of
capabilities, $setRQ$ is a set of requirements, $setRL$ is a set of
relationships, $node$ is a node, $cap$ is a capability, $req$ is a
requirement, $rel$ is a relationship, $setlCP$ is a set of local
states of capabilities, $setlRQ$ is a set of local states of
requirements, and $pool$ is a message pool\footnote{Note that here we
  do not distinguish between an object and its identifier for the sake
  of brevity.}:
\begin{itemize}
\item \stt{allHostedOnCPInStates} (categorized as (3) above)\\ 
  Predicate used as \stt{allHostedOnCPInStates($setCP$,$setlCP$)}
  which holds iff every capability included in $setCP$ whose type is
  {\tt hostedOn} is in one of locals state in $setlCP$;\\$~~~~\forall
  cap\in
  setCP:(\mbstt{type}(cap)=\mbstt{hostedOn}\ra\mbstt{state}(cap)\in
  setlCP)$.
\item \stt{allHostedOnRQInStates} (categorized as (3))\\ 
  Predicate used as \stt{allHostedOnRQInStates($setRQ$,$setlRQ$)}
  which holds iff every requirement included in $setRQ$ whose type is
  {\tt hostedOn} is in one of locals state in $setlRQ$;\\$~~~~\forall
  req\in
  setRQ:(\mbstt{type}(req)=\mbstt{hostedOn}\ra\mbstt{state}(req)\in
  setlRQ)$.
\item \stt{allHostedOnRQOfNDInStates} (categorized as (3))\\ 
  Predicate used as
  \stt{allHostedOnRQOfNDInStates($setRQ$,$node$,$setlRQ$)} which holds iff
  every requirement included in $setRQ$ whose type is {\tt hostedOn} and whose
  parent is $node$ is in one of locals state in $setlRQ$;\\$~~~~\forall
  req\in
  setRQ:(\mbstt{type}(req)=\mbstt{hostedOn}\land\mbstt{node}(req)=node\ra\mbstt{state}(req)\in
  setlRQ)$.
\item \stt{getCPOfRQ} (categorized as (2))\\
 Operator used as \stt{getCPOfRQ($setCP$,$setRL$,$req$)} which returns
 the corresponding capability of $req$ by firstly finding the
 corresponding relationship of $req$ in $setRL$ and then finding the
 corresponding capability of the relationship in $setCP$.
\item \stt{getRQOfCP} (categorized as (2))\\
 Operator used as \stt{getRQOfCP($setRQ$,$setRL$,$cap$)} which returns
 the corresponding requirement of $cap$ by firstly finding the
 corresponding relationship of $cap$ in $setRL$ and then finding the
 corresponding requirement of the relationship in $setRQ$.
\item \stt{allRLHaveSameTypeCPRQ} (categorized as (3))\\ 
  Predicate used as
  \stt{allRLHaveSameTypeCPRQ($setRL$,$setCP$,$setRQ$)} which holds iff
  every relationship included in $setRL$ has the corresponding
  capability included in $setCP$ and the corresponding requirement
  included in $setRQ$ and those three objects has the same type;\\ 
  $~~~~\forall rel\in setRL:\\
  ~~~~~~~~(\forall cap\in setCP:\mbstt{cap}(rel)=cap\ra\mbstt{type}(rel)=\mbstt{type}(cap))\land\\
  ~~~~~~~~(\forall req\in setRQ:\mbstt{req}(rel)=req\ra\mbstt{type}(rel)=\mbstt{type}(req))$.
\item \stt{allRLNotInSameND} (categorized as (3))\\ 
  Predicate used as
  \stt{allRLNotInSameND($setRL$,$setCP$,$setRQ$)} which holds iff
  every relationship included in $setRL$ has the corresponding
  capability included in $setCP$ and the corresponding requirement
  included in $setRQ$ and their parent nodes are not the same;\\ 
  $~~~~\forall rel\in setRL, \exists cap\in setCP, \exists req\in setRQ:\\
  ~~~~~~~~~\mbstt{cap}(rel)=cap\land\mbstt{req}(rel)=req\land
  \mbstt{node}(cap)\ne\mbstt{node}(req)$.
\item \stt{getHostedOnRQOfND} (categorized as (3))\\
 Operator used as \stt{getHostedOnRQOfND($setRQ$,$node$)} which returns
 the {\tt hostedOn} requirement in $setRQ$ whose parent is $node$.
\item \stt{getHostedOnRQsOfNDInStates} (categorized as (3))\\
 Operator used as
 \stt{getHostedOnRQsOfNDInStates($setRQ$,$node$,$setlRQ$)} which
 returns the set of {\tt hostedOn} requirements in $setRQ$ whose
 parent is $node$ and whose local state is in $setlRQ$.
\item \stt{VMOfND} (categorized as (3))\\
 Operator used as \stt{VMOfND($node$,$setND$,$setCP$,$setRQ$,$setRL$)}
 which returns the {\tt VM} node which hosts $node$; precisely, the
 operator recursively traverses {\tt hostedOn} requirements,
 relationships, and capabilities starting from $node$ and returns the
 first found {\tt VM} node including $node$ itself.
\item \stt{VMOfCP} (categorized as (3))\\
 Operator used as \stt{VMOfCP($cap$,$setND$,$setCP$,$setRQ$,$setRL$)}
 which returns the {\tt VM} node which hosts the parent node of $cap$.
\item \stt{VMOfRQ} (categorized as (3))\\
 Operator used as \stt{VMOfRQ($req$,$setND$,$setCP$,$setRQ$,$setRL$)}
 which returns the {\tt VM} node\\ which hosts the parent node of $req$.
\item \stt{allRLHoldLocality} (categorized as (3))\\ 
  Predicate used as
  \stt{allRLHoldLocality($setRL$,$setND$,$setCP$,$setRQ$)} which holds
  iff every relationship included in $setRL$ satisfies the locality
  constraint, which means that if the type of a relationship is local,
  it should be between a capability and a requirement of the nodes
  hosted on the same virtual machine, while if the type is not local
  (i.e.\ remote), it should be between a capability and a requirement
  of the nodes hosted on the different virtual machines.
\item \stt{allNDHaveAtMostOneHost} (categorized as (3))\\ 
  Predicate used as \stt{allNDHaveAtMostOneHost($setND$,$setRQ$)}
  which holds iff every node included in $setND$ has 0 or 1 {\tt
    hostedOn} requirement included in $setRQ$.
\item \stt{ifOpenMsgThenCPInStates} (categorized as (1))\\ 
  Predicate used as
  \stt{ifOpenMsgThenCPInStates($pool$,$setCP$,$setlCP$)} which holds
  iff every open message included in $pool$ has the corresponding
  capability which is included in $setCP$ and whose local state is in
  $setlCP$;\\ $~~~~\forall msg\in pool:(isOpen(msg)\ra\\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(\exists cap\in setCP:
  cap(msg)=cap\land \mbstt{state}(cap)\in setlCP))$.
\item \stt{ifAvailableMsgThenCPInStates} (categorized as (1))\\ 
  Predicate used as
  \stt{ifAvailableMsgThenCPInStates($pool$,$setCP$,$setlCP$)} which
  holds iff every available message included in $pool$ has the
  corresponding capability which is included in $setCP$ and whose
  local state is in $setlCP$;\\ $~~~~\forall msg\in
  pool:(isAvail(msg)\ra\\ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(\exists cap\in setCP:
  cap(msg)=cap\land \mbstt{state}(cap)\in setlCP))$.
\item \stt{ifCPInStatesThenRQInStates} (categorized as (2))\\ 
  Predicate used as
  \stt{ifCPInStatesThenRQInStates($setCP$,$setlCP$,$setRQ$,$setlRQ$,$setRL$)}
  \\which holds iff every capability included in $setCP$ whose local
  sate is included in\\ $setlCP$ has the corresponding requirement
  included in $setRQ$ whose local state is in $setlRQ$;\\$~~~~ \forall
  cap\in setCP:(\mbstt{state}(cap)\in
  setlCP\ra\\~~~~~~~~~~~~~~~\exists rel\in setRL, req\in
  setRQ:\\ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  (\mbstt{cap}(rel)=cap\land\mbstt{req}(rel)=req\land\mbstt{state}(req)\in
  setlRQ))$.
\item \stt{ifConnectsToCPInStatesThenRQInStatesOrOpenMsg} (categorized as (1) (2))\\ 
  Predicate used as
  \stt{ifConnectsToCPInStatesThenRQInStatesOrOpenMsg($setCP$,$setlCP$,\\$setRQ$,$setlRQ$,$setRL$,$pool$)}
  which holds iff every {\tt connectsTo} capability in
  $setCP$ whose local sate is included in $setlCP$ has the
  corresponding requirement included in $setRQ$ whose local state is
  in $setlRQ$ or has the corresponding open message included in
  $pool$;\\$~~~~ \forall cap\in
  setCP:(\mbstt{type}(cap)=\mbstt{hostedOn}\land\mbstt{state}(cap)\in
  setlCP\ra\\~~~~~~~~~~~~~~~(\exists rel\in setRL, req\in
  setRQ:\\ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  (\mbstt{cap}(rel)=cap\land\mbstt{req}(rel)=req\land\mbstt{state}(req)\in
  setlRQ))\lor\\~~~~~~~~~~~~~~~\exists msg\in pool:cap(msg)=cap\land isOpen(msg))$.
\item \stt{ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg} (categorized as (1) (2))\\ 
  Predicate used as
  \stt{ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg($setCP$,\\$setlCP$,$setRQ$,$setlRQ$,$setRL$,$pool$)}
  which holds iff every {\tt connectsTo} capability included in
  $setCP$ whose local sate is included in $setlCP$ has the
  corresponding requirement included in $setRQ$ whose local state is
  in $setlRQ$ or has the corresponding available message included in
  $pool$;\\$~~~~ \forall cap\in
  setCP:(\mbstt{type}(cap)=\mbstt{hostedOn}\land\mbstt{state}(cap)\in
  setlCP\ra\\~~~~~~~~~~~~~~~(\exists rel\in setRL, req\in
  setRQ:\\ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  (\mbstt{cap}(rel)=cap\land\mbstt{req}(rel)=req\land\mbstt{state}(req)\in
  setlRQ))\lor\\~~~~~~~~~~~~~~~\exists msg\in pool:cap(msg)=cap\land isAvail(msg))$.
\end{itemize}

%% ===============================================================
\section{Behavior Model of TOSCA Templates}
\label{sec:TOSCAbehavior}
%% ===============================================================
The framework models the behavior of an automated system operation as a state
machine in which a set of transition rules of global states specifies the
behavior. As described in Section~\ref{sec:TOSCA}, the behavior of a
topology of TOSCA is decided by the behavior of types of nodes and
relationships included in the topology. Here, we propose to model the
behavior of a type as a set of transition rules each of which is
called an {\it invocation rule} and specifies when a type operation can
be invoked and how it changes the local state of a node or
relationship of the type.

As described in Section \ref{sec:TOSCA}, type operations and their
invocation rules should be defined by type architects. When an
application architect defines a topology, the set of all invocation
rules of included node/relationship types collectively composes a
state machine which specifies the whole behavior of the topology.

In the example of Fig.~\ref{fig:exampletopology}, we assume that
behavior of four node types is the same focusing on when a node is
created and started because they are the most essential for setup
operations.

On the other hand, behavior of relationship types usually varies
according to their nature; they may be in the IaaS layer or in the
inside of VM layer, ``local'' or ``remote'', ``immediate'' or
``await''. Three relationship types of this example typically cover
the variation. A HostedOn relationship is one between resources in the
IaaS layer.  It is ``immediate'', i.e.\ it can be established as soon
as the target node is created.  Each of DependsOn and ConnectsTo
relationships is between resources inside of VMs and is ``await'',
i.e.\ it should wait for the target node to be started. A DependsOn
relationship is ``local'' in the same VM, while a ConnectsTo is
``remote'' to a different VM and should use some messages to notice
the states of its capability to its requirement. We assume that a
state of a relationship is a pair of the states of its capability and
requirement in this dissertation for the sake of simplicity. Thereby, an
operation of a relationship type changes the state of its capability
or requirement.

Behavior of these types is depicted in Fig.~\ref{fig:examplesem}.  A
solid arrow represents a state transition of each object caused by a
type operation and a dashed arrow represents an invocation of a type
operation or a message sending.

\begin{figure}
\centering
%%\includegraphics[height=8cm]{examplesem.png}
\includegraphics[height=8cm,natwidth=420,natheight=366]{./exsem.png}
\caption{Typical Behavior of Relationship Types}
\label{fig:examplesem}
\end{figure}

There are twelve invocation rules; two of them are for node
operations, two are for operations of HostedOn relationship, four are
for DependsOn, and four are for ConnectsTo. The followings are
their detailed definitions explained in natural language:
\begin{description}
\item[]Initial States: Every node is initially in a local state named
  as $initial$, every capability of the node is $closed$, and every
  requirement is $unbound$.
\item[] Invocation Rule of Node Type Operations:
  \begin{itemize}
  \item $CREATE$ operation can be invoked if all of the HostedOn
    requirements of the node are $ready$ and changes the local state of the node from
    $initial$ to $created$.
  \item $START$ operation can be invoked if all of the requirements
    are $ready$ and changes the local state from $created$ to $started$.
  \end{itemize}
\item[] Invocation Rule of Operations of HostedOn Relationship Type:
  \begin{itemize}
  \item $CAPAVAILABLE$ operation can be invoked if the target node is
    already created, i.e.\ $created$ or $started$ and changes the local state
    of its capability from $closed$ to $available$.
  \item $REQREADY$ operation can be invoked if its capability is
    $available$ and changes the local state of the requirement from $unbound$
    to $ready$.
  \end{itemize}
\item[] Invocation Rule of Operations of DependsOn Relationship Type:
  \begin{itemize}
  \item $CAPOPEN$ operation can be invoked if the target node is
    already created. It changes the local state of its capability from
    $closed$ to $open$.
  \item $CAPAVAILABLE$ operation can be invoked if the target node is
    $started$ and changes the local state of its capability from
    $open$ to $available$.
  \item $REQWAITING$ operation can be invoked if its capability is already
    activated, i.e.\ $open$ or $available$, and the source node is
    $created$. It changes the local state of its requirement from
    $unbound$ to $waiting$.
  \item $REQREADY$ operation can be invoked if its capability is
    $available$ and changes the local state of its requirement from
    $waiting$ to $ready$.
  \end{itemize}
\item[] Invocation Rule Operations of ConnectsTo Relationship Type:
  \begin{itemize}
  \item $CAPOPEN$ operation can be invoked if the target node is
    already created. It changes the local state of its capability from
    $closed$ to $open$ and also issues an open message of the
    capability to the message pool.
  \item $CAPAVAILABLE$ operation can be invoked if the target node is
    $started$. It changes the local state of its capability from $open$ to
    $available$ and also issues an available message of the capability
    to the message pool.
  \item $REQWAITING$ operation can be invoked if it finds an open
    message of its capability and the source node is $created$. It
    changes the local state of its requirement from $unbound$ to $waiting$.
  \item $REQREADY$ operation can be invoked if it finds an available
    message of its capability and changes the local state of its requirement from
    $waiting$ to $ready$.
  \end{itemize}
\end{description}

%% ===============================================================
\subsection{Representation of the Example Behavior Model}
%% ===============================================================
Each of twelve rules explained in English above is more formally
represented by a transition rule of \cafeobj as follows:
%% =======================================================================
\small
\begin{verbatim}
  module! STATERules {
    protecting(STATEfuns)
  
    -- Variables
    var TND : NDType
    vars IDND IDND1 IDND2 : NDID 
    var IDCP : CPID
    var IDRQ : RQID
    var IDRL : RLID
    var SetND : SetOfNode
    var SetCP : SetOfCapability
    var SetRQ : SetOfRequirement
    var SetRL : SetOfRelationship
    var SCP : CPState
    var MP : PoolOfMsg
  
    -- CREATE Operation for Node Type
    ctrans [R01]:
       < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
    => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
    if allHostedOnRQOfNDInStates(SetRQ,IDND,ready) .
  
    -- START Operation for Node Type
    ctrans [R02]:
       < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
    => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
    if allRQOfNDInStates(SetRQ,IDND,ready) .
  
    -- CAPAVAILABLE Operation for HostedOn Relationship Type
    ctrans [R03]:
       < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
    => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
    if isCreated(state(getNode(SetND,IDND))) .
  
    -- REQREADY Operation for HostedOn Relationship Type
    trans [R04]:
       < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
                (req(hostedOn,IDRQ,unbound,IDND2) SetRQ),
                (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
    => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
                (req(hostedOn,IDRQ,ready,  IDND2) SetRQ),
                (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
  
    -- CAPOPEN Operation for DependsOn Relationship Type
    ctrans [R05]:
       < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
    => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
    if isCreated(state(getNode(SetND,IDND))) .
  
    -- CAPAVAILABLE Operation for DependsOn Relationship Type
    ctrans [R06]:
       < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
    => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
    if state(getNode(SetND,IDND)) = started .
  
    -- REQWAITING Operation for DependsOn Relationship Type
    ctrans [R07]:
       < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
                (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
                (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
    => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
                (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
                (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
    if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
  
    -- REQREADY Operation for DependsOn Relationship Type
    trans [R08]:
       < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
                (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
                (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
    => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
                (req(dependsOn,IDRQ,ready,  IDND2) SetRQ),
                (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
  
    -- CAPOPEN Operation for ConnectsTo Relationship Type
    ctrans [R09]:
       < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP),
         SetRQ, SetRL, MP >
    => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP),
         SetRQ, SetRL, (opMsg(IDCP) MP) >
    if isCreated(state(getNode(SetND,IDND))) .
  
    -- CAPAVAILABLE Operation for ConnectsTo Relationship Type
    ctrans [R10]:
       < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP),
         SetRQ, SetRL, MP >
    => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP),
         SetRQ, SetRL, (avMsg(IDCP) MP) >
    if state(getNode(SetND,IDND)) = started .
  
    -- REQWAITING Operation for ConnectsTo Relationship Type
    ctrans [R11]:
       < SetND, SetCP, 
         (req(connectsTo,IDRQ,unbound,IDND) SetRQ),
         (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
         (opMsg(IDCP) MP) >
    => < SetND, SetCP, 
         (req(connectsTo,IDRQ,waiting,IDND) SetRQ),
         (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
    if state(getNode(SetND,IDND)) = created .
  
    -- REQREADY Operation for ConnectsTo Relationship Type
    trans [R12]:
       < SetND, SetCP, 
         (req(connectsTo,IDRQ,waiting,IDND) SetRQ),
         (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
         (avMsg(IDCP) MP) >
    => < SetND, SetCP, 
         (req(connectsTo,IDRQ,ready,  IDND) SetRQ),
         (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
  }
\end{verbatim}
\normalsize
%% =======================================================================

%% ===============================================================
\section{Verification of TOSCA Templates}
\label{sec:TOSCAverification}
%% ===============================================================
This section presents the verification of the liveness property of
setup operations of the TOSCA models consisting of four node types,
three relationship types, and twelve transition rules. As described in
Chapter~\ref{chap:verification}, reachability of setup operations of
cloud systems is formalized as ($init~\mbstt{leads-to}~final$) and
there are six sufficient conditions for it.

%% ===============================================================
\subsection{Definition of Predicates}
\label{sec:TOSCAsupport}
%% ===============================================================
\noindent{\bf Step 0-1:} Define $init$ and $final$. \\
The initial and final states of the TOSCA models are represented in
\cafeobj as follows:
%% =======================================================================
\small
\begin{verbatim}
  module! STATEfuns {
    protecting(STATE)
    ...
    -- Many operator definitions explained in Section 7.1.1
    ..
    var SetND : SetOfNode
    var SetCP : SetOfCapability
    var SetRQ : SetOfRequirement
    var SetRL : SetOfRelationship
    var MP : PoolOfMsg
    var S : State
  
    pred init : State
    eq init(< SetND,SetCP,SetRQ,SetRL,MP >)
       = not (SetND = empND) and (MP = empMsg) and
         wfs(< SetND,SetCP,SetRQ,SetRL,MP >) and
         noNDCycle(< SetND,SetCP,SetRQ,SetRL,MP >) and
         allNDInStates(SetND,initial) and 
         allCPInStates(SetCP,closed) and 
         allRQInStates(SetRQ,unbound) .
  
    pred final : State
    eq final(< SetND,SetCP,SetRQ,SetRL,MP >)
       = allNDInStates(SetND,started) .
  
    pred wfs : State
    eq wfs(S)
       = wfs-uniqND(S) and wfs-uniqCP(S) and 
         wfs-uniqRQ(S) and wfs-uniqRL(S) and
         wfs-allCPHaveND(S) and wfs-allRQHaveND(S) and 
         wfs-allCPHaveRL(S) and wfs-allRQHaveRL(S) and 
         wfs-allRLHaveCP(S) and wfs-allRLHaveRQ(S) and 
         wfs-allRLHaveSameTypeCPRQ(S) and
         wfs-allRLNotInSameND(S) and
         wfs-allRLHoldLocality(S) and
         wfs-allNDHaveAtMostOneHost(S) .
  
    pred wfs-uniqND : State
    eq wfs-uniqND(< SetND,SetCP,SetRQ,SetRL,MP >)
       = uniqND(SetND) .
  ...
  -- Similar fourteen definitions of wfs-*.  
  ...
  }
\end{verbatim}
\normalsize
%% =======================================================================

As described in Section~\ref{sec:cyclelemma}, we need to define
operators {\tt DDSC} and {\tt getAllObjInState} in order to use the
Cyclic Dependency Lemma in the
verification. Section~\ref{sec:cyclelemma} also describes two
techniques to prove the invariant property of $noCycle(X,S)$. One is
to design each transition rule to decrease dependencies between
objects when it is applied. Section~\ref{sec:invariant} shows example
proofs using this technique.

Another technique used in this chapter is to design the system having
a simpler constraint where some relationship between objects have no
cyclic chains. Recalling Lemma~\ref{lemma:simplerel}, we can define
{\tt DDSC} to implement some simpler relationship $r$ instead of the
true $\mathit{DDS_C}$ and use {\tt noCycle} defined by using $r$ instead of the true
$noCycle_c$. Module {\tt STATECyclefuns} defines an example of such
{\tt DDSC}:
%% =======================================================================
\small
\begin{verbatim}
  module! STATECyclefuns {
    protecting(UtilFuns)
  
    var ND : Node
    var SetND : SetOfNode
    var SetCP : SetOfCapability
    var SetRQ : SetOfRequirement
    var SetRL : SetOfRelationship
    var MP : PoolOfMsg
  
    op getAllNDInState : State -> SetOfNode
    eq getAllNDInState(< SetND,SetCP,SetRQ,SetRL,MP >) = SetND .
  
    op DDSC : Node State -> SetOfNode
    eq DDSC(ND,< SetND,SetCP,SetRQ,SetRL,MP >)
    eq DDSC(ND,< SetND,SetCP,SetRQ,SetRL,MP >)
      = getNDsOfCPs(SetND,
                    getCPsOfRLs(SetCP,
                                getRLsOfRQs(SetRL,
                                            getRQsOfND(SetRQ,ND)))) .
  }
\end{verbatim}
\normalsize
%% =======================================================================
Since this {\tt DDSC} firstly finds the corresponding requirements of
the given node, then finds the corresponding capabilities of the
requirements, and finally finds and returns the parents of the
capabilities, the true $\mathit{DDS_C}$ is obviously a subset of this {\tt
  DDSC}.  Moreover this {\tt DDSC} does not refer local states of
objects and twelve transition rules of the example behavior model
never change links of objects. It means that \stt{DDSC(X,$S$)} for any
reachable global state $S$ from an initial state $\mathit{S_0}$ is the same as
\stt{DDS(X,$\mathit{S_0}$)} and {\tt noCycle} defined by using {\tt DDSC} is an
invariant. {\tt noCycle} can be defined using template module {\tt CYCLEPRED}
as follows:

%% =======================================================================
\small
\begin{verbatim}
  module! STATEfuns {
    protecting(STATE)
    ... 
    -- Other definitions explained above.
    ... 
    extending(CYCLEPRED(
       STATECyclefuns {sort Object -> Node,
                       sort SetOfObject -> SetOfNode,
                       op empObj -> empND,
                       op getAllObjInState -> getAllNDInState})
       * {op noCycle -> noNDCycle}
       )
  }
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 0-2:} Define $cont$.
\noindent{\bf Step 0-3:} Define $m$.
%% =======================================================================
\small
\begin{verbatim}
  module! ProofBase {
    protecting(STATERules)
    vars S SS : State
    eq cont(S) = (S =(*,1)=>+ SS) .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 0-3:} Define $m$.
%% =======================================================================
\small
\begin{verbatim}
    var SetND : SetOfNode
    var SetCP : SetOfCapability
    var SetRQ : SetOfRequirement
    var SetRL : SetOfRelationship
    var MP : PoolOfMsg
    op m : State -> Nat
    eq m(< SetND,SetCP,SetRQ,SetRL,MP >)
       = (#NodeInStates(initial,SetND) * 2)
       + (#NodeInStates(created,SetND) * 1)
       + (#NodeInStates(started,SetND) * 0)
       + (#CapabilityInStates(closed,   SetCP) * 2)
       + (#CapabilityInStates(open,     SetCP) * 1)
       + (#CapabilityInStates(available,SetCP) * 0)
       + (#RequirementInStates(unbound,SetRQ) * 2)
       + (#RequirementInStates(waiting,SetRQ) * 1)
       + (#RequirementInStates(ready,  SetRQ) * 0) .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 0-4:} Define $inv$. 
%% =======================================================================
\small
\begin{verbatim}
  var SetND : SetOfNode
  var SetCP : SetOfCapability
  var SetRQ : SetOfRequirement
  var SetRL : SetOfRelationship
  var MP : PoolOfMsg
  var S : State

  pred inv-ifNDInitialThenRQUnboundReady : State
  eq inv-ifNDInitialThenRQUnboundReady(< SetND,SetCP,SetRQ,SetRL,MP >)
     = ifNDInStatesThenRQInStates(SetND,initial,SetRQ,(unbound ready)) .
  ...
  -- Many similar definitions of invariants.
  -- 3 invariants are defined using predefined predicates.
  -- 9 invariants are defined using problem specific predicates.
  ...

  pred inv : State

  -- wfs-*:
  ceq inv(S) = false if not wfs-uniqND(S) .
  ...
  -- Similar fourteen definitions for wfs-*.  
  ...

  -- inv-*:
  ceq inv(S) = false if not inv-ifNDInitialThenRQUnboundReady(S) .
  ...
  -- Similar eleven definitions for inv-*.  
  ...

\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 0-5:} Prepare for using the Cyclic Dependency
Lemma. \\
For the CloudFormation example, the Cyclic Dependency Lemma is
required to use for only one transition rule, {\tt R01}. For
the TOSCA example, however, there are two transition rules, {\tt R01} and {\tt
  R02} which cause cyclic situations in the verification. Thus, we
need to define two lemmas in advance.  One of them means that there is
a contradiction when $\mathit{DDS_C}$ of the specified {\tt initial} resource
includes any {\tt initial} resources.  Another means that there is a
contradiction when $\mathit{DDS_C}$ of the specified {\tt created} resource
includes any {\tt created} resources.  They are defined as the
following two conditional equations:
%% =======================================================================
\small
\begin{verbatim}
  ceq [CycleR01 :nonexec]: 
     true = false
     if someNDInStates(DDSC(node(T:NDType,I:NDID,initial),S:State),initial) .

  ceq [CycleR02 :nonexec]: 
     true = false
     if someNDInStates(DDSC(node(T:NDType,I:NDID,created),S:State),created) .

\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 0-6:} Prepare proof constants.
%% =======================================================================
\small
\begin{verbatim}
    ops idND idND' idND1 idND2 idND3 : -> NDIDLt
    ops idCP idCP' idCP1 idCP2 idCP3 : -> CPIDLt
    ops idRQ idRQ' idRQ1 idRQ2 idRQ3 : -> RQIDLt
    ops idRL idRL' idRL1 idRL2 idRL3 : -> RLIDLt
    ops sND sND' sND'' sND''' : -> SetOfNode
    ops sCP sCP' sCP'' sCP''' : -> SetOfCapability
    ops sRQ sRQ' sRQ'' sRQ''' : -> SetOfRequirement
    ops sRL sRL' sRL'' sRL''' : -> SetOfRelationship
    ops tnd tnd' tnd'' tnd''' : -> NDType
    ops trl trl' trl'' trl''' : -> RLType
    ops snd snd' snd'' : -> NDState
    ops scp scp' scp'' : -> CPState
    ops srq srq' srq'' : -> RQState
    op stND : -> SetOfNDState
    op stCP : -> SetOfCPState
    op stRQ : -> SetOfRQState
    ops mp mp' : -> PoolOfMsg
    op msg : -> Msg
  }
\end{verbatim}
\normalsize
%% =======================================================================

%% ===============================================================
\subsection{Lemmas for Using Cyclic Dependency Lemma}
\label{sec:TOSCAcont}
%% ===============================================================
As described in Section~\ref{sec:initialcont}, it is wise to define
lemmas for using the Cyclic Dependency Lemma and use them in the
similar cases. For this TOSCA example, two similar lemmas are
required. One lemma claims that if there is an {\tt initial} node in a
reachable global state then there exists a transition rule applicable to the
global state. Here we refer to it as the {\it initial-cont} lemma. It
can be proved as follows:\\

\noindent{\bf Step 1-0:} Define a predicate to be proved.\\
Module {\tt ProofInitialCont} defines the predicate as {\tt invcont}.
Note that we can only consider the case where \stt{inv(S)} holds
because {\tt S} is a reachable global state.
%% =======================================================================
\small
\begin{verbatim}
  module! ProofInitialCont {
    protecting(ProofBase)
  
    vars B1 B2 : Bool
  
    pred (_when _) : Bool Bool { prec: 64 r-assoc }
    eq (B1 when B2)
       = B2 implies B1 .
  
    var S: State
  
    pred invcont : State
    eq invcont(S) 
      = cont(S) = true
      when inv(S) .
  }
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 1-1:} Begin with the most general case.
%% =======================================================================
\small
\begin{verbatim}
  select ProofInitialCont .
  :goal {
    eq invcont(< (node(tnd, idND, initial) sND), sCP, sRQ, sRL, mp >) 
       = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 1-2:} Consider which rule is applied to the 
global state in the current case. \\
The applicable rule may be {\tt R01} because the global state includes
an {\tt initial} node.\\

\noindent{\bf Step 1-3:} Split the current case into cases which
collectively cover the current case and one of which matches to LHS of
the current rule. \\ 
The global state already matches to LHS of {\tt RO1}.\\

\noindent{\bf Step 1-4:} Split the current case into cases where
the condition of the current rule does or does not hold.
%% =======================================================================
\small
\begin{verbatim}
  :csp { 
    eq allHostedOnRQOfNDInStates(sRQ,idND,ready) = true .
    eq sRQ = (req(hostedOn,idRQ,unbound,idND) sRQ') .
    eq sRQ = (req(hostedOn,idRQ,waiting,idND) sRQ') .
  }
  -- Case 1: When all of the hostedOn requirements are ready:
  :apply (rd) -- 1
  -- Case 2: When there is an unbound hostedOn requirement of the node:
  ... -- More consideration needed.
  -- Case 3: When there is a waiting hostedOn requirement of the node:
  :apply (rd) -- 3
\end{verbatim}
\normalsize
%% =======================================================================
Only Case 2 remains unproved and it then becomes the current case.\\

\noindent{\bf Step 1-2:} Consider which rule is applied to the 
global state in the current case. \\
The applicable rule may be {\tt R04} because the global state in Case
2 includes an {\tt unbound hostedOn} requirement.\\

\noindent{\bf Step 1-5:} When there is a dangling link, split the case
into cases where the linked object does or does not exist.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2: When there is an unbound hostedOn requirement of the node:
  :csp {
    eq onlyOneRLOfRQ(sRL,idRQ) = false .
    eq sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL') .
  }
  -- Case 2-1: When the relationship of requirement idRQ does not exist:
  :apply (rd) -- 2-1
  -- Case 2-2: When the relationship of requirement idRQ exists:
  :csp {
    eq existCP(sCP,idCP) = false .
    eq sCP = (cap(hostedOn,idCP,scp,idND') sCP') .
  }
  -- Case 2-2-1: When the capability of the relationship does not exist:
  :apply (rd) -- 2-2-1
  -- Case 2-2-2: When the capability of the relationship exists:
  :ctf {
    eq idND' = idND .
  }
  -- Case 2-2-2-1: When the node of capability idCP is
  --                              the same of requiement idRQ:
  :apply (rd) -- 2-2-2-1
  -- Case 2-2-2-2: When the node of capability idCP is not
  --                              the same of requiement idRQ:
  ... -- More consideration needed.
\end{verbatim}
\normalsize
%% =======================================================================
Only Case 2-2-2-2 remains unproved.\\

\noindent{\bf Step 1-3:} Split the current case into cases which
collectively cover the current case and one of which matches to LHS of
the current rule. 
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-2-2-2: When the node of capability idCP is not
  --                              the same of requiement idRQ:
  :csp {
    eq scp = closed .
    eq scp = open .
    eq scp = available .
  }
  -- Case 2-2-2-2-1: When the capability of idCP is closed:
  ... -- More consideration needed.
  -- Case 2-2-2-2-2: When the capability of idCP is open:
  :apply (rd) -- 2-2-2-2-2
  -- Case 2-2-2-2-2: When the capability of idCP is avialable:
  :apply (rd) -- 2-2-2-2-3
\end{verbatim}
\normalsize
%% =======================================================================
Only Case 2-2-2-2-1 remains unproved.\\

\noindent{\bf Step 1-2:} Consider which rule is applied to the 
global state in the current case. \\
The applicable rule may be {\tt R03} because the global state in Case
2-2-2-2-1 includes an {\tt unbound hostedOn} requirement.\\

\noindent{\bf Step 1-5:} When there is a dangling link, split the case
into cases where the linked object does or does not exist.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-2-2-2-1: When the capability of idCP is closed:
  :csp {
    eq existND(sND,idND') = false .
    eq sND = (node(tnd',idND',snd') sND') .
  }
  -- Case 2-2-2-2-1-1: When the node of the capability of idCP does not exist:
  :apply (rd) -- 2-2-2-2-1-1
  -- Case 2-2-2-2-1-2: When the node of the capability of idCP exists:
  ... -- More consideration needed.
\end{verbatim}
\normalsize
%% =======================================================================
Only Case 2-2-2-2-1-2 remains unproved.\\

\noindent{\bf Step 1-4:} Split the current case into cases where
the condition of the current rule does or does not hold.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-2-2-2-1-1: When the node of the capability of idCP does not exist:
  :csp {
    eq snd' = initial .
    eq snd' = created .
    eq snd' = started .
  }
  -- Case 2-2-2-2-1-2-1: When the node of idND' is initial:
  ... -- More consideration needed.
  -- Case 2-2-2-2-1-2-2: When the node of idND' is created:
  :apply (rd) -- 2-2-2-2-1-2-2
  -- Case 2-2-2-2-1-2-3: When the node of idND' is started:
  :apply (rd) -- 2-2-2-2-1-2-3
\end{verbatim}
\normalsize
%% =======================================================================
Only Case 2-2-2-2-1-2-1 remains unproved.\\

\noindent{\bf Step 1-6:} When falling in a cyclic situation, use the
Cyclic Dependency Lemma. 
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-2-2-2-1-2-1: When the node of idND' is initial:
  :init [CycleR01] by {
    T:NDType <- tnd;
    I:NDID   <- idND;
    S:State  <- < (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >;
  }
  :apply (rd) -- 2-2-2-2-1-2-1
\end{verbatim}
\normalsize
%% =======================================================================
Thus, all of the cases are successfully proved and we can assume that $cont(S)$
holds for any reachable global state $S$ which include an {\tt initial} node.

Another similar lemma claims that if there is a {\tt created} node in
a global state then there exists a transition rule applicable to the
global state. Here we refer to it as the {\it created-cont} lemma. It
can be proved as follows:\\

\noindent{\bf Step 1-0:} Define a predicate to be proved.\\
Module {\tt ProofCreatedCont} imports predicate {\tt invcont} from
module {\tt ProofInitialCont} and additionally introduces the
initial-cont lemma proved just above because the proof of this lemma
uses it. Note that the {\tt when} clause is omitted from the
initial-cont lemma because \stt{inv(S)} holds for any reachable global
state {\tt S}.
%% =======================================================================
\small
\begin{verbatim}
  module! ProofCreatedCont {
    protecting(ProofInitialCont)

    var T : NDType
    var I : NDID
    var SetND : SetOfNode
    var SetCP : SetOfCapability
    var SetRQ : SetOfRequirement
    var SetRL : SetOfRelationship
    var M : PoolOfMsg
    -- This proof uses the initial-cont lemma.
    eq cont(< (node(T, I, initial) SetND), 
               SetCP, SetRQ, SetRL, M >) = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 1-1:} Begin with the most general case.
%% =======================================================================
\small
\begin{verbatim}
  select ProofCreatedCont .
  :goal {
    eq invcont(< (node(tnd, idND, created) sND), sCP, sRQ, sRL, mp >)
       = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 1-2:} Consider which rule is applied to the 
global state in the current case. \\
The applicable rule may be {\tt R02} because the global state includes
a {\tt created} node.\\

\noindent{\bf Step 1-3:} Split the current case into cases which
collectively cover the current case and one of which matches to LHS of
the current rule. \\ 
The global state already matches to LHS of {\tt RO2}.\\

\noindent{\bf Step 1-4:} Split the current case into cases where
the condition of the current rule does or does not hold.
%% =======================================================================
\small
\begin{verbatim}
  :csp { 
    eq allRQOfNDInStates(sRQ,idND,ready) = true .
    eq sRQ = (req(trl,idRQ,unbound,idND) sRQ') .
    eq sRQ = (req(trl,idRQ,waiting,idND) sRQ') .
  }
  -- Case 1: When all of the requirements are ready:
  :apply (rd) -- 1
  -- Case 2: When there is an unbound requirement of node idND:
  ... -- More consideration needed.
  -- Case 3: When there is a waiting requirement of node idND:
  ... -- More consideration needed.
\end{verbatim}
\normalsize
%% =======================================================================
Both Case 2 and 3 remain unproved. Let Case 2 be the current state.\\

\noindent{\bf Step 1-2:} Consider which rule is applied to the 
global state in the current case. \\
The applicable rule may be {\tt R04}, {\tt R07}, or {\tt R11} because
the global state in Case 2 includes an {\tt unbound} requirement and
the applicable rule depends on its type.\\

\noindent{\bf Step 1-3:} Split the current case into cases which
collectively cover the current case and one of which matches to LHS of
the current rule. \\ 
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2: When there is an unbound requirement of node idND:
  :csp {
    eq trl = hostedOn .
    eq trl = dependsOn .
    eq trl = connectsTo .
  }
  -- Case 2-1: When the type of requirement idRQ is hostedOn:
  :apply (rd) -- 2-1
  -- Case 2-2: When the type of requirement idRQ is dependsOn:
  ... -- More consideration needed.
  -- Case 2-3: When the type of requirement idRQ is connectsTo:
  ... -- More consideration needed.
\end{verbatim}
\normalsize
%% =======================================================================
Case 2-1 is not a reachable global state because a node never
becomes {\tt created} when one of its {\tt hostedOn} requirement is
{\tt unbound}, which makes \stt{inv(S)} reduce to false.
Thus, Case 2-2 and 2-3 remains unproved. Let Case 2-2 be the current case.\\

\noindent{\bf Step 1-5:} When there is a dangling link, split the case
into cases where the linked object does or does not exist.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-2: When the type of requirement idRQ is dependsOn:
  :csp {
    eq onlyOneRLOfRQ(sRL,idRQ) = false .
    eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  }
  -- Case 2-2-1: When the relationship of requirement idRQ does not exist:
  :apply (rd) -- 2-2-1
  -- Case 2-2-2: When the relationship of requirement idRQ exists:
  :csp {
    eq existCP(sCP,idCP) = false .
    eq sCP = (cap(dependsOn,idCP,scp,idND') sCP') .
  }
  -- Case 2-2-2-1: When the capability of the relationship does not exist:
  :apply (rd) -- 2-2-2-1
  -- Case 2-2-2-2: When the capability of the relationship exists:
  :ctf {
    eq idND' = idND .
  }
  -- Case 2-2-2-2-1: When the node of capability idCP is
  --                              the same of requiement idRQ:
  :apply (rd) -- 2-2-2-2-1
  -- Case 2-2-2-2-2: When the node of capability idCP is not
  --                              the same of requiement idRQ:
  ... -- More consideration needed.
\end{verbatim}
\normalsize
%% =======================================================================
\noindent{\bf Step 1-3:} Split the current case into cases which
collectively cover the current case and one of which matches to LHS of
the current rule. 
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-2-2-2-2: When the node of capability idCP is not
  --                              the same of requiement idRQ:
  :csp {
    eq scp = closed .
    eq scp = open .
    eq scp = available .
  }
  -- Case 2-2-2-2-2-1: When capability idCP is closed:
  ... -- More consideration needed.
  -- Case 2-2-2-2-2-2: When capability idCP is open:
  :apply (rd) -- 2-2-2-2-2-2
  -- Case 2-2-2-2-2-3: When capability idCP is available:
  :apply (rd) -- 2-2-2-2-2-3
\end{verbatim}
\normalsize
%% =======================================================================
Case 2-2-2-2-2-2 and 2-2-2-2-2-2 are proved because {\tt R07} is
applicable.  Thus, only Case 2-2-2-2-2-1 remains unproved.\\

\noindent{\bf Step 1-2:} Consider which rule is applied to the 
global state in the current case. \\
The applicable rule may be {\tt R05} because the global state in Case
2-2-2-2-2-1 includes an {\tt closed dependsOn} capability.\\

\noindent{\bf Step 1-5:} When there is a dangling link, split the case
into cases where the linked object does or does not exist.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-2-2-2-2-1: When capability idCP is closed:
  :csp {
    eq existND(sND,idND') = false .
    eq sND = (node(tnd',idND',snd') sND') .
  }
  -- Case 2-2-2-2-2-1-1: When the node of capability idCP does not exist:
  :apply (rd) -- 2-2-2-2-2-1-1
  -- Case 2-2-2-2-2-1-2: When the node of capability idCP exists:
  ... -- More consideration needed.
\end{verbatim}
\normalsize
%% =======================================================================
Case 2-2-2-2-2-1-2 remains unproved.\\

\noindent{\bf Step 1-4:} Split the current case into cases where
the condition of the current rule does or does not hold.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-2-2-2-2-1-2: When the node of capability idCP exists:
  :csp {
    eq snd' = initial .
    eq snd' = created .
    eq snd' = started .
  }
  -- Case 2-2-2-2-2-1-2-1: When node idND' is initial:
  :apply (rd) -- 2-2-2-2-2-1-2-1
  -- Case 2-2-2-2-2-1-2-2: When node idND' is created:
  :apply (rd) -- 2-2-2-2-2-1-2-2
  -- Case 2-2-2-2-2-1-2-3: When node idND' is started:
  :apply (rd) -- 2-2-2-2-2-1-2-3
\end{verbatim}
\normalsize
%% =======================================================================
Note that Case 2-2-2-2-2-1-2-1 is proved by the initial-cont lemma,
Case 2-2-2-2-2-1-2-2 and 2-2-2-2-2-1-2-3 are proved because {\tt R05}
is applicable. Thus, Case 2-2 is proved and Case 2-3 reminds unprove.
Case 2-3 is split into totally 21 cases all
of which are proved similarly as split cases of Case 2-2.

Similarly Case 3 is split into totally 33 cases two of which require
to use the Cyclic Dependency Lemma for rule {\tt R02}. One of them
is the following Case 3-2-2-2-2-2-2-2:
%% =======================================================================
\small
\begin{verbatim}
  -- Case 3: When there is a waiting requirement of node idND:
  ...
  -- Case splitting proceeds similarly as Case 2.
  ...
  -- Case 3-2-2-2-2-2-2-2: When the node of idND' is created:
  -- The global state in this case is
  -- < (node(tnd,idND,created) node(tnd',idND',created) sND'),
  --   (cap(dependsOn,idCP,open,idND') sCP'),
  --   (req(dependsOn,idRQ,waiting,idND) sRQ'),
  --   (rel(dependsOn,idRL,idCP,idRQ) sRL'),
  --   mp >
  :init [CycleR02] by {
    T:NDType <- tnd;
    I:NDID   <- idND;
    S:State  <- < (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >;
  }
  :apply (rd) -- 3-2-2-2-2-2-2-2
  ...
\end{verbatim}
\normalsize
%% =======================================================================
In this case, node {\tt idND} is {\tt created} and directly depends on
node {\tt idND'} which is also {\tt created}. The Cyclic Dependency
Lemma claims this global state is not reachable and this case is proved.

Another case is very similar to one above; the relationship type
is not {\tt dependsOn} but {\tt connectsTo} as follows:
%% =======================================================================
\small
\begin{verbatim}
  -- Case 3-3-2-1-2-2-2-2-2: When the node of idND' is created:
  -- The global state in this case is
  -- < (node(tnd, idND, created) node(tnd', idND', created) sND'),
  --   (cap(connectsTo, idCP, open, idND') sCP'),
  --   (req(connectsTo, idRQ, waiting, idND) sRQ'),
  --   (rel(connectsTo, idRL, idCP, idRQ) sRL'),
  --   mp >
  :init [CycleR02] by {
    T:NDType <- tnd;
    I:NDID   <- idND;
    S:State  <- < (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >;
  }
  :apply (rd) -- 3-3-2-1-2-2-2-2-2
  ...
\end{verbatim}
\normalsize
%% =======================================================================

All other cases are successfully proved and we can assume that
$cont(S)$ holds for any reachable global state $S$ which include a
{\tt created} node.

%% ===============================================================
\subsection{Proof of Sufficient Condition~(1)}
\label{sec:TOSCAinitcont}
%% ===============================================================
\noindent{\bf Step 1-0:} Define a predicate to be proved. \\
The proof of condition~(1) requires to use the
initial-cont lemma:
%% =======================================================================
\small
\begin{verbatim}
  module! ProofInitCont {
    protecting(ProofBase)

    var S : State
    var T : NDType
    var I : NDID
    var SetND : SetOfNode
    var SetCP : SetOfCapability
    var SetRQ : SetOfRequirement
    var SetRL : SetOfRelationship
    var M : PoolOfMsg

    -- Predicate to be proved.
    pred initcont : State .
    eq initcont(S) = init(S) implies cont(S) .
  
    -- initial-cont lemma: 
    eq cont(< (node(T, I, initial) SetND), 
               SetCP, SetRQ, SetRL, M >) = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 1-1:} Begin with the most general case.
%% =======================================================================
\small
\begin{verbatim}
  select ProofInitCont .
  :goal {eq initcont(< sND, sCP, sRQ, sRL, mp >) = true .}
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 1-2:} Consider which rule is applied to the 
global state in the current case. \\
The first rule is {\tt R01}. \\

\noindent{\bf Step 1-3:} Split the current case into cases which
collectively cover the current case and one of which matches to LHS of
the current rule. \\
Since LHS of rule {\tt R01} requires the global state to have at least
one {\tt initial} node, the case is split into four more cases, i.e.\ no
node, at least one {\tt initial}, {\tt created}, or {\tt started}
node.
%% =======================================================================
\small
\begin{verbatim}
  :csp { 
    eq sND = empND .
    eq sND = (node(tnd,idND,snd) sND') .
  }
  -- Case 1: When there is no node:
  :apply (rd) -- 1
  -- Case 2: When there is a node:
  -- The state of the node is initial, created, or started.
  :csp { 
    eq snd = initial .
    eq snd = created .
    eq snd = started .
  }
  :apply (rd) -- 2-1
  :apply (rd) -- 2-2
  :apply (rd) -- 2-3
\end{verbatim}
\normalsize
%% =======================================================================
Case 2-1 is proved by the initial-cont lemma. In other cases,
$init(S)$ does not hold for the global state $S$\!. Thus, sufficient
condition~(1) is proved.

%% ===============================================================
\subsection{Proof of Sufficient Condition~(2)}
\label{sec:TOSCAcontcont}
%% ===============================================================
\noindent{\bf Step 2-0:} Define a predicate to be proved. \\ 
The proof of condition~(2) requires to use both of the
initial-cont lemma and the created-cont lemma:
%% =======================================================================
\small
\begin{verbatim}
  module! ProofContCont {
    protecting(ProofBase)
  
    vars S SS : State
    var CC : Bool
    var T : NDType
    var I : NDID
    var SetND : SetOfNode
    var SetCP : SetOfCapability
    var SetRQ : SetOfRequirement
    var SetRL : SetOfRelationship
    var M : PoolOfMsg
  
    -- Predicate to be proved.
    pred ccont : State State
    pred contcont : State
    eq ccont(S,SS)
       = inv(S) and not final(S) implies cont(SS) or final(SS) .
    eq contcont(S)
       = not (S =(*,1)=>+ SS if CC suchThat
              not ((CC implies ccont(S,SS)) == true)
           { true }) .
  
    -- initial-cont lemma: 
    eq cont(< (node(T, I, initial) SetND), 
  	    SetCP, SetRQ, SetRL, M >)
       = true .
    -- created-cont lemma:
    eq cont(< (node(T, I, created) SetND), 
  	    SetCP, SetRQ, SetRL, M >)
       = true .
}
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 2-1:} Begin with the cases each of which matches to
LHS of each rule. \\ 
The followings are cases for twelve transition rules:
%% =======================================================================
\small
\begin{verbatim}
  select ProofContCont .
  -- Goal of Condition (2) for rule R01
  :goal {
    eq contcont(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >)
       = true .
  }
 
  -- Goal of Condition (2) for rule R02
  :goal {
    eq contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >)
       = true .
  }
 
  -- Goal of Condition (2) for rule R03
  :goal {
    eq contcont(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >)
       = true .
  }
 
  -- Goal of Condition (2) for rule R04
  :goal {
    eq contcont(< sND, 
                  (cap(hostedOn,idCP,available,idND) sCP),
                  (req(hostedOn,idRQ,unbound,idND')  sRQ),
                  (rel(hostedOn,idRL,idCP,idRQ)      sRL), mp >)
       = true .
  }
 
  -- Goal of Condition (2) for rule R05
  :goal {
    eq contcont(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >)
       = true .
  }
 
  -- Goal of Condition (2) for rule R06
  :goal {
    eq contcont(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >)
       = true .
  }
 
  -- Goal of Condition (2) for rule R07
  :goal {
    eq contcont(< sND, 
                  (cap(dependsOn,idCP,scp,idND)      sCP), 
                  (req(dependsOn,idRQ,unbound,idND') sRQ), 
                  (rel(dependsOn,idRL,idCP,idRQ)     sRL), mp >)
       = true .
  }
 
  -- Goal of Condition (2) for rule R08
  :goal {
    eq contcont(< sND, 
                  (cap(dependsOn,idCP,available,idND) sCP), 
                  (req(dependsOn,idRQ,waiting,idND')  sRQ), 
                  (rel(dependsOn,idRL,idCP,idRQ)      sRL), mp >)
       = true .
  }
 
  -- Goal of Condition (2) for rule R09
  :goal {
    eq contcont(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >)
       = true .
  }
 
  -- Goal of Condition (2) for rule R10
  :goal {
    eq contcont(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >)
       = true .
  }
 
  -- Goal of Condition (2) for rule R11
  :goal {
    eq contcont(< sND, sCP,
                  (req(connectsTo,idRQ,unbound,idND) sRQ), 
                  (rel(connectsTo,idRL,idCP,idRQ)    sRL), 
                  (opMsg(idCP) mp) >)
       = true .
  }
 
  -- Goal of Condition (2) for rule R12
  :goal {
    eq contcont(< sND, sCP, 
                  (req(connectsTo,idRQ,waiting,idND) sRQ), 
                  (rel(connectsTo,idRL,idCP,idRQ)    sRL),
                  (avMsg(idCP) mp) >)
       = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================

The rest of this section describes the proof of condition~(2)
for rule {\tt R06} as an example.
%% =======================================================================
\small
\begin{verbatim}
  select ProofContCont .
  -- Goal of Condition (2) for rule R06
  :goal {
    eq contcont(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >)
       = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 2-7:} When there is a dangling link, split the
current case into cases where the linked object does or does not
exist.
%% =======================================================================
\small
\begin{verbatim}
  :csp {
    eq existND(sND,idND) = false .
    eq sND = (node(tnd,idND,snd) sND') .
  }
  -- Case 1: The node of capability idCP does not exist:
  :apply (rd) -- 1
  -- Case 2: The node of capability idCP exists:
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 2-2:} Split the current case for a rule into
cases where the condition of the rule does or does not hold.
%% =======================================================================
\small
\begin{verbatim}
  :csp {
    eq snd = initial .
    eq snd = created .
    eq snd = started .
  }
  -- Case 2-1: The node is initial:
  :apply (rd) -- 2-1
  -- Case 2-2: The node is created:
  :apply (rd) -- 2-2
  -- Case 2-3: The node is started:
\end{verbatim}
\normalsize
%% =======================================================================
Note that Case 2-1 and 2-2 are proved by the initial-cont lemma and
the created-cont lemma respectively.\\

\noindent{\bf Step 2-3:} Split the current case into cases where
predicate $final$ does or does not hold in the next state.\\
We know that $final$ never holds in the next state of this case.\\

\noindent{\bf Step 2-4:} Consider which rule can be applied to the next
state. \\
Since the next state in Case 2-3 includes an {\tt available} {\tt
  dependsOn} capability with identifier {\tt idCP}, rule {\tt R08} can
be applied to it.\\

\noindent{\bf Step 2-7:} When there is a dangling link, split the
current case into cases where the linked object does or does not
exist.
%% =======================================================================
\small
\begin{verbatim}
  :csp {
    eq onlyOneRLOfCP(sRL,idCP) = false .
    eq sRL = (rel(trl,idRL,idCP,idRQ) sRL') .
  }
  -- Case 2-3-1: There is not a corresponding relationship:
  :apply (rd) -- 2-3-1
  -- Case 2-3-2: There is a corresponding relationship:
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 2-5:} Split the current case into cases which
collectively cover the current case and the next state of one of the split cases
matches to LHS of the current rule. \\
LHS of rule {\tt R08} requires the type of the corresponding relationship
to be {\tt dependsOn}.
%% =======================================================================
\small
\begin{verbatim}
  :csp {
    eq trl = hostedOn .
    eq trl = dependsOn .
    eq trl = connectsTo .
  }
  -- Case 2-3-2-1: The relationship is hostedOn:
  :apply (rd) -- 2-3-2-1
  -- Case 2-3-2-2: The relationship is dependsOn:
  ... -- More consideration needed.
  -- Case 2-3-2-3: The relationship is connectsTo:
  :apply (rd) -- 2-3-2-3
\end{verbatim}
\normalsize
%% =======================================================================
Only Case 2-3-2-2 remains unproved.\\

\noindent{\bf Step 2-7:} When there is a dangling link, split the
current case into cases where the linked object does or does not
exist.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-3-2-2: The relationship is dependsOn:
  :csp {
    eq existRQ(sRQ,idRQ) = false .
    eq sRQ = (req(trl',idRQ,srq,idND') sRQ') .
  }
  -- Case 2-3-2-2-1: There is not a corresponding requirement:
  :apply (rd) -- 2-3-2-2-1
  -- Case 2-3-2-2-2: There is a corresponding requirement:
  ... -- More consideration needed.
\end{verbatim}
\normalsize
%% =======================================================================
Only Case 2-3-2-2-2 remains unproved.\\

\noindent{\bf Step 2-5:} Split the current case into cases which
collectively cover the current case and the next state of one of the split cases
matches to LHS of the current rule. \\
LHS of rule {\tt R08} requires the type of the corresponding requirement
to be {\tt dependsOn} and the local state of it to be {\tt waiting}.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-3-2-2-2: There is a corresponding requirement:
  :csp {
    eq trl' = hostedOn .
    eq trl' = dependsOn .
    eq trl' = connectsTo .
  }
  -- Case 2-3-2-2-2-1: The requirement is hostedOn:
  :apply (rd) -- 2-3-2-2-2-1
  -- Case 2-3-2-2-2-2: The requirement is dependsOn:
  :csp {
    eq srq = unbound .
    eq srq = waiting .
    eq srq = ready .
  }
  -- Case 2-3-2-2-2-2-1: The requirement is unbound:
  ... -- More consideration needed.
  -- Case 2-3-2-2-2-2-2: The requirement is waiting:
  :apply (rd) -- 2-3-2-2-2-2-2
  -- Case 2-3-2-2-2-2-3: The requirement is ready:
  :apply (rd) -- 2-3-2-2-2-2-3
  -- Case 2-3-2-2-2-3: The requirement is connectsTo:
  :apply (rd) -- 2-3-2-2-2-3
\end{verbatim}
\normalsize
%% =======================================================================
Only Case 2-3-2-2-2-2-1 remains unproved.\\

\noindent{\bf Step 2-4:} Consider which rule can be applied to the next
state. \\
Since the next state in Case 2-3-2-2-2-2-1 includes an {\tt unbound} {\tt
  dependsOn} requirement with identifier {\tt idRQ}, rule {\tt R07} can
be applied to it.\\

\noindent{\bf Step 2-7:} When there is a dangling link, split the
current case into cases where the linked object does or does not
exist.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-3-2-2-2-2-1: The requirement is unbound:
  :csp {
    eq existND(sND',idND') = false .
    eq sND' = (node(tnd',idND',snd') sND'') .
  }
  -- Case 2-3-2-2-2-2-1-1: The node of requirement idRQ does not exist:
  :apply (rd) -- 2-3-2-2-2-2-1-1
  -- Case 2-3-2-2-2-2-1-2: The node of requirement idRQ exists:
  ... -- More consideration needed.
\end{verbatim}
\normalsize
%% =======================================================================
Only Case 2-3-2-2-2-2-1-2 remains unproved.\\

\noindent{\bf Step 2-5:} Split the current case into cases which
collectively cover the current case and the next state of one of the split cases
matches to LHS of the current rule. \\
The global state already matches to LHS of {\tt RO7}.\\

\noindent{\bf Step 2-6:} Split the current case into cases where the
condition of the current rule does or does not hold in the next state.
%% =======================================================================
\small
\begin{verbatim}
  -- Case 2-3-2-2-2-2-1-2: The node of requirement idRQ exists:
  :csp {
    eq snd' = initial .
    eq snd' = created .
    eq snd' = started .
  }
  -- Case 2-3-2-2-2-2-1-2-1: The node is initial:
  :apply (rd) -- 2-3-2-2-2-2-1-2-1
  -- Case 2-3-2-2-2-2-1-2-2: The node is created:
  :apply (rd) -- 2-3-2-2-2-2-1-2-2
  -- Case 2-3-2-2-2-2-1-2-3: The node is started:
  :apply (rd) -- 2-3-2-2-2-2-1-2-3
\end{verbatim}
\normalsize
%% =======================================================================
All of the cases are successfully proved.

%% ===============================================================
\subsection{Proof of Sufficient Condition~(3)}
\label{sec:TOSCAmesmes}
%% ===============================================================
\noindent{\bf Step 3-0:} Use natural number axioms. \\
The framework provides a module, {\tt NATAXIOM}, which defines several
natural number axioms to be used for proof of
condition~(3) and (4).  Module {\tt
  ProofMeasure} should protecting import {\tt NATAXIOM} as well as
{\tt ProofBase}:
%% =======================================================================
\small
\begin{verbatim}
  module! ProofMeasure {
    protecting(ProofBase)
    protecting(NATAXIOM)
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 3-1:} Define a predicate to be proved.
%% =======================================================================
\small
\begin{verbatim}
    vars S SS : State
    var CC : Bool
    var N : Nat
      
    pred mmes : State State .
    eq mmes(S,SS)
       = inv(S) and not final(S) implies m(S) > m(SS) .
    pred mesmes : State .
    eq mesmes(S)
       = not (S =(*,1)=>+ SS if CC suchThat
              not ((CC implies mmes(S,SS)) == true)
              { true }) .
  }
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 3-2:} Begin with the cases each of which matches to
LHS of each rule. \\ 
Here we show the proof of condition~(3) for rule {\tt R06}
as an example:
%% =======================================================================
\small
\begin{verbatim}
  -- Goal of Condition (3) for rule R06
  select ProofMeasure .
  :goal {
    eq mesmes(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >)
       = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 3-3:} Split the current case for a rule into
cases where the condition of the rule does or does not hold. 
%% =======================================================================
\small
\begin{verbatim}
  :ctf {
    eq state(getNode(sND,idND)) = started .
  }
  :apply (rd) -- 1
  :apply (rd) -- 2
\end{verbatim}
\normalsize
%% =======================================================================
Condition~(3) for other rules can be similarly proved.

%% ===============================================================
\subsection{Proof of Sufficient Condition~(4)}
\label{sec:TOSCAmesfinal}
%% ===============================================================
\noindent{\bf Step 4-0:} Use natural number axioms. \\
Module {\tt ProofMesFinal} should protecting import {\tt NATAXIOM} as
well as {\tt ProofBase}:
%% =======================================================================
\small
\begin{verbatim}
  module! ProofMesFinal {
    protecting(ProofBase)
    protecting(NATAXIOM)
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 4-1:} Define a predicate to be proved.
%% =======================================================================
\small
\begin{verbatim}
  var S : State
  pred mesfinal : State .
  eq mesfinal(S)
     = inv(S) and cont(S) and m(S) = 0 implies final(S) .
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 4-2:} Begin with the cases each of which matches to
LHS of each rule. \\ 
Here we show the proof of condition~(3) for rule {\tt R06}
as an example:
%% =======================================================================
\small
\begin{verbatim}
  -- Goal of Condition (3) for rule R06
  select ProofMesFinal .
  :goal {
    eq mesfinal(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >)
       = true .
  }
\end{verbatim}
\normalsize
%% =======================================================================

\noindent{\bf Step 4-3:} Split the current case for a rule into
cases where the condition of the rule does or does not hold. 
%% ===============================================================
\small
\begin{verbatim}
  :ctf {
    eq state(getNode(sND,idND)) = started .
  }
  :apply (rd) -- 1
  :apply (rd) -- 2
\end{verbatim}
\normalsize
%% ===============================================================
Condition~(4) for other rules can be similarly proved.

%% ===============================================================
\section{Evaluation}
\label{sec:evaluation}
%% ===============================================================
Table~\ref{table:goalscases} shows the number of proved goals and
split cases to verify the liveness property of setup operations of the
TOSCA models consisting of four node types, three relationship types,
and twelve transition rules. Condition (1) requires only one goal and
6 cases whereas (2) (3) and (4) require 12 goals each of which
is for each of 12 transition rules. Condition (5) also requires 12
goals for each of 12 invariants and (6) requires 144 goals for
each combination of 12 invariants and 12 rules. We need 25
problem specific lemmas each of which requires one goal.
The verification consists of totally 216 goals which
are split into 948 cases.

\begin{table}[hbtp]
  \caption{Number of goals and cases}
  \label{table:goalscases}
  \centering
  \begin{tabular}{lrlr}
    \hline
      targets & goals  & (1 goal for each of ?) & cases \\
    \hline \hline
    Condition (1)  & 1  & (condition) & 6 \\
    Condition (2)  & 12 & (12 rules) & 115  \\
    Condition (3)  & 12 & (12 rules) & 30 \\
    Condition (4)  & 12 & (12 rules) & 30 \\
    Condition (5)  & 12 & (12 invariants) & 18  \\
    Condition (6)  & 144 & (12 rules $\times$ 12 invariants) & 443  \\
    Lemmas  & 25 & (25 lemmas) & 306  \\
    \hline    \hline
    Total  & 218  & & 948 \\
    \hline
  \end{tabular}
\end{table}

%% ===============================================================
\subsubsection{Rate of Reuse}
%% ===============================================================
Table~\ref{table:reuse} shows the reuse rate of entities provided
by the framework.

\begin{table}[hbtp]
  \caption{Reuse rate of entities provided by the framework}
  \label{table:reuse}
  \centering
  \begin{tabular}{lrrrr}
    \hline
      entities & total  & reused & defined & reuse rate \\
    \hline \hline
    Sorts  & 37  & 37 & 0 & 100\% \\
    Operators  & 218 & 142 & 76 & 65\%  \\
    Lemmas  & 38 & 13 & 25 & 34\% \\
    \hline
  \end{tabular}
\end{table}

We need 37 sorts to represent the TOSCA structure models and all of
them can be just instantiated and renamed from predefined sorts
provided by the framework.

We also need totally 218 predicates/operators not including
definitions of proof constants. 104 of them can be
just instantiated and renamed form predefined operators. 11
predicates, such as {\tt initcont}, {\tt contcont}, and so on, are the
same as in proofs of the CloudFormation example and so can be copied
from them.  27 state predicates are simple wrappers of other
predicates, such as {\tt wfs-*} and {\tt inv-*}.

Thereby, 76 operators are problem specific ones. 23 of them are
constructors including local state and type literals. 15 operators are
selectors such as {\tt id}, {\tt type}, {\tt state}, and ones for
links. The framework requires users to define 8 operators, i.e.\ {\tt
  init}, {\tt final}, {\tt wfs}, {\tt inv}, {\tt m}, {\tt invK}, {\tt
  getAllNDInState}, and {\tt DDSC}.

Remaining 30 operators are truly problem specific,
however almost all of them can be easily defined combining predefined
operators and can be written in only several code lines. As described in
Section~\ref{sec:TOSCAstructRep}, there are three kinds of them:
\begin{itemize}
\item Check the consistency between messages and local states of
  objects, e.g. if there is an available message then the
  corresponding capability should be available. Currently, the
  framework provides no functionality to support messaging mechanisms.
\item Check the consistency between capabilities and requirements
  connected by relationships. The framework provides many operators
  and lemmas for links but does not provide those for chains of links.
\item Check other problem-specific constraints, e.g.  every node
  should be hosted on exactly one VM node.
\end{itemize}

The proofs of the TOSCA example need 38
lemmas, 13 of which are already proved by the framework in a general
level of abstraction. Reminding 25 lemmas are required to prove
condition~(5) and (6) for invariants about
three kinds of problem specific operators described above.

%% ===============================================================
\subsubsection{Size of Codes}
%% ===============================================================
Table~\ref{table:LOC} shows the number of lines of codes we write to
very the leads-to property. The ``potential'' column shows the
potential number of lines if we write proofs not using the framework.

\begin{table}[hbtp]
  \caption{Lines of Codes}
  \label{table:LOC}
  \centering
  \begin{tabular}{llrrr}
    \hline
       & & written  & potential & reduce rate \\
    \hline \hline
    \multicolumn{2}{l}{Model} & 598 & 1784 & 66\% \\
    & Structure  & 527 & 1713 & 69\%  \\
    & Behavior  & 71 & 71 & 0\% \\
    \hline
    \multicolumn{2}{l}{Proofs} & 3991 & 4516 & 12\% \\
    \hline
  \end{tabular}
\end{table}

The representation of the TOSCA model in \cafeobj consists of about
600 lines of codes not including comment lines. About 530 lines of codes
represent the structure model and 70 lines represent twelve rules. We
estimate that the size of the structure model representation is 30\%
compared to when we would code it without using the framework, whereas
the size of the behavior model (transition rules) is the same.

The size of codes for proofs is essentially the same as when not using
the framework because reusable codes for proofs are 13 proved lemmas
provided by the framework. 

%% ===============================================================
\subsubsection{Consistent Structure of Proof}
%% ===============================================================
In addition to promoting reuse of abstract entities and lemmas, time
and efforts to develop proofs is radically reduced. Of course, it is
mainly because this is our second experience of the same problem,
whereas the previous proof scores did not have any unified policies of
splitting and so were very difficult to understand even for us. The
framework makes the new proof scores become much clear, especially
those of conditions (2)(3)(6) which should be proved for each of
twelve trans rules.

The recommended module structure also helps to make proof scores easier
to understand.  We can instantly find the place where something is
defined and can instantly imagine which parts of the proof may be
affected when something is modified.

Similarly as application frameworks of software development, our
framework not only provides reusable entities to reduce the size of
codes of proof but also assists users how to design the models and how
to systematically think and develop proofs, which brings high
productivity by minimizing development efforts and high
maintainability by consistent structure of models and proofs.

%% ===============================================================
\chapter{Related Work and Conclusion}
\label{chap:conclusion}
%% ===============================================================
%% ===============================================================
\section{Related Work}
%% ===============================================================
%% ===============================================================
\subsubsection{Reuse of Abstract Proofs}
%% ===============================================================
There are very few existing researches on reuse of proofs.  Abrial,
J. and Hallerstede, S.~\cite{AbrialH07} proposed the generic
instantiation approach for reuse of Event-B development.  The idea of
the generic instantiation is that it is a sufficient condition to
prove instantiated axioms in order to reuse proofs of a generic
machine and its refined machines. In more detail, let $M$ and $C$ be a
generic machine and a context respectively where $M$ sees $C$. Let
$s$, $c$, and $P(s,c)$ be collections of sets, constants, and axioms
defined by $C$ respectively. Similarly, let $N$ and $D$ be a concrete
machine and a context where $N$ sees $D$. Let $t$, $d$, and $Q(t,d)$
be collections of sets, constants, and axioms defined by $D$
respectively. Let $M'$ be a machine instantiated from $M$ where $s$
and $c$ are renamed as $S(t,d)$ and $C(t,d)$. Suppose that $M'$
refines $N$ and sees $D$. Then, proving $Q(t,d) \ra P(S(t,d),C(t,d))$
is a sufficient condition in order to reuse invariants and theorems of
$M$ and also of its refined machines without reproving them.

Silva, R.  and Butler, M. J.~\cite{SilvaB09} proposed to use theorem
proving to ensure the sufficient condition. Using the functionality to
rename elements (Refactory plug-in) and compose machines (Shared Event
Composition plug-in) of the Rodin platform, they defined a way of
instantiating generic machines and generating the sufficient condition
as a theorem of the concrete machine whose proof obligation will be
ensured by Rodin's theorem prover.

Tikhonova, U., et al.~\cite{TikhonovaMBAV13} applied this idea to
verify LACE DSL programs for controlling lithography machines. They
implemented transformation from LACE programs to Event-B
specifications which are composed by instantiated machines from
general ones, however, the generated theorems are too large for the
automatic provers of Rodin to discharge. They say that they do not
expect their average user to prove these theorems using interactive
provers, as it requires knowledge of propositional calculus and
understanding of proof strategies. Instead of theorem proving, they
employed evaluation of structural properties predicates in the
animation plug-in of Rodin.

Although reusing abstract entities by renaming and composing is a
similar approach to our framework, Silva, R. and Butler, M. J. did not
provide any actually reusable entities whereas our framework provides
general templates, libraries, lemmas, and a procedure reusable in a
specific domain. Tikhonova, U., et al. applied the idea to the domain
of the lithography machine control, however, they did not reuse
generally proved properties to prove the instantiated specifications.

%% ===============================================================
\subsubsection{Formal Approach for Cloud Orchestration}
%% ===============================================================
Sala{\"u}n, G., et al.~\cite{EtcheversCBP11, SalaunBCPEG13,
  SalaunEPBC13} designed a system setup protocol and demonstrated to
verify a liveness property of the protocol using their model checking
method. Although their setup protocol is essentially the same as the
behavior model of our TOSCA example in this dissertation, there are four main
differences.

Firstly, they proved one specific protocol whereas this dissertation proposes
a general way to specify, represent, and verify behavior of cloud
orchestration and also shows that it can be effectively applied to a
model of standard specification language as a non-trivial case study.

Secondly, their protocol is based on a specific implementation which
challenges distributed management of cloud resources while current
popular implementations, e.g. CloudFormation, use centralized
management. On the other hand, our model is rather abstract without
assuming distributed or centralized implementations.

Thirdly, they used model checking while we use theorem proving. They
checked about 150 different models of system including from four to
fifteen components in which from 1.4 thousand to 1.4 million
transitions are generated and checked. They found a bug of their
specification because checked models fortunately included error
cases. The model checking method can verify correctness of checked
models and so they should include all of the boundary cases. In our
formalization, the specification itself is verified by interactive
theorem proving in which all of the boundary cases are necessary in
consideration in a systematic way. It achieves structural and deep
understanding that is required to develop trusted systems.

Finally, they called a function to check the acyclicness of resource
dependency whenever a transition occurs whereas our framework provides
formalization, a template module, and lemmas to prove the invariant
property of the acyclicness.

%% ===============================================================
\subsubsection{Dependency Management between Internal Resources}
%% ===============================================================
CloudFormation and OpenStack Heat can manage resources on the IaaS
layer, however, they support to manage dependencies between resources
in VMs. For example, suppose a software component (SC$_1$) on a
VM (VM$_1$) can be activated only after waiting for activation of
another component (SC$_2$) on another VM (VM$_2$), CloudFormation
requires a pair of special purpose resources, namely, {\it
  WaitCondition} and {\it WaitConditionHandle}. VM$_1$ should be
declared to depend on the WaitCondition resource. The corresponding
WaitConditionHandle resource provides a URL that should be passed to
the script for initializing VM$_2$. When SC$_2$ is successfully
activated, the script sends a success signal to the URL, which causes
the WaitCondition become active and then creation of dependent VM$_1$
starts. This style of management includes several problems. Firstly,
it forces complicated and troublesome coding of operations.  Secondly,
although only SC$_1$ should wait for SC$_2$, all the other components on
VM$_1$ are also forced to wait. This causes unnecessary slowdown of
system creation. Thirdly, it tends to make cyclic
dependencies. Suppose SC$_2$ should also wait for another component
SC$_3$ on VM$_1$. Although the dependency among components, SC$_1$,
SC$_2$, and SC$_3$ is acyclic, the dependency between VMs is
cyclic. This may be solved by splitting VM$_1$ to two VMs, one is for
SC$_1$ and another is for SC$_3$, but it causes increased cost and
delayed creation. Our formalization can manage any types of resources
and solve this kind of problems in a smarter way because it can manage
finer grained dependencies, which is shown as invocation rules
described in Section \ref{sec:TOSCAbehavior}.

%% ===============================================================
\subsubsection{Next Version of OASIS TOSCA}
%% ===============================================================
OASIS TOSCA TC currently discusses the next version (v1.1) to define a
standard set of nodes, relationships, and
operations~\cite{TOSCAYAML}. It is planned to use state machines to
describe behavior of the standard operations, which is a similar
approach as ours. However, the usage is limited to clarify the
descriptions of the standard and the way for type architects to define
behavior of their own types is out of the scope of standardization. We
provide a way to specify behavior of types and show that it can be
used for verification.

%% ===============================================================
\section{Future Issues}
%% ===============================================================
While more than six seventh of operators and one third of lemmas for
the TOSCA example can be easily defined using predefined operators and
proved lemmas, several extensions of our framework are desired to
further reduce problem specific coding and proving. The general formalization
for messaging mechanism and chains of links is required.

CloudFormation provides a default roll back mechanism when an
operation failure occurs but it requires manual operations when the
roll back also fails. On the other hand, the current version of TOSCA
does not manage operation failures and it focuses on declaratively
defining expected configurations of cloud systems. A possible
future extension of TOSCA may be to define alternative configurations
in failure cases, which our
formalization can be extended to handle.

In this dissertation, we explain our framework using examples of system setup
operations of cloud systems because cloud orchestration tools
currently focus on them. However, TOSCA is designed to be used for any
types of system operations such as scale-out and scale-in. One of the
main difficulties to specify scaling operations is that they
dynamically change the structure of cloud systems, for which our
framework should be extended from two points of view. Firstly, some
additional guidance is required to design state measuring functions,
especially for the case of scale-out where the number of resources in
the system will increase. Secondly, while the user of our framework is
left responsible for proving the invariant property of $noCycle$, it
may be not a trivial work as to dynamic structure. Some constraint
should be introduced in the cloud system structure to keep acyclicness
of dependency. One possible solution is to assume a partial order of
types of objects and to allow transition rules to produce dependency
only in the descending order. Two techniques to prove the invariant
property of $noCycle$ described in Section~\ref{sec:cyclelemma} will
be also effective for the solution.

Although the framework focuses on leads-to properties, which is one of
the main contribution of this dissertation, safety properties are of another
category of important properties that automated system operations
should have. The framework also supports to verify invariant properties
which may represent various safety properties of cloud orchestration,
however, the proof procedure of the framework should be extended to
guide verification of typical safety properties of this domain.

Finally, the case study shows the high reuse rate of the abstract
entities and proved lemmas provided by the framework, however, its
high productivity and maintainability is based on the subjective
evaluation of the author. An objective bench marking by novice
proof engineers is necessary.

%% ===============================================================
\section{Conclusion}
%% ===============================================================
A general formalization of declarative cloud orchestration is proposed
and a framework is provided for interactive developing proof
scores. The framework provides (1) a general way to formalize
specifications of different kinds of cloud orchestration tools and (2)
a procedure for how to verifying leads-to properties, as well as
invariant properties, of formalized specifications.  It also provides
(3) general templates and libraries of formal descriptions for
specifying orchestration of cloud systems and (4) proved lemmas for
general predicates of the libraries to be used for verification.

The framework has been applied to the verification of specifications
of AWS CloudFormation and also of OASIS TOSCA. The provided procedure
systematically assists the verification process and makes its generic
part be routine work whose efforts are reduced by the provided logic
templates and predicate libraries. As a result, a verification
engineer can concentrate on the work specific to the individual
problem, which brings high productivity by minimizing development
efforts and high maintainability by consistent structure of models and
proofs.

A related work applied their model checking method to a typical
problem in the domain of cloud orchestration, in which many of
finite-state systems were checked. Our framework is more general to be
applied to different kinds of models in the domain and to be used for
interactive theorem proving which can verify systems of arbitrary many
number of states in a significantly systematic way.

An example of usage of our formalization shows a general way to manage
dependencies of cloud resources which is a smarter one than that of
the most popular tool, AWS CloudFormation.

It is also demonstrated that the framework can be used to specify,
represent, and verify the behavior models of the standard
specification language, OASIS TOSCA, of cloud orchestration where the
standard has not yet provided any ways to do so.

The major contributions of this dissertation are that (1) it introduces the
idea of frameworks from software development to proof development
which results in high productivity and high maintainability of proofs
and (2) it shows that the framework can be effectively applied to a
non-trivial problem, that is, to specify, represent, and verify the
behavior models of the standard specification language of cloud
orchestration.

All of the \cafeobj codes of the framework and example proof scores in this dissertation
can be downloaded at \url{https://github.com/yuki-yoshida/JAIST}.

\appendix

\bibliographystyle{plain}
\bibliography{DThesis}

\begin{publication}
\addcontentsline{toc}{chapter}{Publications}

\item
Hiroyuki YOSHIDA, Kazuhiro OGATA, and Kokichi FUTATSUGI,
Formalization and Verification of Declarative Cloud Orchestration,
\emph{Formal Methods and Software Engineering - 17th International Conference
               on Formal Engineering Methods, {ICFEM} 2015, Proceedings}, 
Lecture Notes in Computer Science 9407,
pp 33-49, 
Springer,
Paris, France,
November 3-5, 2015

\end{publication}
\end{document}
